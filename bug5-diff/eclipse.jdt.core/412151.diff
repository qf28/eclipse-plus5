commit ad2aca1c2960107e50013b8f7866125addb168b4
Author: Jesper Moller <jesper@selskabet.org>
Date:   Sat Oct 5 06:38:54 2013 +0530

    Fixed Bug 412151 - [1.8][compiler] Check repeating annotation's
    collection type

16	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
564	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
38	13	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
150	17	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
8	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
7	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
69	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
9	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 3f12316..003303f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -425,6 +425,10 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("CodeCannotBeReached", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("CodeSnippetMissingClass", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("CodeSnippetMissingMethod", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
+		expectedProblemAttributes.put("ContainingAnnotationHasNonDefaultMembers", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("ContainingAnnotationHasShorterRetention", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("ContainingAnnotationHasWrongValueType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("ContainingAnnotationMustHaveValue", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ContradictoryNullAnnotations", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ContradictoryNullAnnotationsOnBound", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ComparingIdentical", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
@@ -915,6 +919,10 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RequiredNonNullButProvidedSpecdNullable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ReferenceToForwardTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("RepeatableAnnotationHasTargets", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("RepeatableAnnotationIsDocumented", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("RepeatableAnnotationIsInherited", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("RepeatableAnnotationTargetMismatch", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RepeatedAnnotationWithContainerAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ResourceHasToImplementAutoCloseable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ReturnTypeAmbiguous", DEPRECATED);
@@ -1231,6 +1239,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ConstructionTypeMismatch", SKIP);
 		expectedProblemAttributes.put("ConflictingInheritedNullAnnotations", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ConstructorReferenceNotBelow18", SKIP);
+		expectedProblemAttributes.put("ContainingAnnotationHasNonDefaultMembers", SKIP);
+		expectedProblemAttributes.put("ContainingAnnotationHasShorterRetention", SKIP);
+		expectedProblemAttributes.put("ContainingAnnotationHasWrongValueType", SKIP);
+		expectedProblemAttributes.put("ContainingAnnotationMustHaveValue", SKIP);
 		expectedProblemAttributes.put("ContradictoryNullAnnotations", SKIP);
 		expectedProblemAttributes.put("ContradictoryNullAnnotationsOnBound", SKIP);
 		expectedProblemAttributes.put("ConstructorVarargsArgumentNeedCast", new ProblemAttributes(JavaCore.COMPILER_PB_VARARGS_ARGUMENT_NEED_CAST));
@@ -1709,6 +1721,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ReferenceExpressionReturnNullRedefUnchecked", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_UNCHECKED_CONVERSION));
 		expectedProblemAttributes.put("ReferenceToForwardField", SKIP);
 		expectedProblemAttributes.put("ReferenceToForwardTypeVariable", SKIP);
+		expectedProblemAttributes.put("RepeatableAnnotationHasTargets", SKIP);
+		expectedProblemAttributes.put("RepeatableAnnotationIsDocumented", SKIP);
+		expectedProblemAttributes.put("RepeatableAnnotationIsInherited", SKIP);
+		expectedProblemAttributes.put("RepeatableAnnotationTargetMismatch", SKIP);
 		expectedProblemAttributes.put("RepeatedAnnotationWithContainerAnnotation", SKIP);
 		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_ANNOTATION_INFERENCE_CONFLICT));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
index 56b08cc..1f2f5e0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/RepeatableAnnotationTest.java
@@ -11,6 +11,7 @@
  *
  * Contributors:
  *     Jesper S Moller - initial API and implementation
+ *     					Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -273,4 +274,567 @@ public class RepeatableAnnotationTest extends AbstractComparableTest {
 					}
 			});
 	}
+	// Bug 412151: [1.8][compiler] Check repeating annotation's collection type
+	// 412151: The collections type's (TC) declaration must have a array of Ts as its value() - with Foo and FooContainer in same compilation round
+	public void test010() {
+		this.runNegativeTest(
+			new String[] {
+			"Foo.java",
+			"@interface FooContainer {\n" +
+			"}\n" +
+			"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+			"@interface Foo {}\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 3)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"The containing annotation @FooContainer must declare a member value()\n" + 
+		"----------\n");
+	}
+	// 412151: The collections type's (TC) declaration must have a array of Ts as its value() - with Foo and FooContainer in same compilation round
+	public void test011() {
+		this.runNegativeTest(
+			new String[] {
+			"Foo.java",
+			"@interface FooContainer {\n" +
+			"    int[] value();\n" +
+			"}\n" +
+			"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+			"@interface Foo {}\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 4)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"The value method in the containing annotation @FooContainer must be of type Foo[] but is int[]\n" + 
+		"----------\n");
+	}
+	// 412151: The collections type's (TC) declaration must have a array of Ts as its value() - with Foo and FooContainer in same compilation round
+	public void test012() {
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"@interface FooContainer {\n" +
+				"    Foo[][] value();\n" +
+				"}\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@interface Foo {}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in Foo.java (at line 2)\n" + 
+			"	Foo[][] value();\n" + 
+			"	^^^^^^^\n" + 
+			"Invalid type Foo[][] for the annotation attribute FooContainer.value; only primitive type, String, Class, annotation, enumeration are permitted or 1-dimensional arrays thereof\n" + 
+			"----------\n" + 
+			"2. ERROR in Foo.java (at line 4)\n" + 
+			"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+			"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+			"The value method in the containing annotation @FooContainer must be of type Foo[] but is Foo[][]\n" + 
+			"----------\n"
+		);
+	}
+	// 412151: Any methods declared by TC other than value() have a default value (§9.6.2).
+	public void test013() {
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"@interface FooContainer {\n" +
+				"    Foo[] value();\n" +
+				"    int hasDefaultValue() default 1337;\n" +
+				"    int doesntHaveDefaultValue();\n" +
+				"}\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@interface Foo {}\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 6)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"The containing annotation @FooContainer must declare a default value for the annotation attribute \'doesntHaveDefaultValue\'\n" + 
+		"----------\n");
+	}
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T ()
+	public void test014() {
+		this.runConformTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@Retention(RetentionPolicy.CLASS)\n" +
+				"@interface FooContainer {\n" +
+				"    Foo[] value();\n" +
+				"}\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Retention(RetentionPolicy.CLASS)\n" +
+				"@interface Foo {\n" +
+				"}\n"
+			}, 
+		"");
+	}
+
+	// 
+	public void test015() {
+		// These are fine:
+		this.runConformTest(
+			new String[] {
+					"FooContainer.java",
+					"public @interface FooContainer {\n" +
+					"	Foo[] value();\n" +
+					"}\n",
+					"Foo.java",
+					"@java.lang.annotation.Repeatable(FooContainer.class) public @interface Foo {\n" +
+					"}\n"
+				}, 
+				"");
+		// This changes FooContainer without re-checking Foo
+		this.runConformTest(
+				new String[] {
+						"FooContainer.java",
+						"public @interface FooContainer {\n" +
+						"	int[] value();\n" +
+						"}\n"
+					},
+					"",
+					null,
+					false,
+					null);
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"@Foo @Foo public class X { /* Problem since Foo now uses FooContainer which doesn't work anymore*/\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	@Foo @Foo public class X { /* Problem since Foo now uses FooContainer which doesn\'t work anymore*/\n" + 
+			"	^^^^\n" + 
+			"The value method in the containing annotation @FooContainer must be of type Foo[] but is int[]\n" + 
+			"----------\n",
+			null, false /* don't flush*/);
+	}
+
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T ()
+	// Base example, both targets are specified
+	public void test016() {
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@Retention(RetentionPolicy.SOURCE)\n" +
+				"@interface FooContainer { Foo[] value(); }\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Retention(RetentionPolicy.RUNTIME)\n" +
+				"@interface Foo { }\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 5)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"Retention \'RUNTIME\' of @Foo is longer than the retention of the containing annotation @FooContainer, which is \'SOURCE\'\n" + 
+		"----------\n");
+	}
+
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T ()
+	// Only specified on FooContainer
+	public void test017() {
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@Retention(RetentionPolicy.SOURCE)\n" +
+				"@interface FooContainer { Foo[] value(); }\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@interface Foo { }\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 5)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"Retention \'CLASS\' of @Foo is longer than the retention of the containing annotation @FooContainer, which is \'SOURCE\'\n" + 
+		"----------\n");
+	}
+
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T ()
+	// Only specified on Foo
+	public void test018() {
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@interface FooContainer { Foo[] value(); }\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Retention(RetentionPolicy.RUNTIME)\n" +
+				"@interface Foo { }\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 4)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"Retention \'RUNTIME\' of @Foo is longer than the retention of the containing annotation @FooContainer, which is \'CLASS\'\n" + 
+		"----------\n");
+	}
+
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T ()
+	// Only specified on Foo - but positive
+	public void test019() {
+		this.runConformTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@interface FooContainer { Foo[] value(); }\n" +
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Retention(RetentionPolicy.SOURCE)\n" +
+				"@interface Foo { }\n"
+			});
+	}
+
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T
+	// Only specified on FooContainer, separate compilation
+	public void test020() {
+		this.runConformTest(
+			new String[] {
+					"FooContainer.java",
+					"import java.lang.annotation.Retention;\n" + 
+					"import java.lang.annotation.RetentionPolicy;\n" + 
+					"@Retention(RetentionPolicy.SOURCE)\n" +
+					"public @interface FooContainer { Foo[] value(); }\n",
+					"Foo.java",
+					"import java.lang.annotation.Retention;\n" + 
+					"import java.lang.annotation.RetentionPolicy;\n" + 
+					"@Retention(RetentionPolicy.SOURCE)\n" +
+					"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+					"public @interface Foo { }\n"
+				});
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"public @interface Foo { } // If omitted, retention is class\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 1)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"Retention \'CLASS\' of @Foo is longer than the retention of the containing annotation @FooContainer, which is \'SOURCE\'\n" + 
+		"----------\n",
+		null, false /* don't flush*/);
+	}
+
+	// 412151: The @Retention meta-annotation of TC must at least include the retention of T ()
+	// Only specified on Foo, separate compilation
+	public void test021() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"public @interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"public @interface Foo { }\n"
+			});
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Retention;\n" + 
+				"import java.lang.annotation.RetentionPolicy;\n" + 
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Retention(RetentionPolicy.RUNTIME)\n" +
+				"@interface Foo { }\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 3)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"Retention \'RUNTIME\' of @Foo is longer than the retention of the containing annotation @FooContainer, which is \'CLASS\'\n" + 
+		"----------\n",
+		null, false /* don't flush*/);
+	}
+
+	// 412151: TC's @Targets, if specified, must be a subset or the same as T's @Targets
+	// TC's @Targets, if specified, must be a subset or the same as T's @Targets. Simple test
+	public void test022() {
+		this.runNegativeTest(
+			new String[] {
+				"FooContainer.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})\n" +
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Target({ElementType.FIELD})\n" +
+				"@interface Foo { }\n"
+			},
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 3)\n" + 
+		"	public @java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                        ^^^^^^^^^^^^^^^^^^\n" + 
+		"The containing annotation @FooContainer is allowed at targets where the repeatable annotation @Foo is not: TYPE, METHOD\n" + 
+		"----------\n");
+	}
+
+	// 412151: TC's @Targets, if specified, must be a subset or the same as T's @Targets
+	// TC's @Targets, if specified, must be a subset or the same as T's @Targets. Test this as a separate pass, so that
+	// FooContainer is loaded from binary.
+	public void test023() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @Target({ElementType.METHOD})\n" +
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @Target({ElementType.METHOD})\n" +
+				"@interface Foo { }\n"
+			});
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@java.lang.annotation.Target({ElementType.FIELD})\n" +
+				"@interface Foo { }\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 3)\n" + 
+		"	public @java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                        ^^^^^^^^^^^^^^^^^^\n" + 
+		"The containing annotation @FooContainer is allowed at targets where the repeatable annotation @Foo is not: METHOD\n" + 
+		"----------\n",
+		null, false /* don't flush*/);
+	}
+
+	// 412151: TC's @Targets, if specified, must be a subset or the same as T's @Targets
+	// TC's may target ANNOTATION_TYPE but that should match TYPE for T, since it's a superset
+	public void test024() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"import java.lang.annotation.ElementType;\n" + 
+				"@java.lang.annotation.Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n" +
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"import java.lang.annotation.ElementType;\n" + 
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@java.lang.annotation.Target({ElementType.METHOD, ElementType.TYPE})\n" +
+				"@interface Foo { }\n"
+			});
+	}
+
+	// 412151: TC's @Targets, if specified, must be a subset or the same as T's @Targets
+	// Test that all ElementTypes can be reported
+	public void test025() {
+		this.runNegativeTest(
+			new String[] {
+				"FooContainer.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.ANNOTATION_TYPE, ElementType.PACKAGE, ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n" +
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"public @java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@Target({})\n" +
+				"@interface Foo { }\n"
+			},
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 3)\n" + 
+		"	public @java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                        ^^^^^^^^^^^^^^^^^^\n" + 
+		"The containing annotation @FooContainer is allowed at targets where the repeatable annotation @Foo is not: TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, TYPE_USE\n" + 
+		"----------\n");
+	}
+
+	// 412151: TC's @Targets, if specified, must be a subset or the same as T's @Targets
+	// TC's has no @Targets (=everywhere), but @Foo has, then complain.
+	public void test026() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@interface Foo { }\n"
+			});
+		this.runNegativeTest(
+			new String[] {
+				"Foo.java",
+				"import java.lang.annotation.Target;\n" + 
+				"import java.lang.annotation.ElementType;\n" + 
+				"@java.lang.annotation.Repeatable(FooContainer.class)\n" +
+				"@java.lang.annotation.Target({ElementType.FIELD})\n" +
+				"@interface Foo { }\n"
+			}, 
+		"----------\n" + 
+		"1. ERROR in Foo.java (at line 3)\n" + 
+		"	@java.lang.annotation.Repeatable(FooContainer.class)\n" + 
+		"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+		"The repeatable annotation @Foo has a @Target annotation, @FooContainer does not\n" + 
+		"----------\n",
+		null, false /* don't flush*/);
+	}
+
+	// 412151: If T is @Documented, then TC should also be Documented
+	public void test027() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"@java.lang.annotation.Documented @interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@java.lang.annotation.Documented @interface Foo { }\n"});
+	}
+	
+	// 412151: If T is @Documented, then TC should also be Documented, OK for TC to be documented while T is not
+	public void test028() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"@java.lang.annotation.Documented @interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@interface Foo { }\n"});
+	}
+
+	// 412151: If T is @Documented, then TC should also be Documented
+	public void test029() {
+		this.runNegativeTest(
+			new String[] {
+				"FooContainer.java",
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@java.lang.annotation.Repeatable(FooContainer.class) @java.lang.annotation.Documented\n" +
+				"@interface Foo { }\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in Foo.java (at line 1)\n" + 
+			"	@java.lang.annotation.Repeatable(FooContainer.class) @java.lang.annotation.Documented\n" + 
+			"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+			"The repeatable annotation @Foo is marked @Documented, but the containing annotation @FooContainer is not\n" + 
+			"----------\n");
+	}
+
+	// 412151: If T is @Documented, then TC should also be Documented - check from previous compilation
+	public void test030() {
+		this.runConformTest(
+				new String[] {
+					"FooContainer.java",
+					"@java.lang.annotation.Documented @interface FooContainer { Foo[] value(); }\n",
+					"Foo.java",
+					"@java.lang.annotation.Documented @interface Foo { }\n"
+				});
+			this.runConformTest(
+				new String[] {
+					"Foo.java",
+					"public @java.lang.annotation.Documented @java.lang.annotation.Repeatable(FooContainer.class)\n" +
+					"@interface Foo { }\n"
+				},
+				"",
+				null,
+				false,
+				null);
+	}
+
+	// 412151: If T is @Inherited, then TC should also be Inherited
+	public void test031() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"@java.lang.annotation.Inherited @interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@java.lang.annotation.Inherited @interface Foo { }\n"});
+	}
+
+	// 412151: If T is @Inherited, then TC should also be Inherited, OK for TC to be inherited while T is not.
+	public void test032() {
+		this.runConformTest(
+			new String[] {
+				"FooContainer.java",
+				"@java.lang.annotation.Inherited @interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@interface Foo { }\n"});
+	}
+	// 412151: If T is @Inherited, then TC should also be Inherited
+	public void test033() {
+		this.runNegativeTest(
+			new String[] {
+				"FooContainer.java",
+				"@interface FooContainer { Foo[] value(); }\n",
+				"Foo.java",
+				"@java.lang.annotation.Repeatable(FooContainer.class) @java.lang.annotation.Inherited\n" +
+				"@interface Foo { }\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in Foo.java (at line 1)\n" + 
+			"	@java.lang.annotation.Repeatable(FooContainer.class) @java.lang.annotation.Inherited\n" + 
+			"	                                 ^^^^^^^^^^^^^^^^^^\n" + 
+			"The repeatable annotation @Foo is marked @Inherited, but the containing annotation @FooContainer is not\n" + 
+			"----------\n");
+	}
+
+	// 412151: If T is @Inherited, then TC should also be Inherited - check from previous compilation
+	public void test034() {
+		this.runConformTest(
+				new String[] {
+					"FooContainer.java",
+					"@java.lang.annotation.Inherited @interface FooContainer { Foo[] value(); }\n",
+					"Foo.java",
+					"@java.lang.annotation.Inherited @interface Foo { }\n"
+				});
+			this.runConformTest(
+				new String[] {
+					"Foo.java",
+					"public @java.lang.annotation.Inherited @java.lang.annotation.Repeatable(FooContainer.class)\n" +
+					"@interface Foo { }\n"
+				},
+				"",
+				null,
+				false,
+				null);
+	}
+	// 412151: Ensure no double reporting for bad target.
+	public void test035() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Repeatable;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.FIELD)\n" +
+				"@interface TC {\n" +
+				"	T [] value();\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE)\n" +
+				"@Repeatable(TC.class)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"@T @T // we used to double report here.\n" +
+				"public class X { \n" +
+				"	X f;\n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 9)\n" + 
+			"	@Repeatable(TC.class)\n" + 
+			"	            ^^^^^^^^\n" + 
+			"The containing annotation @TC is allowed at targets where the repeatable annotation @T is not: FIELD\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 12)\n" + 
+			"	@T @T // we used to double report here.\n" + 
+			"	^^\n" + 
+			"The repeatable annotation @T is disallowed for this location since its container annotation @TC is disallowed at this location\n" + 
+			"----------\n");
+	}	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 9c71018..521e872 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -199,7 +199,15 @@
  *									DuplicateAnnotationNotMarkedRepeatable
  *									DisallowedTargetForContainerAnnotation
  *									RepeatedAnnotationWithContainerAnnotation
- *******************************************************************************/
+ *									ContainingAnnotationMustHaveValue
+ *									ContainingAnnotationHasNonDefaultMembers
+ *									ContainingAnnotationHasWrongValueType
+ *								 	ContainingAnnotationHasShorterRetention
+ *									RepeatableAnnotationHasTargets
+ *									RepeatableAnnotationTargetMismatch
+ *									RepeatableAnnotationIsDocumented
+ *									RepeatableAnnotationIsInherited
+*******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
@@ -1620,6 +1628,35 @@ void setSourceStart(int sourceStart);
 	int RepeatedAnnotationWithContainerAnnotation = TypeRelated + 899;
 	
 	/**
+	 * External problems -- These are problems defined by other plugins
+	 */
+
+	/** @since 3.2 */
+	int ExternalProblemNotFixable = 900;
+
+	// indicates an externally defined problem that has a quick-assist processor
+	// associated with it
+	/** @since 3.2 */
+	int ExternalProblemFixable = 901;
+	
+	/** @since 3.9 BETA_JAVA8 */
+	int ContainingAnnotationHasWrongValueType = TypeRelated + 902;
+	/** @since 3.9 BETA_JAVA8 */
+	int ContainingAnnotationMustHaveValue = TypeRelated + 903;
+	/** @since 3.9 BETA_JAVA8 */
+	int ContainingAnnotationHasNonDefaultMembers = TypeRelated + 904;
+	/** @since 3.9 BETA_JAVA8 */
+	int ContainingAnnotationHasShorterRetention = TypeRelated + 905;
+	/** @since 3.9 BETA_JAVA8 */
+	int RepeatableAnnotationHasTargets = TypeRelated + 906;
+	/** @since 3.9 BETA_JAVA8 */
+	int RepeatableAnnotationTargetMismatch = TypeRelated + 907;
+	/** @since 3.9 BETA_JAVA8 */
+	int RepeatableAnnotationIsDocumented = TypeRelated + 908;
+	/** @since 3.9 BETA_JAVA8 */
+	int RepeatableAnnotationIsInherited = TypeRelated + 909;
+	
+	/**
 	 * Errors/warnings from annotation based null analysis
 	 */
 	/** @since 3.8 */
@@ -1751,16 +1788,4 @@ void setSourceStart(int sourceStart);
 	int IllegalStrictfpForAbstractInterfaceMethod = MethodRelated + 1057;
 	/** @since 3.9 BETA_JAVA8 */
 	int IllegalDefaultModifierSpecification = MethodRelated + 1058;
-
-	/**
-	 * External problems -- These are problems defined by other plugins
-	 */
-
-	/** @since 3.2 */
-	int ExternalProblemNotFixable = 900;
-
-	// indicates an externally defined problem that has a quick-assist processor
-	// associated with it
-	/** @since 3.2 */
-	int ExternalProblemFixable = 901;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index fcb81fa..5c47287 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -25,6 +25,7 @@
  *     Jesper S Moller - Contributions for
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
+ *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -796,6 +797,18 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 
 		if (copySE8AnnotationsToType)
 			copySE8AnnotationsToType(scope, recipient, sourceAnnotations);
+
+		if (annotations != null && length > 0 && recipient != null && recipient.isAnnotationType()) {
+			// See if this is meta-annotated as repeatable and if so validate constraints.
+			for (int i = 0; i < length; i++) {
+				Annotation annotation = sourceAnnotations[i];
+				MemberValuePair[] valuePairs = annotation.memberValuePairs();
+				ReferenceBinding annotationType = annotations[i] != null ? annotations[i].getAnnotationType() : null;
+				if (annotationType != null && annotationType.id == TypeIds.T_JavaLangAnnotationRepeatable && valuePairs != null && valuePairs.length > 0) {
+					annotation.checkRepeatableAnnotation(valuePairs[0], scope, valuePairs[0].compilerElementPair.value);
+				}
+			}
+		}
 		
 		// check duplicate annotations
 		if (annotations != null && length > 1) {
@@ -817,7 +830,8 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 								// in a map of (container's ReferenceBinding -> the repeated source Annotation)
 								if (implicitContainerAnnotations == null) implicitContainerAnnotations = new HashMap(3);
 								implicitContainerAnnotations.put(resolvedContainer, sourceAnnotations[i]);
-								Annotation.checkAnnotationContainerTarget(sourceAnnotations[i], scope, annotationType, resolvedContainer);
+								// Validate the repeated *use* of a repeatable annotation.
+								Annotation.checkContainingAnnotation(sourceAnnotations[i], scope, resolvedContainer, annotationType);
 							}
 						} else {
 							foundDuplicate = true;
@@ -833,6 +847,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 					scope.problemReporter().duplicateAnnotation(sourceAnnotations[i], scope.compilerOptions().sourceLevel);
 				}
 			}
+			// Check for presence of repeating annotation together with the containing annotation
 			if (implicitContainerAnnotations != null) {
 				for (int i = 0; i < length; i++) {
 					if (distinctAnnotations[i] == null) continue;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 609f370..d101b95 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -27,6 +27,7 @@
  *                          Bug 414384 - [1.8] type annotation on abbreviated inner class is not marked as inner type
  *      Jesper S Moller <jesper@selskabet.org> -  Contributions for
  *                          Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
+#							Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -359,12 +360,6 @@ public abstract class Annotation extends Expression {
 			case TypeIds.T_JavaLangAnnotationInherited :
 				tagBits |= TagBits.AnnotationInherited;
 				break;
-			case TypeIds.T_JavaLangAnnotationRepeatable :
-				Object value = valueAttribute.compilerElementPair.value;
-				if (this.recipient instanceof ReferenceBinding && value instanceof ReferenceBinding) {
-					((ReferenceBinding) this.recipient).setContainerAnnotation((ReferenceBinding)value);  
-				}
-				break;
 			case TypeIds.T_JavaLangOverride :
 				tagBits |= TagBits.AnnotationOverride;
 				break;
@@ -400,6 +395,155 @@ public abstract class Annotation extends Expression {
 		return tagBits;
 	}
 
+	static String getRetentionName(long tagBits) {
+		if ((tagBits & TagBits.AnnotationRuntimeRetention) == TagBits.AnnotationRuntimeRetention) {
+			// TagBits.AnnotationRuntimeRetention combines both TagBits.AnnotationClassRetention & TagBits.AnnotationSourceRetention
+			return new String(UPPER_RUNTIME);
+		} else if ((tagBits & TagBits.AnnotationSourceRetention) != 0) {
+			return new String(UPPER_SOURCE);
+		} else {
+			return new String(TypeConstants.UPPER_CLASS);
+		}
+	}
+
+	private static long getAnnotationRetention(ReferenceBinding binding) {
+		long retention = binding.getAnnotationTagBits() & TagBits.AnnotationRetentionMASK;
+		// Retention defaults to CLASS
+		return retention != 0 ? retention : TagBits.AnnotationClassRetention;
+	}
+	
+	public void checkRepeatableAnnotation(ASTNode valueAttribute, Scope scope, Object containingBinding) {
+		if (! (this.recipient instanceof ReferenceBinding && containingBinding instanceof ReferenceBinding)) return; // Has deeper problems...
+		ReferenceBinding containing = (ReferenceBinding)containingBinding;
+		ReferenceBinding repeatableAnnotation = (ReferenceBinding) this.recipient;
+		repeatableAnnotation.setContainingAnnotation(containing);
+
+		checkContainingAnnotation(valueAttribute, scope, containing, repeatableAnnotation);
+	}
+
+	public static void checkContainingAnnotation(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {
+		MethodBinding[] annotationMethods = container.methods();
+		boolean sawValue = false;
+		for (int i = 0, length = annotationMethods.length; i < length; ++i) {
+			MethodBinding method = annotationMethods[i];
+			if (CharOperation.equals(method.selector, TypeConstants.VALUE)) {
+				sawValue = true;
+				if (method.returnType.isArrayType() && method.returnType.dimensions() == 1) {
+					ArrayBinding array = (ArrayBinding) method.returnType;
+					if (TypeBinding.equalsEquals(array.elementsType(), repeatableAnnotation)) continue;
+				}
+				scope.problemReporter().containingAnnotationHasWrongValueType(markerNode, container, repeatableAnnotation, method.returnType);
+			} else {
+				// Not the value() - must have default (or else isn't suitable as container
+				if ((method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0) {
+					scope.problemReporter().containingAnnotationHasNonDefaultMembers(markerNode, container, method.selector);
+				}
+			}
+		}
+		if (!sawValue) {
+			scope.problemReporter().containingAnnotationMustHaveValue(markerNode, container);
+		}
+		
+		checkContainingAnnotationRetention(markerNode, scope, container, repeatableAnnotation);
+		if (markerNode instanceof Annotation)
+			checkContainingAnnotationTarget((Annotation) markerNode, (BlockScope) scope, (TypeBinding) container, repeatableAnnotation);
+		else
+			checkContainingAnnotationTarget(markerNode, scope, container, repeatableAnnotation);
+		checkContaintAnnotationDocumented(markerNode, scope, container, repeatableAnnotation);
+		checkContaintAnnotationInherited(markerNode, scope, container, repeatableAnnotation);
+	}
+
+	// This is for error reporting for bad targets at the repeated annotation use site (as opposed to repeatable annotation type declaration site) - Leads to better message.
+	public static void checkContainingAnnotationTarget(Annotation annotation, BlockScope scope, TypeBinding containerAnnotationType, TypeBinding annotationType) {
+		// check (meta)target compatibility
+		if (!annotationType.isValidBinding()) {
+			// no need to check annotation usage if missing
+			return;
+		}
+		if (! isAnnotationTargetAllowed(annotation, scope, containerAnnotationType, annotation.recipient.kind())) {
+			scope.problemReporter().disallowedTargetForContainerAnnotation(annotation, containerAnnotationType);
+		}
+	}
+	
+	// This is for error reporting for bad targets at annotation type declaration site (as opposed to the repeat site)
+	private static void checkContainingAnnotationTarget(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {
+		long tagBits = repeatableAnnotation.getAnnotationTagBits();
+		if ((tagBits & TagBits.AnnotationTargetMASK) != 0) { 
+			long containingTagBits = container.getAnnotationTagBits();
+			if ((containingTagBits & TagBits.AnnotationTargetMASK) == 0) {
+				scope.problemReporter().repeatableAnnotationHasTargets(markerNode, repeatableAnnotation, container);
+			} else {
+				final long targets = tagBits & TagBits.AnnotationTargetMASK;
+				final long containingTargets = containingTagBits & TagBits.AnnotationTargetMASK;
+				
+				if ((containingTargets & ~targets) != 0) {
+					class MissingTargetBuilder {
+						StringBuffer targetBuffer = new StringBuffer();
+						void check(long targetMask, char[] targetName) {
+							if ((containingTargets & targetMask & ~targets) != 0) {
+								add(targetName);
+							}
+						}
+						void checkAnnotationType(char[] targetName) {
+							if ((containingTargets & TagBits.AnnotationForAnnotationType) != 0 &&
+									((targets & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType))) == 0) {
+								add(targetName);
+							}
+						}
+						private void add(char[] targetName) {
+							if (this.targetBuffer.length() != 0) {
+								this.targetBuffer.append(", "); //$NON-NLS-1$
+							}
+							this.targetBuffer.append(targetName);
+						}
+						public String toString() {
+							return this.targetBuffer.toString();
+						}
+						public boolean hasError() {
+							return this.targetBuffer.length() != 0;
+						}
+					}
+					MissingTargetBuilder builder = new MissingTargetBuilder();
+
+					builder.check(TagBits.AnnotationForType, TypeConstants.TYPE);
+					builder.check(TagBits.AnnotationForField, TypeConstants.UPPER_FIELD);
+					builder.check(TagBits.AnnotationForMethod, TypeConstants.UPPER_METHOD);
+					builder.check(TagBits.AnnotationForParameter, TypeConstants.UPPER_PARAMETER);
+					builder.check(TagBits.AnnotationForConstructor, TypeConstants.UPPER_CONSTRUCTOR);
+					builder.check(TagBits.AnnotationForLocalVariable, TypeConstants.UPPER_LOCAL_VARIABLE);
+					builder.checkAnnotationType(TypeConstants.UPPER_ANNOTATION_TYPE);
+					builder.check(TagBits.AnnotationForPackage, TypeConstants.UPPER_PACKAGE);
+					builder.check(TagBits.AnnotationForTypeParameter, TypeConstants.TYPE_PARAMETER_TARGET);
+					builder.check(TagBits.AnnotationForTypeUse, TypeConstants.TYPE_USE_TARGET);
+					if (builder.hasError()) {
+						scope.problemReporter().repeatableAnnotationTargetMismatch(markerNode, repeatableAnnotation, container, builder.toString());
+					}
+				}
+			}
+		}
+	}
+
+	private static void checkContaintAnnotationDocumented(ASTNode markerNode, Scope scope, ReferenceBinding containing, ReferenceBinding repeatableAnnotation) {
+		if ((repeatableAnnotation.getAnnotationTagBits() & TagBits.AnnotationDocumented) != 0 && (containing.getAnnotationTagBits() & TagBits.AnnotationDocumented) == 0) {
+			scope.problemReporter().repeatableAnnotationIsDocumented(markerNode, repeatableAnnotation, containing);
+		}
+	}
+
+	private static void checkContaintAnnotationInherited(ASTNode markerNode, Scope scope, ReferenceBinding containing, ReferenceBinding repeatableAnnotation) {
+		if ((repeatableAnnotation.getAnnotationTagBits() & TagBits.AnnotationInherited) != 0 && (containing.getAnnotationTagBits() & TagBits.AnnotationInherited) == 0) {
+			scope.problemReporter().repeatableAnnotationIsInherited(markerNode, repeatableAnnotation, containing);
+		}
+	}
+
+	private static void checkContainingAnnotationRetention(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {
+		long annotationBits = getAnnotationRetention(repeatableAnnotation);
+		long containerBits = getAnnotationRetention(container); 
+		// Due to clever layout of the bits, we can compare the absolute value directly
+		if (containerBits < annotationBits) {
+			scope.problemReporter().containingAnnotationHasShorterRetention(markerNode, repeatableAnnotation, getRetentionName(annotationBits), container, getRetentionName(containerBits));
+		}
+	}
+	
 	public AnnotationBinding getCompilerAnnotation() {
 		return this.compilerAnnotation;
 	}
@@ -815,17 +959,6 @@ public abstract class Annotation extends Expression {
 		}
 	}
 
-	public static void checkAnnotationContainerTarget(Annotation annotation, BlockScope scope, TypeBinding annotationType, TypeBinding containerAnnotationType) {
-		// check (meta)target compatibility
-		if (!annotationType.isValidBinding()) {
-			// no need to check annotation usage if missing
-			return;
-		}
-		if (! isAnnotationTargetAllowed(annotation, scope, containerAnnotationType, annotation.recipient.kind())) {
-			scope.problemReporter().disallowedTargetForContainerAnnotation(annotation, containerAnnotationType);
-		}
-	}
-	
 	// Check and answer if an attempt to annotate a package is being made. Error should be reported by caller.
 	public static boolean isTypeUseCompatible(TypeReference reference, Scope scope) {
 		if (reference != null && !(reference instanceof SingleTypeReference)) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index a540968..af6d3cc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -76,7 +76,7 @@ public class BinaryTypeBinding extends ReferenceBinding {
 
 	protected SimpleLookupTable storedAnnotations = null; // keys are this ReferenceBinding & its fields and methods, value is an AnnotationHolder
 
-	private ReferenceBinding containerAnnotation;
+	private ReferenceBinding containingAnnotation;
 
 static Object convertMemberValue(Object binaryValue, LookupEnvironment env, char[][][] missingTypeNames) {
 	if (binaryValue == null) return null;
@@ -1247,7 +1247,7 @@ public boolean isHierarchyConnected() {
 	return (this.tagBits & (TagBits.HasUnresolvedSuperclass | TagBits.HasUnresolvedSuperinterfaces)) == 0;
 }
 public boolean isRepeatableAnnotation() {
-	return this.containerAnnotation != null;
+	return this.containingAnnotation != null;
 }
 public int kind() {
 	
@@ -1299,10 +1299,10 @@ public TypeBinding prototype() {
 }
 
 public ReferenceBinding resolveContainerAnnotation() {
-	if (this.containerAnnotation instanceof UnresolvedReferenceBinding) {
-		this.containerAnnotation = (ReferenceBinding) BinaryTypeBinding.resolveType(this.containerAnnotation, this.environment, false);
+	if (this.containingAnnotation instanceof UnresolvedReferenceBinding) {
+		this.containingAnnotation = (ReferenceBinding) BinaryTypeBinding.resolveType(this.containingAnnotation, this.environment, false);
 	}
-	return this.containerAnnotation;
+	return this.containingAnnotation;
 }
 
 private FieldBinding resolveTypeFor(FieldBinding field) {
@@ -1363,8 +1363,8 @@ AnnotationBinding[] retrieveAnnotations(Binding binding) {
 	
 	return AnnotationBinding.addStandardAnnotations(super.retrieveAnnotations(binding), binding.getAnnotationTagBits(), this.environment);
 }
-public void setContainerAnnotation(ReferenceBinding value) {
-	this.containerAnnotation = value;
+public void setContainingAnnotation(ReferenceBinding value) {
+	this.containingAnnotation = value;
 }
 SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	
@@ -1582,7 +1582,7 @@ private void scanTypeForContainerAnnotation(IBinaryType binaryType, char[][][] m
 				if (elementValuePairs != null && elementValuePairs.length == 1) {
 					Object value = elementValuePairs[0].getValue();
 					if (value instanceof ClassSignature) {
-						this.containerAnnotation = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
+						this.containingAnnotation = (ReferenceBinding) this.environment.getTypeFromSignature(((ClassSignature)value).getTypeName(), 0, -1, false, null, missingTypeNames, TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER);
 					}
 				}
 				break;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
index dbbb258..af476a9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Binding.java
@@ -107,6 +107,10 @@ public abstract class Binding {
 		// empty block
 	}
 
+	public boolean isAnnotationType() {
+		return false;
+	}
+	
 	/* API
 	* Answer true if the receiver is not a problem binding
 	*/
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index a3f09e9..70adf27 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -1559,7 +1559,7 @@ AnnotationBinding[] retrieveAnnotations(Binding binding) {
 public void setAnnotations(AnnotationBinding[] annotations) {
 	storeAnnotations(this, annotations);
 }
-public void setContainerAnnotation(ReferenceBinding value) {
+public void setContainingAnnotation(ReferenceBinding value) {
 	// Leave this to subclasses
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 60bcea8..5d55383 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -86,7 +86,7 @@ public class SourceTypeBinding extends ReferenceBinding {
 	private int defaultNullness;
 	private int nullnessDefaultInitialized = 0; // 0: nothing; 1: type; 2: package
 	private int lambdaOrdinal = 0;
-	private ReferenceBinding containerAnnotation = null;
+	private ReferenceBinding containingAnnotation = null;
 	
 public SourceTypeBinding(char[][] compoundName, PackageBinding fPackage, ClassScope scope) {
 	this.compoundName = compoundName;
@@ -1333,7 +1333,7 @@ public boolean isHierarchyConnected() {
 	return (this.tagBits & TagBits.EndHierarchyCheck) != 0;
 }
 public boolean isRepeatableAnnotation() {
-	return this.containerAnnotation != null;
+	return this.containingAnnotation != null;
 }
 public ReferenceBinding[] memberTypes() {
 	if (this != this.prototype)
@@ -1574,10 +1574,10 @@ public TypeBinding prototype() {
 }
 
 public ReferenceBinding resolveContainerAnnotation() {
-	if (this.containerAnnotation instanceof UnresolvedReferenceBinding) {
-		this.containerAnnotation = (ReferenceBinding)BinaryTypeBinding.resolveType(this.containerAnnotation, this.scope.environment(), false);
+	if (this.containingAnnotation instanceof UnresolvedReferenceBinding) {
+		this.containingAnnotation = (ReferenceBinding)BinaryTypeBinding.resolveType(this.containingAnnotation, this.scope.environment(), false);
 	}
-	return this.containerAnnotation;
+	return this.containingAnnotation;
 }
 public FieldBinding resolveTypeFor(FieldBinding field) {
 	
@@ -2026,8 +2026,8 @@ public AnnotationHolder retrieveAnnotationHolder(Binding binding, boolean forceI
 		binding.getAnnotationTagBits(); // ensure annotations are up to date
 	return super.retrieveAnnotationHolder(binding, false);
 }
-public void setContainerAnnotation(ReferenceBinding value) {
-	this.containerAnnotation  = value;
+public void setContainingAnnotation(ReferenceBinding value) {
+	this.containingAnnotation  = value;
 }
 public void setFields(FieldBinding[] fields) {
 	this.fields = fields;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index ca25ef6..f2823bd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -491,10 +491,6 @@ void initializeForStaticImports() {
 	// only applicable to source types
 }
 
-public boolean isAnnotationType() {
-	return false;
-}
-
 public final boolean isAnonymousType() {
 	return (this.tagBits & TagBits.IsAnonymousType) != 0;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 6e68af7..2de1d8c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -50,7 +50,8 @@
  *								bug 382721 - [1.8][compiler] Effectively final variables needs special treatment
  *								bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
  *								bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
- *******************************************************************************/
+ *								bug 412151 - [1.8][compiler] Check repeating annotation's collection type
+ ********************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
 import java.io.CharConversionException;
@@ -7069,6 +7070,73 @@ public void repeatedAnnotationWithContainer(Annotation annotation, Annotation co
 		annotation.sourceStart,
 		annotation.sourceEnd);
 }
+public void containingAnnotationMustHaveValue(ASTNode markerNode, ReferenceBinding containerAnnotationType) {
+	this.handle(
+		IProblem.ContainingAnnotationMustHaveValue,
+		new String[] {new String(containerAnnotationType.readableName())},
+		new String[] {new String(containerAnnotationType.shortReadableName())},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+public void containingAnnotationHasWrongValueType(ASTNode markerNode, ReferenceBinding containerAnnotationType, ReferenceBinding annotationType, TypeBinding returnType) {
+	this.handle(
+		IProblem.ContainingAnnotationHasWrongValueType,
+		new String[] {new String(containerAnnotationType.readableName()), new String(annotationType.readableName()), new String(returnType.readableName())},
+		new String[] {new String(containerAnnotationType.shortReadableName()), new String(annotationType.shortReadableName()), new String(returnType.shortReadableName())},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+public void containingAnnotationHasNonDefaultMembers(ASTNode markerNode, ReferenceBinding containerAnnotationType, char[] selector) {
+	this.handle(
+		IProblem.ContainingAnnotationHasNonDefaultMembers,
+		new String[] {new String(containerAnnotationType.readableName()), new String(selector)},
+		new String[] {new String(containerAnnotationType.shortReadableName()), new String(selector)},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+public void containingAnnotationHasShorterRetention(ASTNode markerNode, ReferenceBinding annotationType, String annotationRetention, ReferenceBinding containerAnnotationType, String containerRetention) {
+	this.handle(
+		IProblem.ContainingAnnotationHasShorterRetention,
+		new String[] {new String(annotationType.readableName()), annotationRetention, new String(containerAnnotationType.readableName()), containerRetention},
+		new String[] {new String(annotationType.shortReadableName()), annotationRetention, new String(containerAnnotationType.shortReadableName()), containerRetention},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+public void repeatableAnnotationHasTargets(ASTNode markerNode, ReferenceBinding annotationType, ReferenceBinding containerAnnotationType) {
+	this.handle(
+		IProblem.RepeatableAnnotationHasTargets,
+		new String[] {new String(annotationType.readableName()), new String(containerAnnotationType.readableName())},
+		new String[] {new String(annotationType.shortReadableName()), new String(containerAnnotationType.shortReadableName())},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+public void repeatableAnnotationTargetMismatch(ASTNode markerNode, ReferenceBinding annotationType, ReferenceBinding containerAnnotationType, String unmetTargets) {
+	this.handle(
+		IProblem.RepeatableAnnotationTargetMismatch,
+		new String[] {new String(annotationType.readableName()), new String(containerAnnotationType.readableName()), unmetTargets},
+		new String[] {new String(annotationType.shortReadableName()), new String(containerAnnotationType.shortReadableName()), unmetTargets},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+
+public void repeatableAnnotationIsDocumented(ASTNode markerNode, ReferenceBinding annotationType, ReferenceBinding containerAnnotationType) {
+	this.handle(
+		IProblem.RepeatableAnnotationIsDocumented,
+		new String[] {new String(annotationType.readableName()), new String(containerAnnotationType.readableName())},
+		new String[] {new String(annotationType.shortReadableName()), new String(containerAnnotationType.shortReadableName())},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+
+public void repeatableAnnotationIsInherited(ASTNode markerNode, ReferenceBinding annotationType, ReferenceBinding containerAnnotationType) {
+	this.handle(
+		IProblem.RepeatableAnnotationIsInherited,
+		new String[] {new String(annotationType.readableName()), new String(containerAnnotationType.readableName())},
+		new String[] {new String(annotationType.shortReadableName()), new String(containerAnnotationType.shortReadableName())},
+		markerNode.sourceStart,
+		markerNode.sourceEnd);
+}
+
 public void reset() {
 	this.positionScanner = null;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 87dcd1d..a47704c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -40,6 +40,7 @@
 #							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
 #							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
 #							Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
+#							Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -747,6 +748,14 @@
 897 = Duplicate annotation of non-repeatable type @{0}. Only annotation types marked @Repeatable can be used multiple times at one target.
 898 = The repeatable annotation @{0} is disallowed for this location since its container annotation @{1} is disallowed at this location
 899 = The repeatable annotation @{0} may not be repeated where its container annotation @{1} is also used directly
+902 = The value method in the containing annotation @{0} must be of type {1}[] but is {2}
+903 = The containing annotation @{0} must declare a member value()
+904 = The containing annotation @{0} must declare a default value for the annotation attribute ''{1}''
+905 = Retention ''{1}'' of @{0} is longer than the retention of the containing annotation @{2}, which is ''{3}''
+906 = The repeatable annotation @{0} has a @Target annotation, @{1} does not
+907 = The containing annotation @{1} is allowed at targets where the repeatable annotation @{0} is not: {2}
+908 = The repeatable annotation @{0} is marked @Documented, but the containing annotation @{1} is not
+909 = The repeatable annotation @{0} is marked @Inherited, but the containing annotation @{1} is not
 
 ### NULL ANNOTATIONS
 910 = Null type mismatch: required ''{0}'' but the provided value is null
