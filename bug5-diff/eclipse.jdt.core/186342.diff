commit 19b4c669e6d8313d03dbcc8b595622002fe408a5
Author: Stephan Herrmann <sherrmann>
Date:   Sun Jan 16 18:50:31 2011 +0000

    HEAD	- Fixed bug 186342: [compiler][null]Using annotations for null checking

90	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
32	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
943	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
3	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
26	3	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
18	0	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
3	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
48	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
8	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
13	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
12	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
21	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
8	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
16	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
83	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
12	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
50	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
43	8	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
70	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
7	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
58	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
5	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
8	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
111	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
20	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
177	3	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index cbea1ac..e9f4b8c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,7 +10,9 @@
  *     Benjamin Muskalla - Contribution for bug 239066
  *     Stephan Herrmann  - Contribution for bug 236385
  *     Stephan Herrmann  - Contribution for bug 295551
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
+ *     						bug 185682 - Increment/decrement operators mark local variables as read
+ *     						bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -48,7 +50,7 @@ public class BatchCompilerTest extends AbstractRegressionTest {
 	private static final Main MAIN = new Main(null/*outWriter*/, null/*errWriter*/, false/*systemExit*/, null/*options*/, null/*progress*/);
 
 	static {
-//		TESTS_NAMES = new String[] { "test295_warn_options" };
+//		TESTS_NAMES = new String[] { "testNullAnnotations" };
 //		TESTS_NUMBERS = new int[] { 306 };
 //		TESTS_RANGE = new int[] { 298, -1 };
 	}
@@ -1589,6 +1591,22 @@ public void test012(){
         "    -classNames <className1[,className2,...]>\n" +
         "                         qualified names of binary classes to process\n" +
         " \n" +
+        " Null annotation options:\n" +
+		"    -nullAnnotations:<suboptions>\n" +
+		"                      enable use of annotations for specifying null contracts;\n" +
+		"                      <suboptions> is a non-empty, comma-separated list of:\n" +
+		"        nullable=<typename>\n" +
+		"                      specifies the fully qualified name of an annotation type\n" +
+		"                      to be used for marking types whose values include null\n" +
+		"        nonnull=<typename>\n" +
+		"                      specifies the fully qualified name of an annotation type\n" +
+		"                      to be used for marking types whose values cannot be null\n" +
+		"        emulate       tells the compiler to emulate the above annotation types\n" +
+		"                      although they do not exist on the classpath\n" +
+		"        import        tells the compiler to import the above annotation types\n" +
+		"                      without specific mention in the sources such that their\n" +
+		"                      simple names can be used without explicit imports\n" +
+		" \n" +
         " Advanced options:\n" +
         "    @<file>            read command line arguments from file\n" +
         "    -maxProblems <n>   max number of problems per compilation unit (100 by\n" +
@@ -1793,6 +1811,8 @@ public void test012b(){
 			"		<argument value=\"---OUTPUT_DIR_PLACEHOLDER---\"/>\n" + 
 			"	</command_line>\n" + 
 			"	<options>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.defaultImport\" value=\"disabled\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.emulate\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.targetPlatform\" value=\"1.5\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.unusedLocal\" value=\"optimize out\"/>\n" + 
@@ -1850,11 +1870,14 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noEffectAssignment\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullContractInsufficientInfo\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullContractViolation\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingMethodWithoutSuperInvocation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.parameterAssignment\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullContractViolation\" value=\"error\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullReference\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.rawTypeReference\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.redundantNullCheck\" value=\"ignore\"/>\n" + 
@@ -12264,4 +12287,68 @@ public void testReportingUnavoidableGenericProblems2() {
 		"3 problems (1 error, 2 warnings)",
 		true);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342  -- minimal options passed
+public void testNullAnnotations1() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @org.eclipse.jdt.annotation.NonNull Object foo(boolean b) {\n" +
+			"          return null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "X.java\""
+		+ " -1.5 -nullAnnotations:emulate -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"----------\n" + 
+		"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n" + 
+		"	return null;\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"Null contract violation: returning null from a method declared as @NonNull.\n" +
+		"----------\n" + 
+		"1 problem (1 error)",
+		true);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342  -- full options passed
+public void testNullAnnotations2() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @NichtNull Object foo(boolean b) {\n" +
+			"          return null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "X.java\""
+		+ " -1.5 -nullAnnotations:nullable=org.foo.Nullish,emulate,import,nonnull=de.foo.NichtNull -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"----------\n" + 
+		"1. ERROR in ---OUTPUT_DIR_PLACEHOLDER---/X.java (at line 3)\n" + 
+		"	return null;\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"Null contract violation: returning null from a method declared as @NichtNull.\n" +
+		"----------\n" + 
+		"1 problem (1 error)",
+		true);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342  -- unrecognized sub-option
+public void testNullAnnotations3() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @NichtNull Object foo(boolean b) {\n" +
+			"          return null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"\"" + OUTPUT_DIR +  File.separator + "X.java\""
+		+ " -1.5 -nullAnnotations:wrong -d \"" + OUTPUT_DIR + "\"",
+		"",
+		"Unrecognized sub-option of -nullAnnotations: wrong,\n" + 
+		"legal values are nullable=.., nonnull=.., emulate and import\n",
+		true);
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 3c0164e..3adb8ac 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2006, 2010 IBM Corporation and others.
+ * Copyright (c) 2006, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,7 +8,9 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
- *     Stephan Herrmann  - Contribution for bug 236385
+ *     Stephan Herrmann  - Contributions for 
+ *     							bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
+ *     							bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -386,9 +388,13 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("CodeSnippetMissingMethod", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ComparingIdentical", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ConflictingImport", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
+		expectedProblemAttributes.put("ConflictingTypeEmulation", new ProblemAttributes(CategorizedProblem.CAT_BUILDPATH));
 		expectedProblemAttributes.put("ConstructorVarargsArgumentNeedCast", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("CorruptedSignature", new ProblemAttributes(CategorizedProblem.CAT_BUILDPATH));
 		expectedProblemAttributes.put("DeadCode", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("DefiniteNullFromNonNullMethod", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("DefiniteNullToNonNullParameter", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("DefiniteNullToNonNullLocal", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("DirectInvocationOfAbstractMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(CategorizedProblem.CAT_RESTRICTION));
@@ -491,6 +497,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("IllegalPrimitiveOrArrayTypeForEnclosingInstance", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalQualifiedEnumConstantLabel", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("IllegalQualifiedParameterizedTypeAllocation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("IllegalDefinitionToNonNullParameter", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("IllegalRedefinitionToNullableReturn", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("IllegalRedefinitionToNonNullParameter", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("IllegalStaticModifierForMemberType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalTypeVariableSuperReference", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("IllegalUsageOfQualifiedTypeReference", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
@@ -669,6 +678,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("MissingEnclosingInstance", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("MissingNullAnnotationType", new ProblemAttributes(CategorizedProblem.CAT_BUILDPATH));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("MissingReturnType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -697,6 +707,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("NonGenericMethod", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonGenericType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullLocalInsufficientInfo", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullParameterInsufficientInfo", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("NonNullReturnInsufficientInfo", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
@@ -746,6 +759,9 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("ParsingErrorUnexpectedEOF", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
 		expectedProblemAttributes.put("PossibleAccidentalBooleanAssignment", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullFromNonNullMethod", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullToNonNullLocal", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullToNonNullParameter", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawTypeReference", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
@@ -1023,9 +1039,13 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("CodeSnippetMissingMethod", SKIP);
 		expectedProblemAttributes.put("ComparingIdentical", new ProblemAttributes(JavaCore.COMPILER_PB_COMPARING_IDENTICAL));
 		expectedProblemAttributes.put("ConflictingImport", SKIP);
+		expectedProblemAttributes.put("ConflictingTypeEmulation", SKIP);
 		expectedProblemAttributes.put("ConstructorVarargsArgumentNeedCast", new ProblemAttributes(JavaCore.COMPILER_PB_VARARGS_ARGUMENT_NEED_CAST));
 		expectedProblemAttributes.put("CorruptedSignature", SKIP);
 		expectedProblemAttributes.put("DeadCode", new ProblemAttributes(JavaCore.COMPILER_PB_DEAD_CODE));
+		expectedProblemAttributes.put("DefiniteNullFromNonNullMethod", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_VIOLATION));
+		expectedProblemAttributes.put("DefiniteNullToNonNullLocal", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_VIOLATION));
+		expectedProblemAttributes.put("DefiniteNullToNonNullParameter", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_VIOLATION));
 		expectedProblemAttributes.put("DirectInvocationOfAbstractMethod", SKIP);
 		expectedProblemAttributes.put("DisallowedTargetForAnnotation", SKIP);
 		expectedProblemAttributes.put("DiscouragedReference", new ProblemAttributes(JavaCore.COMPILER_PB_DISCOURAGED_REFERENCE));
@@ -1128,6 +1148,9 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("IllegalPrimitiveOrArrayTypeForEnclosingInstance", SKIP);
 		expectedProblemAttributes.put("IllegalQualifiedEnumConstantLabel", SKIP);
 		expectedProblemAttributes.put("IllegalQualifiedParameterizedTypeAllocation", SKIP);
+		expectedProblemAttributes.put("IllegalDefinitionToNonNullParameter", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_VIOLATION));
+		expectedProblemAttributes.put("IllegalRedefinitionToNullableReturn", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_VIOLATION));
+		expectedProblemAttributes.put("IllegalRedefinitionToNonNullParameter", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_VIOLATION));
 		expectedProblemAttributes.put("IllegalStaticModifierForMemberType", SKIP);
 		expectedProblemAttributes.put("IllegalTypeVariableSuperReference", SKIP);
 		expectedProblemAttributes.put("IllegalUsageOfQualifiedTypeReference", SKIP);
@@ -1306,6 +1329,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("MissingEnclosingInstance", SKIP);
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", SKIP);
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
+		expectedProblemAttributes.put("MissingNullAnnotationType", SKIP);
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", SKIP);
 		expectedProblemAttributes.put("MissingReturnType", SKIP);
@@ -1334,6 +1358,9 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("NonGenericMethod", SKIP);
 		expectedProblemAttributes.put("NonGenericType", SKIP);
 		expectedProblemAttributes.put("NonNullLocalVariableComparisonYieldsFalse", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("NonNullReturnInsufficientInfo", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO));
+		expectedProblemAttributes.put("NonNullLocalInsufficientInfo", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO));
+		expectedProblemAttributes.put("NonNullParameterInsufficientInfo", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO));
 		expectedProblemAttributes.put("NonStaticAccessToStaticField", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticAccessToStaticMethod", new ProblemAttributes(JavaCore.COMPILER_PB_STATIC_ACCESS_RECEIVER));
 		expectedProblemAttributes.put("NonStaticContextForEnumMemberType", SKIP);
@@ -1383,6 +1410,9 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("ParsingErrorUnexpectedEOF", SKIP);
 		expectedProblemAttributes.put("PossibleAccidentalBooleanAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_POSSIBLE_ACCIDENTAL_BOOLEAN_ASSIGNMENT));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
+		expectedProblemAttributes.put("PotentialNullFromNonNullMethod", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION));
+		expectedProblemAttributes.put("PotentialNullToNonNullLocal", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION));
+		expectedProblemAttributes.put("PotentialNullToNonNullParameter", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", SKIP);
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", SKIP);
 		expectedProblemAttributes.put("RawTypeReference", new ProblemAttributes(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE));
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
new file mode 100644
index 0000000..992e407
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -0,0 +1,943 @@
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 GK Software AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation 
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.util.Map;
+
+import junit.framework.Test;
+
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+public class NullAnnotationTest extends AbstractComparableTest {
+
+public NullAnnotationTest(String name) {
+	super(name);
+}
+
+// Static initializer to specify tests subset using TESTS_* static variables
+// All specified tests which do not belong to the class are skipped...
+static {
+//		TESTS_NAMES = new String[] { "test_parameter_contract_inheritance_008" };
+//		TESTS_NUMBERS = new int[] { 561 };
+//		TESTS_RANGE = new int[] { 1, 2049 };
+}
+
+public static Test suite() {
+	return buildComparableTestSuite(testClass());
+}
+
+public static Class testClass() {
+	return NullAnnotationTest.class;
+}
+
+// Conditionally augment problem detection settings
+static boolean setNullRelatedOptions = true;
+protected Map getCompilerOptions() {
+    Map defaultOptions = super.getCompilerOptions();
+    if (setNullRelatedOptions) {
+	    defaultOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	    defaultOptions.put(CompilerOptions.OPTION_ReportPotentialNullReference, CompilerOptions.ERROR);
+	    defaultOptions.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.ERROR);
+		defaultOptions.put(CompilerOptions.OPTION_ReportRawTypeReference, CompilerOptions.IGNORE);
+		defaultOptions.put(CompilerOptions.OPTION_IncludeNullInfoFromAsserts, CompilerOptions.ENABLED);
+		
+		defaultOptions.put(CompilerOptions.OPTION_ReportMissingOverrideAnnotationForInterfaceMethodImplementation, CompilerOptions.DISABLED);
+
+		// enable null annotations:
+		defaultOptions.put(CompilerOptions.OPTION_EmulateNullAnnotationTypes, CompilerOptions.ENABLED);
+		defaultOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+		// leave other new options at these defaults:
+//		defaultOptions.put(CompilerOptions.OPTION_ReportNullContractViolation, CompilerOptions.ERROR);
+//		defaultOptions.put(CompilerOptions.OPTION_ReportPotentialNullContractViolation, CompilerOptions.ERROR);
+//		defaultOptions.put(CompilerOptions.OPTION_ReportNullContractInsufficientInfo, CompilerOptions.WARNING);
+		
+//		defaultOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.eclipse.jdt.annotation.Nullable");
+//		defaultOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.eclipse.jdt.annotation.NonNull");
+    }
+    return defaultOptions;
+}
+// a nullable argument is dereferenced without a check
+public void test_nullable_paramter_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void foo(@Nullable Object o) {\n" +
+			  "        System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	System.out.print(o.toString());\n" + 
+		"	                 ^\n" + 
+		"Potential null pointer access: The variable o may be null at this location\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+
+// a null value is passed to a nullable argument
+public void test_nullable_paramter_002() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void foo(@Nullable Object o) {\n" +
+			  "        // nop\n" +
+			  "    }\n" +
+			  "    void bar() {\n" +
+			  "        foo(null);\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "");
+}
+
+// a non-null argument is checked for null
+public void test_nonnull_parameter_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void foo(@NonNull Object o) {\n" +
+			  "        if (o != null)\n" +
+			  "              System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	if (o != null)\n" + 
+		"	    ^\n" + 
+		"Redundant null check: The variable o cannot be null at this location\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a non-null argument is dereferenced without a check
+public void test_nonnull_parameter_002() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void foo(@NonNull Object o) {\n" +
+			  "        System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "    public static void main(String... args) {\n" +
+			  "        new X().foo(\"OK\");\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "OK");
+}
+// passing null to nonnull parameter 
+public void test_nonnull_parameter_003() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void foo(@NonNull Object o) {\n" +
+			  "        System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "    void bar() {\n" +
+			  "        foo(null);\n" +
+			  "    }\n" +
+			  "}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 6)\n" + 
+		"	foo(null);\n" + 
+		"	    ^^^^\n" + 
+		"Null contract violation: passing null to a parameter declared as @NonNull.\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// passing potential null to nonnull parameter - target method is consumed from .class
+public void test_nonnull_parameter_004() {
+	runConformTest(
+			new String[] {
+				"Lib.java",
+				"public class Lib {\n" +
+				"    void setObject(@NonNull Object o) { }\n" +
+				"}\n"
+			});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void bar(Lib l, boolean b) {\n" +
+			  "        Object o = null;\n" +
+			  "        if (b) o = new Object();\n" +
+			  "        l.setObject(o);\n" +
+			  "    }\n" +
+			  "}\n"},
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	l.setObject(o);\n" + 
+		"	            ^\n" + 
+		"Null contract violation: potentially passing null to a parameter declared as @NonNull.\n" + 
+		"----------\n",
+		"",/* expected output */
+		"",/* expected error */
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// passing unknown value to nonnull parameter  - target method is consumed from .class
+public void test_nonnull_parameter_005() {
+	runConformTest(
+			new String[] {
+				"Lib.java",
+				"public class Lib {\n" +
+				"    void setObject(@NonNull Object o) { }\n" +
+				"}\n"
+			});
+	runConformTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void bar(Lib l, Object o) {\n" +
+			  "        l.setObject(o);\n" +
+			  "    }\n" +
+			  "}\n"},
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. WARNING in X.java (at line 3)\n" + 
+		"	l.setObject(o);\n" + 
+		"	            ^\n" + 
+		"Potential null contract violation: insufficient nullness information regarding a value that is passed to a parameter declared as @NonNull.\n" + 
+		"----------\n",
+		"",/* expected output */
+		"",/* expected error */
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+
+// assigning potential null to a nonnull local variable
+public void test_nonnull_local_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void foo(boolean b, Object p) {\n" +
+			  "        @NonNull Object o1 = b ? null : new Object();\n" +
+			  "        @NonNull String o2 = \"\";\n" +
+			  "        o2 = null;\n" +
+			  "        @NonNull Object o3 = p;\n" +
+			  "    }\n" +
+			  "}\n"},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@NonNull Object o1 = b ? null : new Object();\n" + 
+		"	                     ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null contract violation: potentially assigning null to local variable o1, which is declared as @NonNull.\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	o2 = null;\n" + 
+		"	     ^^^^\n" + 
+		"Null contract violation: assigning null to local variable o2, which is declared as @NonNull.\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 6)\n" + 
+		"	@NonNull Object o3 = p;\n" + 
+		"	                     ^\n" + 
+		"Potential null contract violation: insufficient nullness information regarding a value that is assigned to local variable o3, which is declared as @NonNull.\n" + 
+		"----------\n",
+	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+
+// a method tries to tighten the null contract, super declares parameter o as @Nullable
+// other parameters: s is redefined from not constrained to @Nullable which is OK
+//                   third is redefined from not constrained to @NonNull which is bad, too
+public void test_parameter_contract_inheritance_001() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    void foo(String s, @Nullable Object o, Object third) { }\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    void foo(@Nullable String s, @NonNull Object o, @NonNull Object third) { System.out.print(o.toString()); }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	void foo(@Nullable String s, @NonNull Object o, @NonNull Object third) { System.out.print(o.toString()); }\n" + 
+		"	                                             ^\n" + 
+		"Cannot tighten null contract for parameter o, inherited method from Lib declares this parameter as @Nullable.\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 3)\n" + 
+		"	void foo(@Nullable String s, @NonNull Object o, @NonNull Object third) { System.out.print(o.toString()); }\n" + 
+		"	                                                                ^^^^^\n" + 
+		"Cannot tighten null contract for parameter third, inherited method from Lib does not constrain this parameter.\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a method body fails to handle the inherited null contract, super declares parameter as @Nullable
+public void test_parameter_contract_inheritance_002() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    void foo(@Nullable Object o) { }\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    void foo(Object o) {\n" +
+			"        System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	System.out.print(o.toString());\n" + 
+		"	                 ^\n" + 
+		"Potential null pointer access: The variable o may be null at this location\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a method relaxes the parameter null contract, super interface declares parameter o as @NonNull
+// other (first) parameter just repeats the inherited @NonNull
+public void test_parameter_contract_inheritance_003() {
+	runConformTest(
+		new String[] {
+			"IX.java",
+			"public interface IX {\n" +
+			"    void foo(@NonNull String s, @NonNull Object o);\n" +
+			"}\n",
+			"X.java",
+			"public class X implements IX {\n" +
+			"    public void foo(@NonNull String s, @Nullable Object o) { ; }\n" +
+			"    void bar() { foo(\"OK\", null); }\n" +
+			"}\n"
+		},
+		"");
+}
+// a method adds a @NonNull annotation, super interface has no null annotation
+// changing other from unconstrained to @Nullable is OK
+public void test_parameter_contract_inheritance_004() {
+	runConformTest(
+		new String[] {
+			"IX.java",
+			"public interface IX {\n" +
+			"    void foo(Object o, Object other);\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X implements IX {\n" +
+			"    public void foo(@NonNull Object o, @Nullable Object other) { System.out.print(o.toString()); }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	public void foo(@NonNull Object o, @Nullable Object other) { System.out.print(o.toString()); }\n" + 
+		"	                                ^\n" + 
+		"Cannot tighten null contract for parameter o, inherited method from IX does not constrain this parameter.\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a method tries to relax the null contract, super declares @NonNull return
+public void test_parameter_contract_inheritance_005() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@Nullable Object getObject() { return null; }\n" + 
+		"	                 ^^^^^^^^^^^\n" + 
+		"Cannot relax null contract for method return, inherited method from Lib is declared as @NonNull.\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+
+// super has no contraint for return, sub method confirms the null contract as @Nullable 
+public void test_parameter_contract_inheritance_006() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return null; }\n" +
+			"}\n"
+		});
+	runConformTest(
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibs*/,
+		false /* flush output directory */,
+		null/*vmArguments*/,
+		null/*customOptions*/,
+		null/*compilerRequestor*/);
+}
+// a method body violates the inherited null contract, super declares @NonNull return
+public void test_parameter_contract_inheritance_007() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	Object getObject() { return null; }\n" + 
+		"	                     ^^^^^^^^^^^^\n" + 
+		"Null contract violation: returning null from a method declared as @NonNull.\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a client potentially violates the inherited null contract, super interface declares @NonNull parameter
+public void test_parameter_contract_inheritance_008() {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportNullContractInsufficientInfo, CompilerOptions.ERROR);
+	runConformTest(
+		new String[] {
+			"IX.java",
+			"public interface IX {\n" +
+			"    void printObject(@NonNull Object o);\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X implements IX {\n" +
+			"    public void printObject(Object o) { System.out.print(o.toString()); }\n" +
+			"}\n",
+			"M.java",
+			"public class M{\n" +
+			"    void foo(X x, Object o) {\n" +
+			"        x.printObject(o);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		options,
+		"----------\n" + 
+		"1. ERROR in M.java (at line 3)\n" + 
+		"	x.printObject(o);\n" + 
+		"	              ^\n" + 
+		"Potential null contract violation: insufficient nullness information regarding a value that is passed to a parameter declared as @NonNull.\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a static method has a more relaxed null contract than a like method in the super class, but no overriding.
+public void test_parameter_contract_inheritance_009() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @NonNull static Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Nullable static Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		"");
+}
+// a nullable return value is dereferenced without a check
+public void test_nullable_return_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"    void foo() {\n" +
+			"        Object o = getObject();\n" +
+			"        System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	System.out.print(o.toString());\n" + 
+		"	                 ^\n" + 
+		"Potential null pointer access: The variable o may be null at this location\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a nullable return value is dereferenced without a check, method is read from .class file
+public void test_nullable_return_002() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(Lib l) {\n" +
+			"        Object o = l.getObject();\n" +
+			"        System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	System.out.print(o.toString());\n" + 
+		"	                 ^\n" + 
+		"Potential null pointer access: The variable o may be null at this location\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a non-null return value is checked for null, method is read from .class file
+public void test_nonnull_return_001() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		});
+	runNegativeTest(
+		false /* flush output directory */,
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(Lib l) {\n" +
+			"        Object o = l.getObject();\n" +
+			"        if (o != null)\n" +
+			"            System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		// compiler options
+		null /* no class libraries */,
+		null /* no custom options */,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	if (o != null)\n" + 
+		"	    ^\n" + 
+		"Redundant null check: The variable o cannot be null at this location\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a non-null method returns null
+public void test_nonnull_return_003() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @NonNull Object getObject(boolean b) {\n" +
+			"        if (b)\n" +
+			"            return null;\n" + // definite contract violation despite enclosing "if"
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	return null;\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"Null contract violation: returning null from a method declared as @NonNull.\n" + 
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a non-null method potentially returns null
+public void test_nonnull_return_004() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @NonNull Object getObject(@Nullable Object o) {\n" +
+			"        return o;\n" + // 'o' is only potentially null
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return o;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Null contract violation: return value can be null but method is declared as @NonNull.\n" + 
+		"----------\n");
+}
+// a non-null method returns its non-null argument
+public void test_nonnull_return_005() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @NonNull Object getObject(@NonNull Object o) {\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibs*/,
+		true/*shouldFlushOutputDirectory*/,
+		null/*vmArguments*/,
+		customOptions,
+		null/*compilerRequestor*/);
+}
+//a non-null method has insufficient nullness info for its return value
+public void test_nonnull_return_006() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    @NonNull Object getObject(Object o) {\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 3)\n" + 
+		"	return o;\n" + 
+		"	^^^^^^^^^\n" + 
+		"Potential null contract violation: insufficient nullness information regarding return value while the method is declared as @NonNull.\n" + 
+		"----------\n");
+}
+// mixed use of fully qualified name / explicit import
+public void test_annotation_import_001() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.foo.Nullable");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.foo.NonNull");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.DISABLED);
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @org.foo.NonNull Object getObject() { return new Object(); }\n" + 	// FQN
+			"}\n",
+			"X.java",
+			"import org.foo.NonNull;\n" +											// explicit import
+			"public class X {\n" +
+			"    @NonNull Object getObject(@NonNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibs*/,
+		true/*shouldFlushOutputDirectory*/,
+		null/*vmArguments*/,
+		customOptions,
+		null/*compilerRequestor*/);
+}
+
+// use of explicit imports throughout
+public void test_annotation_import_002() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.foo.Nullable");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.foo.NonNull");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.DISABLED);
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"import org.foo.NonNull;\n" +
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"import org.foo.NonNull;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(@org.foo.Nullable String dummy, @NonNull Lib l) {\n" +
+			"        Object o = l.getObject();" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibs*/,
+		true/*shouldFlushOutputDirectory*/,
+		null/*vmArguments*/,
+		customOptions,
+		null/*compilerRequestor*/);
+}
+// default import plus explicit ones
+public void test_annotation_import_003() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.foo.Nullable");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.foo.NonNull");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+	runConformTest(
+		new String[] {
+			"libpack/Lib.java",
+			"package libpack;\n" +
+			"public class Lib {\n" +
+			"    public @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"import libpack.Lib;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(@NonNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibs*/,
+		true/*shouldFlushOutputDirectory*/,
+		null/*vmArguments*/,
+		customOptions,
+		null/*compilerRequestor*/);
+}
+// default import but unspecified annotation names
+public void test_annotation_import_004() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, null);
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, null);
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+	runConformTest(
+		new String[] {
+			"libpack/Lib.java",
+			"package libpack;\n" +
+			"public class Lib {\n" +
+			"    public @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"import libpack.Lib;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(@NonNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"",
+		null/*classLibs*/,
+		true/*shouldFlushOutputDirectory*/,
+		null/*vmArguments*/,
+		customOptions,
+		null/*compilerRequestor*/);
+}
+// default import of existing annotation types
+public void test_annotation_import_005() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportNullContractInsufficientInfo, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.foo.MayBeNull");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.foo.MustNotBeNull");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+	customOptions.put(CompilerOptions.OPTION_EmulateNullAnnotationTypes, CompilerOptions.DISABLED);
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"public class X {\n" +
+			"    @MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n",
+			
+			"org/foo/MayBeNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"public @interface MayBeNull {}\n",
+			
+			"org/foo/MustNotBeNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"public @interface MustNotBeNull {}\n",
+		},
+		null/*classLibs*/,
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	return l.getObject();\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Potential null contract violation: insufficient nullness information regarding return value while the method is declared as @MustNotBeNull.\n" +
+//		"Potential null contract violation: insufficient nullness information for checking return value against declaration as @MustNotBeNull.\n" + 
+		"----------\n",
+		JavacTestOptions.SKIP);
+}
+// a non-null method returns a value obtained from an unannotated method, default import of missing annotation types
+public void test_annotation_import_006() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportNullContractInsufficientInfo, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.foo.MayBeNull");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.foo.MustNotBeNull");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+	customOptions.put(CompilerOptions.OPTION_EmulateNullAnnotationTypes, CompilerOptions.DISABLED);
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"public class X {\n" +
+			"    @MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null/*classLibs*/,
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in Lib.java (at line 0)\n" + 
+		"	public class Lib {\n" + 
+		"	^\n" + 
+		"Buildpath problem: the type org.foo.MayBeNull which is configured as a null annotation type cannot be resolved.\n" + 
+		"----------\n",
+		JavacTestOptions.SKIP);
+}
+// emulation names conflict with existing types
+public void test_annotation_emulation_001() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "libpack.Lib");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "libpack.Lib");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"libpack/Lib.java",
+			"package libpack;\n" +
+			"public class Lib {\n" +
+			"}\n",
+		},
+		null/*classLibs*/,
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in libpack\\Lib.java (at line 0)\n" + 
+		"	package libpack;\n" + 
+		"	^\n" + 
+		"Buildpath problem: emulation of type libpack.Lib is requested (for null annotations) but a type of this name exists on the build path.\n" + 
+		"----------\n",
+		JavacTestOptions.SKIP);
+}
+// regular use (explicit import/FQN) of existing annotation types (=no emulation)
+public void test_annotation_emulation_002() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(CompilerOptions.OPTION_ReportNullReference, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullContractViolation, CompilerOptions.ERROR);
+	customOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.foo.MayBeNull");
+	customOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.foo.MustNotBeNull");
+	customOptions.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.DISABLED);
+	customOptions.put(CompilerOptions.OPTION_EmulateNullAnnotationTypes, CompilerOptions.DISABLED);
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @org.foo.MayBeNull Object getObject() { return new Object(); }\n" + 	// FQN
+			"}\n",
+			"X.java",
+			"import org.foo.MustNotBeNull;\n" +											// explicit import
+			"public class X {\n" +
+			"    @MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n",
+
+			"org/foo/MayBeNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"public @interface MayBeNull {}\n",
+			
+			"org/foo/MustNotBeNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"public @interface MustNotBeNull {}\n",
+		},
+		null/*classLibs*/,
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	return l.getObject();\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Null contract violation: return value can be null but method is declared as @MustNotBeNull.\n" + 
+		"----------\n",
+		JavacTestOptions.SKIP);
+}
+
+// a default null annotation is illegally used on a class:
+public void test_illegal_annotation_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"@NonNull public class X {\n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	@NonNull public class X {\n" + 
+		"	^^^^^^^^\n" + 
+		"The annotation @NonNull is disallowed for this location\n" + 
+		"----------\n");	
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 8b01277..c947366 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann  - Contribution for bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -96,6 +97,7 @@ public static Test suite() {
 	since_1_5.add(InnerEmulationTest_1_5.class);
 	since_1_5.add(AssignmentTest_1_5.class);
 	since_1_5.add(InnerClass15Test.class);
+	since_1_5.add(NullAnnotationTest.class);
 
 	// Tests to run when compliance is greater than 1.5
 	ArrayList since_1_6 = new ArrayList();
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
index e602ecc..9bdefa0 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -10,8 +10,10 @@
  *     Tom Tromey - Contribution for bug 125961
  *     Tom Tromey - Contribution for bug 159641
  *     Benjamin Muskalla - Contribution for bug 239066
- *     Stephan Herrmann  - Contribution for bug 236385
- *     Stephan Herrmann  - Contribution for bug 295551
+ *     Stephan Herrmann  - Contributions for 
+ *     							bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
+ *     							bug 295551 - Add option to automatically promote all warnings to errors 
+ *     							bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.batch;
 
@@ -2388,6 +2390,27 @@ public void configure(String[] argv) {
 					mode = INSIDE_WARNINGS_PROPERTIES;
 					continue;
 				}
+				if (currentArg.startsWith("-nullAnnotations:")) { //$NON-NLS-1$
+					StringTokenizer tokenizer =
+						new StringTokenizer(currentArg.substring("-nullAnnotations:".length()), ","); //$NON-NLS-1$ //$NON-NLS-2$
+					while (tokenizer.hasMoreTokens()) {
+						String token = tokenizer.nextToken();
+						if (token.startsWith("nullable=")) { //$NON-NLS-1$
+							this.options.put(CompilerOptions.OPTION_NullableAnnotationName, token.substring("nullable=".length())); //$NON-NLS-1$
+						} else if (token.startsWith("nonnull=")) { //$NON-NLS-1$
+							this.options.put(CompilerOptions.OPTION_NonNullAnnotationName, token.substring("nonnull=".length())); //$NON-NLS-1$
+						} else if (token.equals("emulate")) { //$NON-NLS-1$
+							this.options.put(CompilerOptions.OPTION_EmulateNullAnnotationTypes, CompilerOptions.ENABLED);
+						} else if (token.equals("import")) { //$NON-NLS-1$
+							this.options.put(CompilerOptions.OPTION_DefaultImportNullAnnotationTypes, CompilerOptions.ENABLED);
+						} else {
+							throw new IllegalArgumentException(
+								this.bind("configure.unrecognized.nullannotation.option", token)); //$NON-NLS-1$
+						}
+					}
+					mode = DEFAULT;
+					continue;
+				}
 				break;
 			case INSIDE_TARGET :
 				if (this.didSpecifyTarget) {
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 3b8f013..3da20d6 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -8,6 +8,7 @@
 # Contributors:
 #     IBM Corporation - initial API and implementation
 #		Benjamin Muskalla - Contribution for bug 239066
+#       Stephan Herrmann  - Contribution for bug 186342 - [compiler][null]Using annotations for null checking
 ###############################################################################
 ### JavaBatchCompiler messages.
 
@@ -71,6 +72,7 @@ configure.invalidUsageOfMinusOption=usage of ''-'' for ''{0}'' is illegal there
 
 ## configure.directoryNotExist = directory does not exist: {0}
 configure.unrecognizedOption = Unrecognized option : {0}
+configure.unrecognized.nullannotation.option = Unrecognized sub-option of -nullAnnotations: {0},\nlegal values are 'nullable=..', 'nonnull=..', 'emulate' and 'import'
 configure.noClasspath = no classpath defined, using default directory instead
 configure.incorrectClasspath = incorrect classpath: {0}
 configure.invalidexpansionargumentname = expansion argument file {0} does not exist or cannot be read
@@ -222,6 +224,22 @@ misc.usage = {1} {2}\n\
 \    -classNames <className1[,className2,...]>\n\
 \                         qualified names of binary classes to process\n\
 \ \n\
+\ Null annotation options:\n\
+\    -nullAnnotations:<suboptions>\n\
+\                      enable use of annotations for specifying null contracts;\n\
+\                      <suboptions> is a non-empty, comma-separated list of:\n\
+\        nullable=<typename>\n\
+\                      specifies the fully qualified name of an annotation type\n\
+\                      to be used for marking types whose values include null\n\
+\        nonnull=<typename>\n\
+\                      specifies the fully qualified name of an annotation type\n\
+\                      to be used for marking types whose values cannot be null\n\
+\        emulate       tells the compiler to emulate the above annotation types\n\
+\                      although they do not exist on the classpath\n\
+\        import        tells the compiler to import the above annotation types\n\
+\                      without specific mention in the sources such that their\n\
+\                      simple names can be used without explicit imports\n\
+\ \n\
 \ Advanced options:\n\
 \    @<file>            read command line arguments from file\n\
 \    -maxProblems <n>   max number of problems per compilation unit (100 by\n\
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 9f6da77..7fe18a3 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -51,7 +51,9 @@ Eclipse SDK 3.7M5 - %date% - 3.7.0 M5
 <h2>What's new in this drop</h2>
 
 <h3>Problem Reports Fixed</h3>
-<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=334315">334315</a>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a>
+[compiler][null]Using annotations for null checking
+<br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=334315">334315</a>
 [compiler] Problem types with missing superclass or superinterfaces should use Object for missing types
 <br><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=333956">333956</a>
 CompilerOptions#warningOptionNames(): OPTION_ReportRawTypeReference missing
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index d223a16..76dd10a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -116,7 +116,21 @@
  *		Benjamin Muskalla - added the following constants
  *									MissingSynchronizedModifierInInheritedMethod
  *		Stephan Herrmann  - added the following constants
- *									UnusedObjectAllocation									
+ *									UnusedObjectAllocation
+ *									DefiniteNullFromNonNullMethod
+ *									PotentialNullFromNonNullMethod
+ *									NonNullReturnInsufficientInfo
+ *									DefiniteNullToNonNullParameter
+ *									PotentialNullToNonNullParameter
+ *									NonNullParameterInsufficientInfo
+ *									DefiniteNullToNonNullLocal
+ *									PotentialNullToNonNullLocal
+ *									NonNullLocalInsufficientInfo
+ *									ConflictingTypeEmulation
+ *									MissingNullAnnotationType
+ *									IllegalRedefinitionToNullableReturn
+ *									IllegalRedefinitionToNonNullParameter
+ *									IllegalDefinitionToNonNullParameter
  *******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
@@ -1340,6 +1354,38 @@ void setSourceStart(int sourceStart);
 	int JavadocTypeArgumentsForRawGenericConstructor = Javadoc + Internal + 859;
 
 	/**
+	 * Null Annotations
+	 */
+	/** @since 3.7 */
+	int DefiniteNullFromNonNullMethod = MethodRelated + 880;
+	/** @since 3.7 */
+	int PotentialNullFromNonNullMethod = MethodRelated + 881;
+	/** @since 3.7 */
+	int NonNullReturnInsufficientInfo = MethodRelated + 882;
+	/** @since 3.7 */
+	int DefiniteNullToNonNullParameter = MethodRelated + 883;
+	/** @since 3.7 */
+	int PotentialNullToNonNullParameter = MethodRelated + 884;
+	/** @since 3.7 */
+	int NonNullParameterInsufficientInfo = MethodRelated + 885;
+	/** @since 3.7 */
+	int DefiniteNullToNonNullLocal = Internal + 886;
+	/** @since 3.7 */
+	int PotentialNullToNonNullLocal = Internal + 887;
+	/** @since 3.7 */
+	int NonNullLocalInsufficientInfo = Internal + 888;
+	/** @since 3.7 */
+	int ConflictingTypeEmulation = ImportRelated + 889;
+	/** @since 3.7 */
+	int MissingNullAnnotationType = ImportRelated + 890;
+	/** @since 3.7 */
+	int IllegalRedefinitionToNullableReturn = MethodRelated + 891;
+	/** @since 3.7 */
+	int IllegalRedefinitionToNonNullParameter = MethodRelated + 892;
+	/** @since 3.7 */
+	int IllegalDefinitionToNonNullParameter = MethodRelated + 893;
+
+	/**
 	 * External problems -- These are problems defined by other plugins
 	 */
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 8a41fd5..2db9e00 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -100,6 +101,12 @@ public abstract class AbstractMethodDeclaration
 				} else if (paramAnnotations != null) {
 					paramAnnotations[i] = Binding.NO_ANNOTATIONS;
 				}
+				// transfer nullness info from the argument to the method:
+				if ((argument.binding.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0) {
+					if (this.binding.parameterNonNullness == null)
+						this.binding.parameterNonNullness = new Boolean[this.arguments.length];
+					this.binding.parameterNonNullness[i] = Boolean.valueOf((argument.binding.tagBits & TagBits.AnnotationNonNull) != 0);
+				}
 			}
 			if (paramAnnotations != null)
 				this.binding.setParameterAnnotations(paramAnnotations);
@@ -415,7 +422,6 @@ public abstract class AbstractMethodDeclaration
 		}
 
 		try {
-			bindArguments();
 			bindThrownExceptions();
 			resolveJavadoc();
 			resolveAnnotations(this.scope, this.annotations, this.binding);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index 662603b..5c29532 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -161,6 +162,12 @@ public abstract class Annotation extends Expression {
 			case TypeIds.T_JavaLangSuppressWarnings :
 				tagBits |= TagBits.AnnotationSuppressWarnings;
 				break;
+			case TypeIds.T_ConfiguredAnnotationNullable :
+				tagBits |= TagBits.AnnotationNullable;
+				break;
+			case TypeIds.T_ConfiguredAnnotationNonNull :
+				tagBits |= TagBits.AnnotationNonNull;
+				break;
 		}
 		return tagBits;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 9fcf6b1..962ec33 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,8 +8,10 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Genady Beriozkin - added support for reporting assignment with no effect
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
- *     												and bug 292478 - Report potentially null across variable assignment
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
+ * 							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ * 							bug 292478 - Report potentially null across variable assignment
+ *     						bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -52,6 +54,14 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	flowInfo = ((Reference) this.lhs)
 		.analyseAssignment(currentScope, flowContext, flowInfo, this, false)
 		.unconditionalInits();
+	if (   local != null 
+		&& (local.tagBits & TagBits.AnnotationNonNull) != 0
+		&& nullStatus != FlowInfo.NON_NULL) 
+	{
+		currentScope.problemReporter().possiblyNullToNonNullLocal(local.name, this.expression, 
+				nullStatus,	currentScope.environment().globalOptions.nonNullAnnotationName);
+		nullStatus = FlowInfo.NON_NULL; // from now on assume we adhere to the contract
+	}
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
 		if (flowContext.initsOnFinally != null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 737e49c..aace6fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,8 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
- *     												and bug 292478 - Report potentially null across variable assignment
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
+ *     						bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     						bug 292478 - Report potentially null across variable assignment
+ *     						bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -80,6 +82,13 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.bits &= ~FirstAssignmentToLocal;  // int i = (i = 0);
 	}
 	flowInfo.markAsDefinitelyAssigned(this.binding);
+	if (   (this.binding.tagBits & TagBits.AnnotationNonNull) != 0
+		&& nullStatus != FlowInfo.NON_NULL)
+	{
+		currentScope.problemReporter().possiblyNullToNonNullLocal(this.name, this.initialization, 
+					nullStatus, currentScope.environment().globalOptions.nonNullAnnotationName);
+		nullStatus = FlowInfo.NON_NULL; // from now on assume we adhere to the contract
+	}		
 	if ((this.binding.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(this.binding, nullStatus);
 		// no need to inform enclosing try block since its locals won't get
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 0e4e8dc..fc02f12 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,7 +8,9 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Nick Teryaev - fix for bug (https://bugs.eclipse.org/bugs/show_bug.cgi?id=40752)
- *     Stephan Herrmann - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     Stephan Herrmann - Contributions for
+ *     						bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     						bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -80,6 +82,15 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
 			}
 			flowInfo = this.arguments[i].analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
+			// compare actual null-status against parameter annotations of the called method:
+			int nullStatus = this.arguments[i].nullStatus(flowInfo);
+			if (nullStatus != FlowInfo.NON_NULL 
+					&& this.binding.parameterNonNullness != null
+					&& this.binding.parameterNonNullness[i].booleanValue()) // if @NonNull is required
+			{
+				char[][] annotationName = currentScope.environment().globalOptions.nonNullAnnotationName;
+				currentScope.problemReporter().possiblyNullToNonNullParameter(this.arguments[i], nullStatus, annotationName[annotationName.length-1]);
+			}
 		}
 	}
 	ReferenceBinding[] thrownExceptions;
@@ -250,6 +261,14 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 public int nullStatus(FlowInfo flowInfo) {
+	if (this.binding.isValidBinding()) {
+		// try to retrieve null status of this message send from an annotation of the called method:
+		long tagBits = this.binding.tagBits;
+		if ((tagBits & TagBits.AnnotationNonNull) != 0)
+			return FlowInfo.NON_NULL;
+		if ((tagBits & TagBits.AnnotationNullable) != 0)
+			return FlowInfo.POTENTIALLY_NULL;
+	}
 	return FlowInfo.UNKNOWN;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 5b64c83..c24d3c4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -89,6 +90,12 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 						if (this.binding != null && this.binding.declaringClass == declaringElement)
 							this.bits &= ~ASTNode.CanBeStatic;
 					}
+					// leverage null-info from parameter annotations:
+					long argumentTagBits = this.arguments[i].binding.tagBits;
+					if ((argumentTagBits & TagBits.AnnotationNullable) != 0)
+						flowInfo.markPotentiallyNullBit(this.arguments[i].binding);
+					else if ((argumentTagBits & TagBits.AnnotationNonNull) != 0)
+						flowInfo.markAsDefinitelyNonNull(this.arguments[i].binding);
 				}
 			}
 			if (this.binding.declaringClass instanceof MemberTypeBinding && !this.binding.declaringClass.isStatic()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 5c07c63..1ae536b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     Stephan Herrmann - Contributions for 
+ *     						bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     						bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -40,6 +42,18 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
 			this.expression.checkNPE(currentScope, flowContext, flowInfo);
 		}
+		if (this.expression.nullStatus(flowInfo) != FlowInfo.NON_NULL) {
+			// if we can't prove non-null check against declared null-ness of the enclosing method:
+			AbstractMethodDeclaration referenceMethod = currentScope.methodScope().referenceMethod();
+			if (referenceMethod != null) {
+				MethodBinding method = referenceMethod.binding;
+				if ((method.tagBits & TagBits.AnnotationNonNull) != 0) {
+					char[][] annotationName = currentScope.environment().globalOptions.nonNullAnnotationName;
+					currentScope.problemReporter().possiblyNullFromNonNullMethod(this, this.expression.nullStatus(flowInfo), 
+																				 annotationName[annotationName.length-1]);
+				}
+			}
+		}
 	}
 	this.initStateIndex =
 		currentScope.methodScope().recordInitializationStates(flowInfo);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index 4cc5637..4384647 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -8,8 +8,10 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
- *     Stephan Herrmann  - Contribution for bug 236385
- *     Stephan Herrmann  - Contribution for bug 295551
+ *     Stephan Herrmann  - Contributions for 
+ *     							bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used 
+ *     							bug 295551 - Add option to automatically promote all warnings to errors
+ *     							bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -106,6 +108,9 @@ public class CompilerOptions {
 	public static final String OPTION_ReportNullReference = "org.eclipse.jdt.core.compiler.problem.nullReference"; //$NON-NLS-1$
 	public static final String OPTION_ReportPotentialNullReference = "org.eclipse.jdt.core.compiler.problem.potentialNullReference"; //$NON-NLS-1$
 	public static final String OPTION_ReportRedundantNullCheck = "org.eclipse.jdt.core.compiler.problem.redundantNullCheck"; //$NON-NLS-1$
+	public static final String OPTION_ReportNullContractViolation = "org.eclipse.jdt.core.compiler.problem.nullContractViolation";  //$NON-NLS-1$
+	public static final String OPTION_ReportPotentialNullContractViolation = "org.eclipse.jdt.core.compiler.problem.potentialNullContractViolation";  //$NON-NLS-1$
+	public static final String OPTION_ReportNullContractInsufficientInfo = "org.eclipse.jdt.core.compiler.problem.nullContractInsufficientInfo";  //$NON-NLS-1$
 	public static final String OPTION_ReportAutoboxing = "org.eclipse.jdt.core.compiler.problem.autoboxing"; //$NON-NLS-1$
 	public static final String OPTION_ReportAnnotationSuperInterface = "org.eclipse.jdt.core.compiler.problem.annotationSuperInterface"; //$NON-NLS-1$
 	public static final String OPTION_ReportMissingOverrideAnnotation = "org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation"; //$NON-NLS-1$
@@ -136,6 +141,10 @@ public class CompilerOptions {
 	public static final String OPTION_IncludeNullInfoFromAsserts = "org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts";  //$NON-NLS-1$
 	public static final String OPTION_ReportMethodCanBeStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic";  //$NON-NLS-1$
 	public static final String OPTION_ReportMethodCanBePotentiallyStatic = "org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic";  //$NON-NLS-1$
+	public static final String OPTION_NullableAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nullable"; //$NON-NLS-1$
+	public static final String OPTION_NonNullAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnull"; //$NON-NLS-1$
+	public static final String OPTION_EmulateNullAnnotationTypes = "org.eclipse.jdt.core.compiler.annotation.emulate"; //$NON-NLS-1$
+	public static final String OPTION_DefaultImportNullAnnotationTypes = "org.eclipse.jdt.core.compiler.annotation.defaultImport"; //$NON-NLS-1$
 	/**
 	 * Possible values for configurable options
 	 */
@@ -165,6 +174,9 @@ public class CompilerOptions {
 	public static final String NO_TAG = "no_tag";	//$NON-NLS-1$
 	public static final String ALL_STANDARD_TAGS = "all_standard_tags";	//$NON-NLS-1$
 
+	private static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
+	private static final char[][] DEFAULT_NULLABLE_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.Nullable".toCharArray()); //$NON-NLS-1$
+
 	/**
 	 * Bit mask for configurable problems (error/warning threshold)
 	 * Note: bitmask assumes 3 highest bits to denote irritant group (to allow storing 8 groups of 29 bits each
@@ -238,6 +250,9 @@ public class CompilerOptions {
 	public static final int UnusedObjectAllocation = IrritantSet.GROUP2 | ASTNode.Bit4;
 	public static final int MethodCanBeStatic = IrritantSet.GROUP2 | ASTNode.Bit5;
 	public static final int MethodCanBePotentiallyStatic = IrritantSet.GROUP2 | ASTNode.Bit6;
+	public static final int NullContractViolation = IrritantSet.GROUP2 | ASTNode.Bit7;
+	public static final int PotentialNullContractViolation = IrritantSet.GROUP2 | ASTNode.Bit8;
+	public static final int NullContractInsufficientInfo = IrritantSet.GROUP2 | ASTNode.Bit9;
 
 	// Severity level for handlers
 	/** 
@@ -359,6 +374,14 @@ public class CompilerOptions {
 	public boolean includeNullInfoFromAsserts;
 	/** Controls whether forced generic type problems get reported  */
 	public boolean reportUnavoidableGenericTypeProblems;
+	/** Fully qualified name of annotation to use as marker for nullable types. */
+	public char[][] nullableAnnotationName;
+	/** Fully qualified name of annotation to use as marker for nonnull types. */
+	public char[][] nonNullAnnotationName;
+	/** Should null annotation types be emulated by synthetic bindings? */
+	public boolean emulateNullAnnotationTypes;
+	/** Should null annotation types be imported by default? */
+	public boolean defaultImportNullAnnotationTypes;
 
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
@@ -498,6 +521,12 @@ public class CompilerOptions {
 				return OPTION_ReportPotentialNullReference;
 			case RedundantNullCheck :
 				return OPTION_ReportRedundantNullCheck;
+			case NullContractViolation :
+				return OPTION_ReportNullContractViolation;
+			case PotentialNullContractViolation :
+				return OPTION_ReportPotentialNullContractViolation;
+			case NullContractInsufficientInfo :
+				return OPTION_ReportNullContractInsufficientInfo;
 			case AutoBoxing :
 				return OPTION_ReportAutoboxing;
 			case AnnotationSuperInterface :
@@ -769,6 +798,9 @@ public class CompilerOptions {
 			case NullReference :
 			case PotentialNullReference :
 			case RedundantNullCheck :
+			case NullContractViolation :
+			case PotentialNullContractViolation :
+			case NullContractInsufficientInfo :
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -944,6 +976,9 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportNullReference, getSeverityString(NullReference));
 		optionsMap.put(OPTION_ReportPotentialNullReference, getSeverityString(PotentialNullReference));
 		optionsMap.put(OPTION_ReportRedundantNullCheck, getSeverityString(RedundantNullCheck));
+		optionsMap.put(OPTION_ReportNullContractViolation, getSeverityString(NullContractViolation));
+		optionsMap.put(OPTION_ReportPotentialNullContractViolation, getSeverityString(PotentialNullContractViolation));
+		optionsMap.put(OPTION_ReportNullContractInsufficientInfo, getSeverityString(NullContractInsufficientInfo));
 		optionsMap.put(OPTION_SuppressWarnings, this.suppressWarnings ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_SuppressOptionalErrors, this.suppressOptionalErrors ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportUnhandledWarningToken, getSeverityString(UnhandledWarningToken));
@@ -964,6 +999,16 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_IncludeNullInfoFromAsserts, this.includeNullInfoFromAsserts ? ENABLED : DISABLED);
 		optionsMap.put(OPTION_ReportMethodCanBeStatic, getSeverityString(MethodCanBeStatic));
 		optionsMap.put(OPTION_ReportMethodCanBePotentiallyStatic, getSeverityString(MethodCanBePotentiallyStatic));
+		if (this.nullableAnnotationName != null) {
+			char[] compoundName = CharOperation.concatWith(this.nullableAnnotationName, '.');
+			optionsMap.put(OPTION_NullableAnnotationName, String.valueOf(compoundName));
+		}
+		if (this.nonNullAnnotationName != null) {
+			char[] compoundName = CharOperation.concatWith(this.nonNullAnnotationName, '.');
+			optionsMap.put(OPTION_NonNullAnnotationName, String.valueOf(compoundName));
+		}
+		optionsMap.put(OPTION_EmulateNullAnnotationTypes, this.emulateNullAnnotationTypes ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_DefaultImportNullAnnotationTypes, this.defaultImportNullAnnotationTypes ? ENABLED : DISABLED);
 		return optionsMap;
 	}
 
@@ -1372,6 +1417,9 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportNullReference)) != null) updateSeverity(NullReference, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportPotentialNullReference)) != null) updateSeverity(PotentialNullReference, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportRedundantNullCheck)) != null) updateSeverity(RedundantNullCheck, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportNullContractViolation)) != null) updateSeverity(NullContractViolation, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportPotentialNullContractViolation)) != null) updateSeverity(PotentialNullContractViolation, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_ReportNullContractInsufficientInfo)) != null) updateSeverity(NullContractInsufficientInfo, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportAutoboxing)) != null) updateSeverity(AutoBoxing, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportAnnotationSuperInterface)) != null) updateSeverity(AnnotationSuperInterface, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportMissingOverrideAnnotation)) != null) updateSeverity(MissingOverrideAnnotation, optionValue);
@@ -1506,6 +1554,36 @@ public class CompilerOptions {
 				this.storeAnnotations = false;
 			}
 		}
+		if ((optionValue = optionsMap.get(OPTION_NullableAnnotationName)) != null) {
+			this.nullableAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+		}
+		if ((optionValue = optionsMap.get(OPTION_NonNullAnnotationName)) != null) {
+			this.nonNullAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+		}
+		if ((optionValue = optionsMap.get(OPTION_EmulateNullAnnotationTypes)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.emulateNullAnnotationTypes = true;
+				// ensure that we actually have annotation names to emulate:
+				if (this.nullableAnnotationName == null)
+					this.nullableAnnotationName = DEFAULT_NULLABLE_ANNOTATION_NAME;
+				if (this.nonNullAnnotationName == null)
+					this.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;
+			} else if (DISABLED.equals(optionValue)) {
+				this.emulateNullAnnotationTypes = false;
+			}
+		}
+		if ((optionValue = optionsMap.get(OPTION_DefaultImportNullAnnotationTypes)) != null) {
+			if (ENABLED.equals(optionValue)) {
+				this.defaultImportNullAnnotationTypes = true;
+				// ensure that we actually have annotation names to be used for default imports:
+				if (this.nullableAnnotationName == null)
+					this.nullableAnnotationName = DEFAULT_NULLABLE_ANNOTATION_NAME;
+				if (this.nonNullAnnotationName == null)
+					this.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;
+			} else if (DISABLED.equals(optionValue)) {
+				this.defaultImportNullAnnotationTypes = false;
+			}
+		}
 	}
 	public String toString() {
 		StringBuffer buf = new StringBuffer("CompilerOptions:"); //$NON-NLS-1$
@@ -1581,6 +1659,9 @@ public class CompilerOptions {
 		buf.append("\n\t- null reference: ").append(getSeverityString(NullReference)); //$NON-NLS-1$
 		buf.append("\n\t- potential null reference: ").append(getSeverityString(PotentialNullReference)); //$NON-NLS-1$
 		buf.append("\n\t- redundant null check: ").append(getSeverityString(RedundantNullCheck)); //$NON-NLS-1$
+		buf.append("\n\t- null contract violation: ").append(getSeverityString(NullContractViolation)); //$NON-NLS-1$
+		buf.append("\n\t- potential null contract vialotation: ").append(getSeverityString(PotentialNullContractViolation)); //$NON-NLS-1$
+		buf.append("\n\t- insufficient information for checking null contract: ").append(getSeverityString(NullContractInsufficientInfo)); //$NON-NLS-1$
 		buf.append("\n\t- autoboxing: ").append(getSeverityString(AutoBoxing)); //$NON-NLS-1$
 		buf.append("\n\t- annotation super interface: ").append(getSeverityString(AnnotationSuperInterface)); //$NON-NLS-1$
 		buf.append("\n\t- missing @Override annotation: ").append(getSeverityString(MissingOverrideAnnotation)); //$NON-NLS-1$
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 576b9bc..346bb65 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -58,9 +59,12 @@ public class IrritantSet {
 	public static final IrritantSet UNCHECKED = new IrritantSet(CompilerOptions.UncheckedTypeOperation);
 	public static final IrritantSet UNQUALIFIED_FIELD_ACCESS = new IrritantSet(CompilerOptions.UnqualifiedFieldAccess);
 
-	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // no optional error by default	
+	public static final IrritantSet COMPILER_DEFAULT_ERRORS = new IrritantSet(0); // see static initializer below	
 	public static final IrritantSet COMPILER_DEFAULT_WARNINGS = new IrritantSet(0); // see static initializer below
 	static {
+		COMPILER_DEFAULT_ERRORS
+			.set(CompilerOptions.NullContractViolation
+				 | CompilerOptions.PotentialNullContractViolation);
 		COMPILER_DEFAULT_WARNINGS
 			// group-0 warnings enabled by default
 			.set(
@@ -98,7 +102,8 @@ public class IrritantSet {
 			// group-2 warnings enabled by default
 			.set(
 				CompilerOptions.DeadCode
-				|CompilerOptions.Tasks);
+				| CompilerOptions.Tasks
+				| CompilerOptions.NullContractInsufficientInfo);
 			
 		ALL.setAll();
 		HIDING
@@ -107,7 +112,10 @@ public class IrritantSet {
 			.set(CompilerOptions.TypeHiding);
 		NULL
 			.set(CompilerOptions.PotentialNullReference)
-			.set(CompilerOptions.RedundantNullCheck);
+			.set(CompilerOptions.RedundantNullCheck)
+			.set(CompilerOptions.NullContractViolation)
+			.set(CompilerOptions.PotentialNullContractViolation)
+			.set(CompilerOptions.NullContractInsufficientInfo);
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
 		STATIC_ACCESS.set(CompilerOptions.NonStaticAccessToStatic);
 		UNUSED
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index cdab6d5..ac7afb8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -553,6 +554,8 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 			isAnnotationType() ? convertMemberValue(method.getDefaultValue(), this.environment, missingTypeNames) : null,
 			this.environment);
 
+	scanForNullAnnotation(method, result);
+
 	if (use15specifics)
 		result.tagBits |= method.getTagBits();
 	result.typeVariables = typeVars;
@@ -1092,6 +1095,53 @@ MethodBinding resolveTypesFor(MethodBinding method) {
 AnnotationBinding[] retrieveAnnotations(Binding binding) {
 	return AnnotationBinding.addStandardAnnotations(super.retrieveAnnotations(binding), binding.getAnnotationTagBits(), this.environment);
 }
+private void scanForNullAnnotation(IBinaryMethod method, MethodBinding result) {
+	char[][] nullableAnnotationName = this.environment.globalOptions.nullableAnnotationName;
+	char[][] nonNullAnnotationName = this.environment.globalOptions.nonNullAnnotationName;
+	if (nullableAnnotationName == null || nonNullAnnotationName == null)
+		return; // not configured to use null annotations
+
+	IBinaryAnnotation[] annotations = method.getAnnotations();
+	if (annotations != null) {
+		for (int i = 0; i < annotations.length; i++) {
+			char[] annotationTypeName = annotations[i].getTypeName();
+			if (annotationTypeName[0] != 'L')
+				continue;
+			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+			if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+				result.tagBits |= TagBits.AnnotationNonNull;
+				return;
+			}
+			if (CharOperation.equals(typeName, nullableAnnotationName)) {
+				result.tagBits |= TagBits.AnnotationNullable;
+				return;
+			}
+		}
+	}
+
+	for (int j = 0; j < result.parameters.length; j++) {
+		IBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j); 
+		if (paramAnnotations != null) {
+			for (int i = 0; i < paramAnnotations.length; i++) {
+				char[] annotationTypeName = paramAnnotations[i].getTypeName();
+				if (annotationTypeName[0] != 'L')
+					continue;
+				char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+				if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+					if (result.parameterNonNullness == null)
+						result.parameterNonNullness = new Boolean[result.parameters.length];
+					result.parameterNonNullness[j] = Boolean.TRUE;
+					break;
+				} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
+					if (result.parameterNonNullness == null)
+						result.parameterNonNullness = new Boolean[result.parameters.length];
+					result.parameterNonNullness[j] = Boolean.FALSE;
+					break;
+				}
+			}
+		}
+	}
+}
 SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	if (forceInitialize && this.storedAnnotations == null) {
 		if (!this.environment.globalOptions.storeAnnotations)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index d01198d..fd77fe1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,7 +7,8 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Erling Ellingsen -  patch for bug 125570
+ *     Erling Ellingsen - patch for bug 125570
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -160,7 +161,10 @@ void checkAndSetImports() {
 
 	// allocate the import array, add java.lang.* by default
 	int numberOfStatements = this.referenceContext.imports.length;
-	int numberOfImports = numberOfStatements + 1;
+	int numberOfDefaultImports = 1;
+	if (this.environment.globalOptions.defaultImportNullAnnotationTypes)
+		numberOfDefaultImports += 2;
+	int numberOfImports = numberOfStatements + numberOfDefaultImports;
 	for (int i = 0; i < numberOfStatements; i++) {
 		ImportReference importReference = this.referenceContext.imports[i];
 		if (((importReference.bits & ASTNode.OnDemand) != 0) && CharOperation.equals(TypeConstants.JAVA_LANG, importReference.tokens) && !importReference.isStatic()) {
@@ -169,8 +173,11 @@ void checkAndSetImports() {
 		}
 	}
 	ImportBinding[] resolvedImports = new ImportBinding[numberOfImports];
-	resolvedImports[0] = getDefaultImports()[0];
-	int index = 1;
+	ImportBinding[] defaultImports = getDefaultImports(); // consistent number of default imports is ensured in LookupEnvironment.makeNullAnnotationTypeImports()
+	for (int i = 0; i < numberOfDefaultImports; i++) {
+		resolvedImports[i] = defaultImports[i];
+	}
+	int index = numberOfDefaultImports;
 
 	nextImport : for (int i = 0; i < numberOfStatements; i++) {
 		ImportReference importReference = this.referenceContext.imports[i];
@@ -303,6 +310,13 @@ void faultInImports() {
 		return; // can be called when a field constant is resolved before static imports
 	if (this.referenceContext.imports == null) {
 		this.typeOrPackageCache = new HashtableOfObject(1);
+		for (int i = 0; i < this.imports.length; i++) {
+			// cache default-imported null annotation types:
+			if (!this.imports[i].onDemand) {
+				char[][] importName = this.imports[i].compoundName;
+				this.typeOrPackageCache.put(importName[importName.length-1], this.imports[i].resolvedImport);
+			}
+		}
 		return;
 	}
 
@@ -327,9 +341,18 @@ void faultInImports() {
 			break;
 		}
 	}
+	int numberOfDefaultImports = 1;
+	if (this.environment.globalOptions.defaultImportNullAnnotationTypes) {
+		numberOfDefaultImports += 2;
+		numberOfImports += 2;
+	}
 	ImportBinding[] resolvedImports = new ImportBinding[numberOfImports];
-	resolvedImports[0] = getDefaultImports()[0];
-	int index = 1;
+	ImportBinding[] defaultImports = getDefaultImports(); // consistent number of default imports is ensured in LookupEnvironment.makeNullAnnotationTypeImports()
+	for (int i = 0; i < numberOfDefaultImports; i++) {
+		resolvedImports[i] = defaultImports[i];
+	}
+
+	int index = numberOfDefaultImports;
 
 	// keep static imports with normal imports until there is a reason to split them up
 	// on demand imports continue to be packages & types. need to check on demand type imports for fields/methods
@@ -613,7 +636,19 @@ ImportBinding[] getDefaultImports() {
 		importBinding = missingObject.fPackage;
 	}
 
-	return this.environment.defaultImports = new ImportBinding[] {new ImportBinding(TypeConstants.JAVA_LANG, true, importBinding, null)};
+	ImportBinding javaLangImport = new ImportBinding(TypeConstants.JAVA_LANG, true, importBinding, null);
+	ImportBinding[] nullAnnotationImports = this.environment.makeNullAnnotationTypeImports(); // trigger regardless of option below
+	if (this.environment.globalOptions.defaultImportNullAnnotationTypes) {
+		ImportBinding[] allDefaultImports = new ImportBinding[nullAnnotationImports.length+1];// java.lang.* + null-annotations
+		allDefaultImports[0] = javaLangImport;
+		System.arraycopy(nullAnnotationImports, 0,
+						 allDefaultImports, 1,
+						 nullAnnotationImports.length);
+		this.environment.defaultImports = allDefaultImports;
+	} else {
+		this.environment.defaultImports = new ImportBinding[] {javaLangImport};
+	}
+	return this.environment.defaultImports;
 }
 // NOT Public API
 public final Binding getImport(char[][] compoundName, boolean onDemand, boolean isStaticImport) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index dedeb91..c534946 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1314,6 +1315,74 @@ boolean isPackage(char[][] compoundName, char[] name) {
 		return this.nameEnvironment.isPackage(null, name);
 	return this.nameEnvironment.isPackage(compoundName, name);
 }
+
+private ReferenceBinding makeNullAnnotationType(char[][] compoundName, int typeId) {
+	char[][] packageName = CharOperation.subarray(compoundName, 0, compoundName.length-1);
+	PackageBinding packageBinding = createPackage(packageName);
+	ReferenceBinding typeBinding = packageBinding.getType(compoundName[compoundName.length-1]);
+	if (typeBinding != null && typeBinding.isValidBinding())
+		this.problemReporter.conflictingTypeEmulation(compoundName); // does not return
+
+	BinaryTypeBinding emulatedType = new BinaryTypeBinding();
+	emulatedType.compoundName = compoundName;
+	emulatedType.sourceName = compoundName[compoundName.length-1];
+	emulatedType.modifiers = ClassFileConstants.AccAnnotation | ClassFileConstants.AccPublic;
+	emulatedType.fields = Binding.NO_FIELDS;
+	emulatedType.methods = Binding.NO_METHODS;
+	emulatedType.memberTypes = Binding.NO_MEMBER_TYPES;
+	emulatedType.superclass = getType(TypeConstants.JAVA_LANG_OBJECT);
+	emulatedType.superInterfaces = Binding.NO_SUPERINTERFACES;
+	emulatedType.fPackage = packageBinding;
+	emulatedType.typeVariables = Binding.NO_TYPE_VARIABLES;
+	emulatedType.tagBits = TagBits.AreFieldsComplete | TagBits.AreFieldsSorted 
+							| TagBits.AreMethodsComplete | TagBits.AreMethodsSorted 
+							| TagBits.HasNoMemberTypes | TagBits.TypeVariablesAreConnected
+							| TagBits.AnnotationClassRetention 
+							| TagBits.AnnotationForMethod | TagBits.AnnotationForParameter 
+							| TagBits.AnnotationForLocalVariable ;
+	emulatedType.id = typeId;
+	
+	packageBinding.addType(emulatedType);
+
+	return emulatedType;
+}
+
+protected ImportBinding[] makeNullAnnotationTypeImports() {
+	char[][] nullableAnnotationName = this.globalOptions.nullableAnnotationName;
+	char[][] nonNullAnnotationName = this.globalOptions.nonNullAnnotationName;
+	if (nullableAnnotationName == null || nonNullAnnotationName == null) {
+		if (this.globalOptions.emulateNullAnnotationTypes || this.globalOptions.defaultImportNullAnnotationTypes)
+			// shouldn't happen by construction of CompilerOptions.set(Map)
+			this.problemReporter.abortDueToInternalError("Inconsistent null annotation options"); //$NON-NLS-1$
+		return new ImportBinding[0];
+	}
+	// fetch annotation types for emulation and/or default import:
+	ReferenceBinding nullableAnnotationType = null;
+	ReferenceBinding nonNullAnnotationType = null;
+	if (this.globalOptions.emulateNullAnnotationTypes) {
+		nullableAnnotationType = makeNullAnnotationType(nullableAnnotationName, TypeIds.T_ConfiguredAnnotationNullable);
+		nonNullAnnotationType  = makeNullAnnotationType(nonNullAnnotationName, TypeIds.T_ConfiguredAnnotationNonNull);
+	} else { // not emulated means those types should exist (and need to be marked):
+		nullableAnnotationType = getType(nullableAnnotationName);
+		if (nullableAnnotationType != null && nullableAnnotationType.isValidBinding())
+			nullableAnnotationType.id = TypeIds.T_ConfiguredAnnotationNullable;
+		else if (this.globalOptions.defaultImportNullAnnotationTypes)
+			this.problemReporter.missingNullAnnotationType(nullableAnnotationName);
+
+		nonNullAnnotationType  = getType(nonNullAnnotationName);
+		if (nonNullAnnotationType != null && nonNullAnnotationType.isValidBinding())
+			nonNullAnnotationType.id = TypeIds.T_ConfiguredAnnotationNonNull;
+		else if (this.globalOptions.defaultImportNullAnnotationTypes)
+			this.problemReporter.missingNullAnnotationType(nonNullAnnotationName);
+	}
+	if (this.globalOptions.defaultImportNullAnnotationTypes)
+		return new ImportBinding[] {
+				new ImportBinding(nullableAnnotationName, false, nullableAnnotationType, null),
+				new ImportBinding(nonNullAnnotationName, false, nonNullAnnotationType, null)
+		};
+	return new ImportBinding[0];
+}
+
 // The method verifier is lazily initialized to guarantee the receiver, the compiler & the oracle are ready.
 public MethodVerifier methodVerifier() {
 	if (this.verifier == null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index bfd3739..51ff598 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -28,6 +29,7 @@ public class MethodBinding extends Binding {
 	public char[] selector;
 	public TypeBinding returnType;
 	public TypeBinding[] parameters;
+	public Boolean[] parameterNonNullness; // TRUE means @NonNull declared, FALSE means @Nullable declared, null means nothing declared
 	public ReferenceBinding[] thrownExceptions;
 	public ReferenceBinding declaringClass;
 	public TypeVariableBinding[] typeVariables = Binding.NO_TYPE_VARIABLES;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
index 33117b2..36bcffe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,6 +8,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
+ *     Stephan Herrmann  - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -152,6 +153,8 @@ void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] m
 				// interface I { @Override Object clone(); } does not override Object#clone()
 				currentMethod.modifiers |= ExtraCompilerModifiers.AccOverriding;
 			}
+			if (!currentMethod.isStatic())
+				checkNullContractCompatibility(currentMethod, inheritedMethod);
 
 			if (!areReturnTypesCompatible(currentMethod, inheritedMethod)
 					&& (currentMethod.returnType.tagBits & TagBits.HasMissingType) == 0) {
@@ -184,7 +187,9 @@ void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] m
 		checkForBridgeMethod(currentMethod, inheritedMethod, allInheritedMethods);
 	}
 }
-
+protected void checkNullContractCompatibility(MethodBinding currentMethod, MethodBinding inheritedMethod) {
+	// nothing to do here. Real action happens at 1.5+
+}
 public void reportRawReferences(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	// nothing to do here. Real action happens at 1.5+
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index 412d0b1..3770720 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -407,6 +408,62 @@ boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMetho
 	return false;
 }
 
+protected void checkNullContractCompatibility(MethodBinding currentMethod, MethodBinding inheritedMethod) {
+	// return type:
+	if ((inheritedMethod.tagBits & TagBits.AnnotationNonNull) != 0) {
+		if ((currentMethod.tagBits & TagBits.AnnotationNullable) != 0) {
+			AbstractMethodDeclaration methodDecl = currentMethod.sourceMethod();
+			this.type.scope.problemReporter().illegalRedefinitionToNullableReturn(methodDecl, inheritedMethod.declaringClass, 
+																			this.environment.globalOptions.nonNullAnnotationName);
+		}
+	}
+	if ((currentMethod.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+		currentMethod.tagBits |= (inheritedMethod.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable));
+
+	// parameters:
+	if (inheritedMethod.parameterNonNullness != null) {
+		// inherited method has null-annotations, check and possibly transfer:
+		
+		// prepare for transfering (contract inheritance):
+		if (currentMethod.parameterNonNullness == null)
+			currentMethod.parameterNonNullness = new Boolean[currentMethod.parameters.length];
+		
+		for (int i = 0; i < inheritedMethod.parameterNonNullness.length; i++) {
+			
+			Boolean inheritedNonNullNess = inheritedMethod.parameterNonNullness[i];
+			if (inheritedNonNullNess != Boolean.TRUE) { 	 				 // super parameter is not restricted to @NonNull
+				if (currentMethod.parameterNonNullness[i] == Boolean.TRUE) { // current parameter is restricted to @NonNull
+					this.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(
+																	currentMethod.sourceMethod().arguments[i],
+																	inheritedMethod.declaringClass,
+																	inheritedNonNullNess == null
+																	? null
+																	: this.environment.globalOptions.nullableAnnotationName);
+					continue;
+				} 
+			}
+			
+			if (currentMethod.parameterNonNullness[i] == null && inheritedNonNullNess != null) {
+				// inherit this annotation as the current method has no annotation:
+				currentMethod.parameterNonNullness[i] = inheritedNonNullNess;
+				VariableBinding argumentBinding = currentMethod.sourceMethod().arguments[i].binding;
+				argumentBinding.tagBits |= inheritedNonNullNess.booleanValue()
+												? TagBits.AnnotationNonNull : TagBits.AnnotationNullable;
+			}
+		}
+	} else if (currentMethod.parameterNonNullness != null) {
+		// super method has no annotations but current has
+		for (int i = 0; i < currentMethod.parameterNonNullness.length; i++) {
+			if (currentMethod.parameterNonNullness[i] == Boolean.TRUE) { // tightening from unconstrained to @NonNull
+				this.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(
+																currentMethod.sourceMethod().arguments[i],
+																inheritedMethod.declaringClass,
+																null);
+			}
+		}
+	}
+}
+
 void reportRawReferences() {
 	CompilerOptions compilerOptions = this.type.scope.compilerOptions();
 	if (compilerOptions.sourceLevel < ClassFileConstants.JDK1_5 // shouldn't whine at all
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index 2b63f7e..e8448e8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -1420,9 +1421,12 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 			}
 		}
 		// only assign parameters if no problems are found
-		if (!foundArgProblem) {
+		if (foundArgProblem) {
+			methodDecl.binding = null;
+		} else {
 			method.parameters = newParameters;
 		}
+		methodDecl.bindArguments();
 	}
 
 	boolean foundReturnTypeProblem = false;
@@ -1465,7 +1469,6 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 		}
 	}
 	if (foundArgProblem) {
-		methodDecl.binding = null;
 		method.parameters = Binding.NO_PARAMETERS; // see 107004
 		// nullify type parameter bindings as well as they have a backpointer to the method binding
 		// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=81134)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
index 6d91209..4aebfc6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -119,10 +120,13 @@ public interface TagBits {
 	long AnnotationInherited = ASTNode.Bit49L;
 	long AnnotationOverride = ASTNode.Bit50L;
 	long AnnotationSuppressWarnings = ASTNode.Bit51L;
-	long AllStandardAnnotationsMask = AnnotationTargetMASK | AnnotationRetentionMASK | AnnotationDeprecated | AnnotationDocumented | AnnotationInherited |  AnnotationOverride | AnnotationSuppressWarnings;
+	long AnnotationNullable = ASTNode.Bit52L;
+	long AnnotationNonNull = ASTNode.Bit53L;
+	long AllStandardAnnotationsMask = AnnotationTargetMASK | AnnotationRetentionMASK | AnnotationDeprecated | AnnotationDocumented 
+				| AnnotationInherited |  AnnotationOverride | AnnotationSuppressWarnings | AnnotationNullable | AnnotationNonNull;
 
-	long DefaultValueResolved = ASTNode.Bit52L;
+	long DefaultValueResolved = ASTNode.Bit54L;
 
 	// set when type contains non-private constructor(s)
-	long HasNonPrivateConstructor = ASTNode.Bit53L;
+	long HasNonPrivateConstructor = ASTNode.Bit55L;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 3e9b82e..1debf06 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for Bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -89,6 +90,9 @@ public interface TypeIds {
 	
 	final int T_JavaUtilCollection = 59;
 
+	final int T_ConfiguredAnnotationNullable = 60;
+	final int T_ConfiguredAnnotationNonNull = 61;
+
 	final int NoId = Integer.MAX_VALUE;
 
 	public static final int IMPLICIT_CONVERSION_MASK = 0xFF;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index 4d33d42..86c23c2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,7 +8,9 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
- *     Stephan Herrmann  - Contribution for bug 236385
+ *     Stephan Herrmann  - Contributions for 
+ *     							bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
+ *     							bug 186342 - [compiler][null]Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -81,6 +83,7 @@ import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
@@ -293,6 +296,22 @@ public static int getIrritant(int problemID) {
 		case IProblem.NullLocalVariableInstanceofYieldsFalse:
 			return CompilerOptions.RedundantNullCheck;
 
+		case IProblem.DefiniteNullFromNonNullMethod:
+		case IProblem.DefiniteNullToNonNullLocal:
+		case IProblem.DefiniteNullToNonNullParameter:
+		case IProblem.IllegalRedefinitionToNullableReturn:
+		case IProblem.IllegalRedefinitionToNonNullParameter:
+		case IProblem.IllegalDefinitionToNonNullParameter:
+			return CompilerOptions.NullContractViolation;
+		case IProblem.PotentialNullFromNonNullMethod:
+		case IProblem.PotentialNullToNonNullLocal:
+		case IProblem.PotentialNullToNonNullParameter:
+			return CompilerOptions.PotentialNullContractViolation;
+		case IProblem.NonNullLocalInsufficientInfo:
+		case IProblem.NonNullParameterInsufficientInfo:
+		case IProblem.NonNullReturnInsufficientInfo:
+			return CompilerOptions.NullContractInsufficientInfo;
+
 		case IProblem.BoxingConversion :
 		case IProblem.UnboxingConversion :
 			return CompilerOptions.AutoBoxing;
@@ -469,6 +488,9 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.NullReference :
 			case CompilerOptions.PotentialNullReference :
 			case CompilerOptions.RedundantNullCheck :
+			case CompilerOptions.NullContractViolation :
+			case CompilerOptions.PotentialNullContractViolation :
+			case CompilerOptions.NullContractInsufficientInfo :
 			case CompilerOptions.IncompleteEnumSwitch :
 			case CompilerOptions.FallthroughCase :
 			case CompilerOptions.OverridingMethodWithoutSuperInvocation :
@@ -530,6 +552,8 @@ public static int getProblemCategory(int severity, int problemID) {
 	switch (problemID) {
 		case IProblem.IsClassPathCorrect :
 		case IProblem.CorruptedSignature :
+		case IProblem.ConflictingTypeEmulation :
+		case IProblem.MissingNullAnnotationType :
 			return CategorizedProblem.CAT_BUILDPATH;
 
 		default :
@@ -1331,6 +1355,15 @@ public void conflictingImport(ImportReference importRef) {
 		importRef.sourceStart,
 		importRef.sourceEnd);
 }
+public void conflictingTypeEmulation(char[][] compoundName) {
+	String[] arguments = new String[] {CharOperation.toString(compoundName)};
+	this.handle(
+		IProblem.ConflictingTypeEmulation,
+		arguments,
+		arguments,
+		ProblemSeverities.Error | ProblemSeverities.Abort | ProblemSeverities.Fatal, // not configurable
+		0, 0);	
+}
 public void constantOutOfRange(Literal literal, TypeBinding literalType) {
 	String[] arguments = new String[] {new String(literalType.readableName()), new String(literal.source())};
 	this.handle(
@@ -2437,6 +2470,32 @@ public void illegalQualifiedParameterizedTypeAllocation(TypeReference qualifiedT
 		qualifiedTypeReference.sourceStart,
 		qualifiedTypeReference.sourceEnd);
 }
+public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
+	if (inheritedAnnotationName == null) {
+		this.handle(
+			IProblem.IllegalDefinitionToNonNullParameter, 
+			new String[] { new String(argument.name), new String(declaringClass.readableName()) },
+			new String[] { new String(argument.name), new String(declaringClass.shortReadableName()) },
+			argument.sourceStart, 
+			argument.sourceEnd);
+		
+	} else {
+		this.handle(
+			IProblem.IllegalRedefinitionToNonNullParameter, 
+			new String[] { new String(argument.name), new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
+			new String[] { new String(argument.name), new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
+			argument.sourceStart, 
+			argument.sourceEnd);
+	}
+}
+public void illegalRedefinitionToNullableReturn(AbstractMethodDeclaration methodDecl, ReferenceBinding declaringClass, char[][] nonNullAnnotationName) {
+	this.handle(
+		IProblem.IllegalRedefinitionToNullableReturn, 
+		new String[] { new String(declaringClass.readableName()), CharOperation.toString(nonNullAnnotationName)},
+		new String[] { new String(declaringClass.shortReadableName()), new String(nonNullAnnotationName[nonNullAnnotationName.length-1])},
+		methodDecl.sourceStart, 
+		methodDecl.sourceEnd);	
+}
 public void illegalStaticModifierForMemberType(SourceTypeBinding type) {
 	String[] arguments = new String[] {new String(type.sourceName())};
 	this.handle(
@@ -5116,6 +5175,11 @@ public void missingEnumConstantCase(SwitchStatement switchStatement, FieldBindin
 		switchStatement.expression.sourceStart,
 		switchStatement.expression.sourceEnd);
 }
+
+public void missingNullAnnotationType(char[][] nullAnnotationName) {
+	String[] args = { new String(CharOperation.concatWith(nullAnnotationName, '.')) };
+	this.handle(IProblem.MissingNullAnnotationType, args, args, 0, 0);	
+}
 public void missingOverrideAnnotation(AbstractMethodDeclaration method) {
 	int severity = computeSeverity(IProblem.MissingOverrideAnnotation);
 	if (severity == ProblemSeverities.Ignore) return;
@@ -6078,6 +6142,51 @@ public void possibleFallThroughCase(CaseStatement caseStatement) {
 		caseStatement.sourceStart,
 		caseStatement.sourceEnd);
 }
+public void possiblyNullFromNonNullMethod(ReturnStatement returnStatement, int nullStatus, char[] annotationName) {
+	int problemId = IProblem.NonNullReturnInsufficientInfo;
+	if ((nullStatus & FlowInfo.NULL) != 0)
+		problemId = IProblem.DefiniteNullFromNonNullMethod;
+	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
+		problemId = IProblem.PotentialNullFromNonNullMethod;
+	String[] arguments = new String[] { String.valueOf(annotationName) };
+	this.handle(
+		problemId,
+		arguments,
+		arguments,
+		returnStatement.sourceStart,
+		returnStatement.sourceEnd);
+}
+public void possiblyNullToNonNullLocal(char[] variableName, Expression expression, int nullStatus, char[][] annotationName) {
+	int problemId = IProblem.NonNullLocalInsufficientInfo;
+	if ((nullStatus & FlowInfo.NULL) != 0)
+		problemId = IProblem.DefiniteNullToNonNullLocal;
+	else if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
+		problemId = IProblem.PotentialNullToNonNullLocal;
+	String[] arguments = new String[] {
+			String.valueOf(variableName),
+			String.valueOf(annotationName[annotationName.length-1]) 
+	};
+	this.handle(
+		problemId,
+		arguments,
+		arguments,
+		expression.sourceStart,
+		expression.sourceEnd);
+}
+public void possiblyNullToNonNullParameter(Expression argument, int nullStatus, char[] annotationName) {
+	int problemId = IProblem.NonNullParameterInsufficientInfo;
+	if ((nullStatus & FlowInfo.NULL) != 0)
+		problemId = IProblem.DefiniteNullToNonNullParameter;
+	else if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
+		problemId = IProblem.PotentialNullToNonNullParameter;
+	String[] arguments = new String[] { String.valueOf(annotationName) };
+	this.handle(
+		problemId,
+		arguments,
+		arguments,
+		argument.sourceStart,
+		argument.sourceEnd);
+}
 public void publicClassMustMatchFileName(CompilationUnitDeclaration compUnitDecl, TypeDeclaration typeDecl) {
 	this.referenceContext = typeDecl; // report the problem against the type not the entire compilation unit
 	String[] arguments = new String[] {new String(compUnitDecl.getFileName()), new String(typeDecl.name)};
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 7684bb8..7e71f5a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -1,5 +1,5 @@
 ###############################################################################
-# Copyright (c) 2000, 2010 IBM Corporation and others.
+# Copyright (c) 2000, 2011 IBM Corporation and others.
 # All rights reserved. This program and the accompanying materials
 # are made available under the terms of the Eclipse Public License v1.0
 # which accompanies this distribution, and is available at
@@ -8,7 +8,9 @@
 # Contributors:
 #     IBM Corporation - initial API and implementation
 #		Benjamin Muskalla - Contribution for bug 239066
-#		Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+#		Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+#						bug 185682 - Increment/decrement operators mark local variables as read
+#				 		bug 186342 - [compiler][null]Using annotations for null checking
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -619,6 +621,22 @@
 858 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
 859 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
 
+### NULL ANNOTATIONS
+880 = Null contract violation: returning null from a method declared as @{0}.
+881 = Null contract violation: return value can be null but method is declared as @{0}.
+882 = Potential null contract violation: insufficient nullness information regarding return value while the method is declared as @{0}.
+883 = Null contract violation: passing null to a parameter declared as @{0}.
+884 = Null contract violation: potentially passing null to a parameter declared as @{0}.
+885 = Potential null contract violation: insufficient nullness information regarding a value that is passed to a parameter declared as @{0}.
+886 = Null contract violation: assigning null to local variable {0}, which is declared as @{1}.
+887 = Null contract violation: potentially assigning null to local variable {0}, which is declared as @{1}.
+888 = Potential null contract violation: insufficient nullness information regarding a value that is assigned to local variable {0}, which is declared as @{1}.
+889 = Buildpath problem: emulation of type {0} is requested (for null annotations) but a type of this name exists on the build path.
+890 = Buildpath problem: the type {0} which is configured as a null annotation type cannot be resolved.
+891 = Cannot relax null contract for method return, inherited method from {0} is declared as @{1}.
+892 = Cannot tighten null contract for parameter {0}, inherited method from {1} declares this parameter as @{2}.
+893 = Cannot tighten null contract for parameter {0}, inherited method from {1} does not constrain this parameter.
+
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type {1} is not accessible due to restriction on classpath entry {0}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index f0b3ecf..22a2ae1 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -81,8 +81,16 @@
  *                                 COMPILER_PB_UNUSED_DECLARED_THROWN_EXCEPTION_EXEMPT_EXCEPTION_AND_THROWABLE
  *     IBM Corporation - added getOptionForConfigurableSeverity(int)
  *     Benjamin Muskalla - added COMPILER_PB_MISSING_SYNCHRONIZED_ON_INHERITED_METHOD
- *     Stephan Herrmann  - added COMPILER_PB_UNUSED_OBJECT_ALLOCATION
- *     Stephan Herrmann  - added COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS
+ *     Stephan Herrmann  - added the following constants:
+ *     								COMPILER_PB_UNUSED_OBJECT_ALLOCATION
+ *     								COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS
+ *     								COMPILER_NULLABLE_ANNOTATION_NAME
+ *     								COMPILER_NONNULL_ANNOTATION_NAME
+ *     								COMPILER_EMULATE_NULL_ANNOTATION_TYPES
+ *     								COMPILER_DEFAULT_IMPORT_NULL_ANNOTATION_TYPES
+ *     								COMPILER_PB_NULL_CONTRACT_VIOLATION
+ *     							 	COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION
+ *     							 	COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1576,6 +1584,172 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_POTENTIAL_NULL_REFERENCE = PLUGIN_ID + ".compiler.problem.potentialNullReference"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Name of Annotation Type for Nullable Types.
+	 * <p>This option defines a fully qualified Java type name that the compiler may use
+	 *    to perform special null analysis.</p>
+	 * <p>If the annotation specified by this option is applied to a type in a method
+	 *    signature or variable declaration this will be interpreted as a contract that 
+	 *    <code>null</code> is a legal value in that position. Currently supported
+	 *    positions are: method parameters, method return type and local variables.</p>
+	 * <p>If a value whose type
+	 *    is annotated with this annotation is dereferenced without checking for null
+	 *    the compiler will trigger a diagnostic as further controlled by 
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}.</p>
+	 * <p>The compiler may furthermore check adherence to the null contract as further
+	 *    controlled by {@link #COMPILER_PB_NULL_CONTRACT_VIOLATION}, 
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION} and
+	 *    {@link #COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO}.
+	 * </p>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code></dd>
+	 * <dt>Possible values:</dt><dd>any legal Java type name</dd>
+	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.Nullable"</code></dd>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_NULLABLE_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nullable"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Name of Annotation Type for Non-Null Types.
+	 * <p>This option defines a fully qualified Java type name that the compiler may use
+	 *    to perform special null analysis.</p>
+	 * <p>If the annotation specified by this option is applied to a type in a method
+	 *    signature or variable declaration this will be interpreted as a contract that 
+	 *    <code>null</code> is <b>not</b> a legal value in that position. Currently 
+	 *    supported positions are: method parameters, method return type and local variables.</p>
+	 * <p>For values declared with this annotation the compiler will never trigger a null
+	 *    reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
+	 *    and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
+	 *    will never occur at runtime in these positions.</p>
+	 * <p>The compiler may furthermore check adherence to the null contract as further
+	 *    controlled by {@link #COMPILER_PB_NULL_CONTRACT_VIOLATION}, 
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION} and
+	 *    {@link #COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO}.
+	 * </p>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code></dd>
+	 * <dt>Possible values:</dt><dd>any legal Java type name</dd>
+	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.NonNull"</code></dd>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_NONNULL_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnull"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Emulate Null Annotation Types.
+	 * <p>When enabled, the compiler will use the annotation types specified in
+	 *    {@link #COMPILER_NONNULL_ANNOTATION_NAME} and {@link #COMPILER_NULLABLE_ANNOTATION_NAME}
+	 *    without searching for a corresponding type definition, ie., these annotation
+	 *    types don't have to actually exist.</p>
+	 * <p>This option is used to make null contract analysis independent of any additional
+	 *    classes that would otherwise need to be supplied at compile time.</p>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.emulate"</code></dd>
+	 * <dt>Possible values:</dt><dd>{ "disabled", "enabled" }</dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_EMULATE_NULL_ANNOTATION_TYPES = PLUGIN_ID + ".compiler.annotation.emulate"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Default Import of Null Annotation Types.
+	 * <p>When enabled, the compiler will be able to resolve the annotation types specified in
+	 *    {@link #COMPILER_NONNULL_ANNOTATION_NAME} and {@link #COMPILER_NULLABLE_ANNOTATION_NAME}
+	 *    by their simple names without an explicit import statement.</p>
+	 * <p>This option is used to avoid mentioning the fully qualified annotation names
+	 *    in any source files, as to facility the migration from one set of annotations
+	 *    to another, e.g., when standard annotations for this purpose will be defined
+	 *    in the future.
+	 * </p> 
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.defaultImport"</code></dd>
+	 * <dt>Possible values:</dt><dd>{ "disabled", "enabled" }</dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_DEFAULT_IMPORT_NULL_ANNOTATION_TYPES = PLUGIN_ID + ".compiler.annotation.defaultImport"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Violations of Null Contracts.
+	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the 
+	 *    following situations is detected:
+	 *    <ol>
+	 *    <li>A method declared with a nonnull annotation returns an expression that is 
+	 *    	  statically known to evaluate to a null value.</li>
+	 *    <li>An expression that is statically known to evaluate to a null value is passed 
+	 *        as an argument in a method call where the corresponding parameter of the called
+	 *        method is declared with a nonnull annotation.</li>
+	 *    <li>A method that overrides or implements an inherited method declared with a nonnull
+	 *        annotation tries to relax that contract by specifying a nullable annotation
+	 *        (prohibition of contravariant return).</li>
+	 *    <li>A method that overrides or implements an inherited method which has a nullable
+	 *        declaration for at least one of its parameters, tries to tighten that null contract
+	 *        by specifying a nonnull annotation for its corresponding parameter
+	 *        (prohibition of covariant parameters).</li>
+	 *    </ol>         
+	 * </p>
+	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+	 *    shall interpret as nonnull or nullable annotations, respectively.
+	 * </p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullContractViolation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"error"</code></dd>
+	 * </dl>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NULL_CONTRACT_VIOLATION = PLUGIN_ID + ".compiler.problem.nullContractViolation"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Violations of Null Contracts with Potential Null Value.
+	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the 
+	 *    following situations is detected:
+	 *    <ol>
+	 *    <li>A method declared with a nonnull annotation returns an expression that is 
+	 *    	  statically known to evaluate to a null value on some flow.</li>
+	 *    <li>An expression that is statically known to evaluate to a null value on some flow
+	 *        is passed as an argument in a method call where the corresponding parameter of 
+	 *        the called method is declared with a nonnull annotation.</li>
+	 *    </ol>         
+	 * </p>
+	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+	 *    shall interpret as nonnull or nullable annotations, respectively.
+	 * </p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.potentialNullContractViolation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"error"</code></dd>
+	 * </dl>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_POTENTIAL_NULL_CONTRACT_VIOLATION = PLUGIN_ID + ".compiler.problem.potentialNullContractViolation"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Insufficient Information for Analysing Adherence to Null Contracts.
+	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the 
+	 *    following situations is detected:
+	 *    <ol>
+	 *    <li>A method declared with a nonnull annotation returns an expression for which 
+	 *        insufficient nullness information is available for statically proving that no
+	 *        flow will pass a null value at runtime.</li>
+	 *    <li>An expression for which insufficient nullness information is available for 
+	 *        statically proving that it will never evaluate to a null value at runtime
+	 *        is passed as an argument in a method call where the corresponding parameter of 
+	 *        the called method is declared with a nonnull annotation.</li>
+	 *    </ol>
+	 *    Insufficient nullness information is usually a consequence of using other unannotated
+	 *    variables or methods.
+	 * </p>
+	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+	 *    shall interpret as nonnull or nullable annotations, respectively.
+	 * </p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullContractInsufficientInfo"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.7
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NULL_CONTRACT_INSUFFICIENT_INFO = PLUGIN_ID + ".compiler.problem.nullContractInsufficientInfo"; //$NON-NLS-1$
+	/**
 	 * Compiler option ID: Reporting Redundant Null Check.
 	 * <p>When enabled, the compiler will issue an error or a warning whenever a
 	 *    variable that is statically known to hold a null or a non-null value
commit 7bb5ad79ed154ad2ecc75a7956f143415e87d242
Author: Stephan Herrmann <sherrmann>
Date:   Tue Nov 29 10:46:10 2011 +0100

    HEAD - Supporting new bundle (annotation types) for
    Bug 186342: [compiler][null] Using annotations for null checking

7	0	org.eclipse.jdt.annotation/.classpath
28	0	org.eclipse.jdt.annotation/.project
12	0	org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
9	0	org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
28	0	org.eclipse.jdt.annotation/about.html
15	0	org.eclipse.jdt.annotation/build.properties
12	0	org.eclipse.jdt.annotation/bundle.properties
45	0	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
46	0	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
36	0	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
diff --git a/org.eclipse.jdt.annotation/.classpath b/org.eclipse.jdt.annotation/.classpath
new file mode 100644
index 0000000..304e861
--- /dev/null
+++ b/org.eclipse.jdt.annotation/.classpath
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.annotation/.project b/org.eclipse.jdt.annotation/.project
new file mode 100644
index 0000000..d76a3e1
--- /dev/null
+++ b/org.eclipse.jdt.annotation/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.eclipse.jdt.annotation</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.pde.PluginNature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..5277d93
--- /dev/null
+++ b/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,12 @@
+#Sun Feb 27 13:49:35 CET 2011
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.5
diff --git a/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF b/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..227f618
--- /dev/null
+++ b/org.eclipse.jdt.annotation/META-INF/MANIFEST.MF
@@ -0,0 +1,9 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: %bundleName
+Bundle-Localization: bundle
+Bundle-SymbolicName: org.eclipse.jdt.annotation
+Bundle-Version: 1.0.0.qualifier
+Export-Package: org.eclipse.jdt.annotation
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-Vendor: %providerName
diff --git a/org.eclipse.jdt.annotation/about.html b/org.eclipse.jdt.annotation/about.html
new file mode 100644
index 0000000..c258ef5
--- /dev/null
+++ b/org.eclipse.jdt.annotation/about.html
@@ -0,0 +1,28 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
+<title>About</title>
+</head>
+<body lang="EN-US">
+<h2>About This Content</h2>
+ 
+<p>June 5, 2006</p>	
+<h3>License</h3>
+
+<p>The Eclipse Foundation makes available all content in this plug-in (&quot;Content&quot;).  Unless otherwise 
+indicated below, the Content is provided to you under the terms and conditions of the
+Eclipse Public License Version 1.0 (&quot;EPL&quot;).  A copy of the EPL is available 
+at <a href="http://www.eclipse.org/legal/epl-v10.html">http://www.eclipse.org/legal/epl-v10.html</a>.
+For purposes of the EPL, &quot;Program&quot; will mean the Content.</p>
+
+<p>If you did not receive this Content directly from the Eclipse Foundation, the Content is 
+being redistributed by another party (&quot;Redistributor&quot;) and different terms and conditions may
+apply to your use of any object code in the Content.  Check the Redistributor's license that was 
+provided with the Content.  If no such license exists, contact the Redistributor.  Unless otherwise
+indicated below, the terms and conditions of the EPL still apply to any source code in the Content
+and such source code may be obtained at <a href="http://www.eclipse.org/">http://www.eclipse.org</a>.</p>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/org.eclipse.jdt.annotation/build.properties b/org.eclipse.jdt.annotation/build.properties
new file mode 100644
index 0000000..23e73e9
--- /dev/null
+++ b/org.eclipse.jdt.annotation/build.properties
@@ -0,0 +1,15 @@
+###############################################################################
+# Copyright (c) 2011 Stephan Herrmann.
+# All rights reserved. This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License v1.0
+# which accompanies this distribution, and is available at
+# http://www.eclipse.org/legal/epl-v10.html
+#
+# Contributors:
+#     Stephan Herrmann - initial API and implementation
+###############################################################################
+source.. = src/
+bin.includes = META-INF/,\
+               .,\
+               bundle.properties,\
+               src/
diff --git a/org.eclipse.jdt.annotation/bundle.properties b/org.eclipse.jdt.annotation/bundle.properties
new file mode 100644
index 0000000..e4bef55
--- /dev/null
+++ b/org.eclipse.jdt.annotation/bundle.properties
@@ -0,0 +1,12 @@
+###############################################################################
+# Copyright (c) 2011 Stephan Herrmann.
+# All rights reserved. This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License v1.0
+# which accompanies this distribution, and is available at
+# http://www.eclipse.org/legal/epl-v10.html
+#
+# Contributors:
+#     Stephan Herrmann - initial API and implementation
+###############################################################################
+providerName=Eclipse.org
+bundleName=JDT Annotations for Enhanced Null Analysis
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
new file mode 100644
index 0000000..ec5e934
--- /dev/null
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright (c) 2011 Stephan Herrmann.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation 
+ *******************************************************************************/
+package org.eclipse.jdt.annotation;
+
+import static java.lang.annotation.ElementType.*;
+import java.lang.annotation.*;
+ 
+/**
+ * <p>
+ * Qualifier for a type in a method signature or a local variable declaration:
+ * The entity (return value, parameter, local variable) whose type has this
+ * annotation can never have the value <code>null</code> at runtime.
+ * <p>
+ * This has two consequences:
+ * <ol>
+ * <li>Dereferencing the entity is safe, i.e., no <code>NullPointerException</code> can occur at runtime.</li>
+ * <li>An attempt to bind a <code>null</code> value to the entity is a compile time error.</li>
+ * </ol>
+ * For the second case diagnostics issued by the compiler should distinguish three situations:
+ * <ol>
+ * <li>Nullness of the value can be statically determined, the entity is definitely bound from either of:
+ *     <ul><li>the value <code>null</code>, or</li>
+ *         <li>an entity with a {@link Nullable @Nullable} type.</li></ul></li>
+ * <li>Nullness can not definitely be determined, because different code branches yield different results.</li>
+ * <li>Nullness can not be determined, because other program elements are involved for which
+ *     null annotations are lacking.</li>
+ * </ol>
+ * </p>
+ * @version 1.0
+ * @author Stephan Herrmann
+ */
+@Retention(RetentionPolicy.CLASS)
+@Documented
+@Target({METHOD,PARAMETER,LOCAL_VARIABLE})
+public @interface NonNull {
+
+}
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
new file mode 100644
index 0000000..7e15ab7
--- /dev/null
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
@@ -0,0 +1,46 @@
+/*******************************************************************************
+ * Copyright (c) 2011 Stephan Herrmann.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation 
+ *******************************************************************************/
+package org.eclipse.jdt.annotation;
+
+import static java.lang.annotation.ElementType.*;
+import java.lang.annotation.*;
+ 
+/**
+ * <p>
+ * This annotation can be applied to a package, type, method or constructor in order to 
+ * define that all contained entities for which a null annotation is otherwise lacking
+ * should be considered as {@link NonNull @NonNull}.
+ * <dl>
+ * <dt>Canceling a default</dt>
+ * <dd>By using a <code>@NonNullByDefault</code> annotation with the parameter <code>false</code>
+ * a default from any enclosing scope can be canceled for the element being annotated.
+ * <dt>Nested defaults</dt>
+ * <dd>If a <code>@NonNullByDefault</code>
+ * annotation is used within the scope of another <code>@NonNullByDefault</code>
+ * annotation or a project wide default setting the inner most annotation defines the
+ * default applicable at any given position (depending on the parameter {@link #value()}).</dd>
+ * </dl>
+ * Note that for applying an annotation to a package a file by the name
+ * <code>package-info.java</code> is used.
+ * 
+ * @version 1.0
+ * @author Stephan Herrmann
+ */
+@Retention(RetentionPolicy.CLASS)
+@Documented
+@Target({PACKAGE,TYPE,METHOD,CONSTRUCTOR})
+public @interface NonNullByDefault {
+	/**
+	 * When parameterized with <code>false</code> the annotation specifies that the current element
+	 * should not apply any default to un-annotated types.
+	 */
+	boolean value() default true;
+}
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
new file mode 100644
index 0000000..a719c90
--- /dev/null
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2011 Stephan Herrmann.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation 
+ *******************************************************************************/
+package org.eclipse.jdt.annotation;
+
+import static java.lang.annotation.ElementType.*;
+import java.lang.annotation.*;
+ 
+/**
+ * <p>
+ * Qualifier for a type in a method signature or a local variable declaration:
+ * The entity (return value, parameter, local variable) whose type has this
+ * annotation is allowed to have the value <code>null</code> at runtime.
+ * <p>
+ * This has two consequences:
+ * <ul>
+ * <li>Binding a <code>null</code> value to the entity is legal.</li>
+ * <li>Dereferencing the entity is unsafe, i.e., a <code>NullPointerException</code> can occur at runtime.</li>
+ * </ul>
+ * </p>
+ * @version 1.0
+ * @author Stephan Herrmann
+ */
+@Retention(RetentionPolicy.CLASS)
+@Documented
+@Target({METHOD,PARAMETER,LOCAL_VARIABLE})
+public @interface Nullable {
+
+}
\ No newline at end of file
commit 305123b230bcfd1f733969b7cd2c687b75857ff0
Author: Stephan Herrmann <sherrmann>
Date:   Wed Nov 30 22:29:21 2011 +0100

    HEAD - Fixed Bug 186342 [compiler][null] Using annotations for null
    checking

11	1	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
29	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
2651	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
2	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
5	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
4	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
484	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
-	-	org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/example.jar
1	1	org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
301	1	org.eclipse.jdt.core/buildnotes_jdt-core.html
46	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
10	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
9	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
95	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
17	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
20	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
4	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
4	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
18	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
8	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
17	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
13	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
8	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
21	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
30	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
5	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
9	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
26	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
52	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
21	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
104	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
17	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
109	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
9	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
74	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
40	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
98	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
59	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
3	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
4	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
12	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
15	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
99	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
16	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
3	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
205	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
17	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
19	2	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
13	5	org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
5	1	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
224	0	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
index 48667a7..8aa2bf0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/BatchCompilerTest.java
@@ -14,6 +14,7 @@
  *     							bug 185682 - Increment/decrement operators mark local variables as read
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *     							bug 359721 - [options] add command line option for new warning token "resource"
+ *     							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -1799,6 +1800,11 @@ public void test012b(){
 			"		<argument value=\"---OUTPUT_DIR_PLACEHOLDER---\"/>\n" + 
 			"	</command_line>\n" + 
 			"	<options>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nonnull\" value=\"org.eclipse.jdt.annotation.NonNull\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault\" value=\"org.eclipse.jdt.annotation.NonNullByDefault\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault\" value=\"disabled\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nullable\" value=\"org.eclipse.jdt.annotation.Nullable\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.annotation.nullanalysis\" value=\"disabled\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode\" value=\"disabled\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.targetPlatform\" value=\"1.5\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.codegen.unusedLocal\" value=\"optimize out\"/>\n" + 
@@ -1857,14 +1863,18 @@ public void test012b(){
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noEffectAssignment\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral\" value=\"ignore\"/>\n" + 
-			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullReference\" value=\"warning\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo\" value=\"warning\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.nullSpecViolation\" value=\"error\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingMethodWithoutSuperInvocation\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod\" value=\"warning\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.parameterAssignment\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullReference\" value=\"ignore\"/>\n" + 
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation\" value=\"error\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable\" value=\"ignore\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.rawTypeReference\" value=\"warning\"/>\n" +
+			"		<option key=\"org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation\" value=\"warning\"/>\n" +
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.redundantNullCheck\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments\" value=\"ignore\"/>\n" + 
 			"		<option key=\"org.eclipse.jdt.core.compiler.problem.redundantSuperinterface\" value=\"ignore\"/>\n" + 
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
index 311ded9..95fa1b1 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/CompilerInvocationTests.java
@@ -11,6 +11,7 @@
  *     Stephan Herrmann  - Contributions for 
  *     							bug 236385: [compiler] Warn for potential programming problem if an object is created but not used
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *     							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -380,6 +381,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("CannotDefineStaticInitializerInLocalType", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("CannotExtendEnum", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("CannotHideAnInstanceMethodWithAStaticMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("CannotImplementIncompatibleNullness", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("CannotImportPackage", new ProblemAttributes(CategorizedProblem.CAT_IMPORT));
 		expectedProblemAttributes.put("CannotInferElidedTypes", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("CannotInvokeSuperConstructorInEnum", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -470,8 +472,10 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("HierarchyHasProblems", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalAbstractModifierCombinationForMethod", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("IllegalAccessFromTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("IllegalAnnotationForBaseType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalCast", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalClassLiteralForTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("IllegalDefinitionToNonNullParameter", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("IllegalDimension", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("IllegalEnclosingInstanceSpecification", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalExtendedDimensions", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
@@ -506,6 +510,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("IllegalPrimitiveOrArrayTypeForEnclosingInstance", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalQualifiedEnumConstantLabel", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("IllegalQualifiedParameterizedTypeAllocation", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
+		expectedProblemAttributes.put("IllegalReturnNullityRedefinition", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("IllegalRedefinitionToNonNullParameter", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("IllegalStaticModifierForMemberType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("IllegalTypeVariableSuperReference", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("IllegalUnderscorePosition", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
@@ -690,6 +696,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
+		expectedProblemAttributes.put("MissingNullAnnotationType", new ProblemAttributes(CategorizedProblem.CAT_BUILDPATH));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
 		expectedProblemAttributes.put("MissingReturnType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("MissingSemiColon", new ProblemAttributes(CategorizedProblem.CAT_SYNTAX));
@@ -745,6 +752,8 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("PackageCollidesWithType", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("PackageIsNotExpectedPackage", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("ParameterAssignment", new ProblemAttributes(CategorizedProblem.CAT_CODE_STYLE));
+		expectedProblemAttributes.put("ParameterLackingNonNullAnnotation", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("ParameterLackingNullableAnnotation", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ParameterMismatch", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
 		expectedProblemAttributes.put("ParameterizedConstructorArgumentTypeMismatch", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ParameterizedMethodArgumentTypeMismatch", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
@@ -771,6 +780,7 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseableAtExit", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("PotentialNullMessageSendReference", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("RawTypeReference", new ProblemAttributes(CategorizedProblem.CAT_UNCHECKED_RAW));
@@ -779,10 +789,15 @@ public void test011_problem_categories() {
 		expectedProblemAttributes.put("RedefinedLocal", new ProblemAttributes(CategorizedProblem.CAT_INTERNAL));
 		expectedProblemAttributes.put("RedundantSpecificationOfTypeArguments", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("RedundantSuperinterface", new ProblemAttributes(CategorizedProblem.CAT_UNNECESSARY_CODE));
 		expectedProblemAttributes.put("ReferenceToForwardField", new ProblemAttributes(CategorizedProblem.CAT_MEMBER));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM));
 		expectedProblemAttributes.put("ReferenceToForwardTypeVariable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ResourceHasToImplementAutoCloseable", new ProblemAttributes(CategorizedProblem.CAT_TYPE));
 		expectedProblemAttributes.put("ReturnTypeAmbiguous", DEPRECATED);
@@ -1057,6 +1072,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("CannotExtendEnum", SKIP);
 		expectedProblemAttributes.put("CannotHideAnInstanceMethodWithAStaticMethod", SKIP);
 		expectedProblemAttributes.put("CannotImportPackage", SKIP);
+		expectedProblemAttributes.put("CannotImplementIncompatibleNullness", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("CannotInferElidedTypes", SKIP);
 		expectedProblemAttributes.put("CannotInvokeSuperConstructorInEnum", SKIP);
 		expectedProblemAttributes.put("CannotOverrideAStaticMethodWithAnInstanceMethod", SKIP);
@@ -1146,8 +1162,10 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("HierarchyHasProblems", SKIP);
 		expectedProblemAttributes.put("IllegalAbstractModifierCombinationForMethod", SKIP);
 		expectedProblemAttributes.put("IllegalAccessFromTypeVariable", SKIP);
+		expectedProblemAttributes.put("IllegalAnnotationForBaseType", SKIP);
 		expectedProblemAttributes.put("IllegalCast", SKIP);
 		expectedProblemAttributes.put("IllegalClassLiteralForTypeVariable", SKIP);
+		expectedProblemAttributes.put("IllegalDefinitionToNonNullParameter", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("IllegalDimension", SKIP);
 		expectedProblemAttributes.put("IllegalEnclosingInstanceSpecification", SKIP);
 		expectedProblemAttributes.put("IllegalExtendedDimensions", SKIP);
@@ -1182,6 +1200,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("IllegalPrimitiveOrArrayTypeForEnclosingInstance", SKIP);
 		expectedProblemAttributes.put("IllegalQualifiedEnumConstantLabel", SKIP);
 		expectedProblemAttributes.put("IllegalQualifiedParameterizedTypeAllocation", SKIP);
+		expectedProblemAttributes.put("IllegalRedefinitionToNonNullParameter", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("IllegalReturnNullityRedefinition", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("IllegalStaticModifierForMemberType", SKIP);
 		expectedProblemAttributes.put("IllegalTypeVariableSuperReference", SKIP);
 		expectedProblemAttributes.put("IllegalUnderscorePosition", SKIP);
@@ -1365,6 +1385,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("MissingEnclosingInstance", SKIP);
 		expectedProblemAttributes.put("MissingEnclosingInstanceForConstructorCall", SKIP);
 		expectedProblemAttributes.put("MissingEnumConstantCase", new ProblemAttributes(JavaCore.COMPILER_PB_INCOMPLETE_ENUM_SWITCH));
+		expectedProblemAttributes.put("MissingNullAnnotationType", SKIP);
 		expectedProblemAttributes.put("MissingOverrideAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
 		expectedProblemAttributes.put("MissingOverrideAnnotationForInterfaceMethodImplementation", new ProblemAttributes(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION));
 		expectedProblemAttributes.put("MissingReturnType", SKIP);
@@ -1421,6 +1442,8 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("PackageCollidesWithType", SKIP);
 		expectedProblemAttributes.put("PackageIsNotExpectedPackage", SKIP);
 		expectedProblemAttributes.put("ParameterAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_PARAMETER_ASSIGNMENT));
+		expectedProblemAttributes.put("ParameterLackingNonNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("ParameterLackingNullableAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
 		expectedProblemAttributes.put("ParameterMismatch", SKIP);
 		expectedProblemAttributes.put("ParameterizedConstructorArgumentTypeMismatch", SKIP);
 		expectedProblemAttributes.put("ParameterizedMethodArgumentTypeMismatch", SKIP);
@@ -1447,6 +1470,7 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseable", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE));
 		expectedProblemAttributes.put("PotentiallyUnclosedCloseableAtExit", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE));
 		expectedProblemAttributes.put("PotentialNullLocalVariableReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
+		expectedProblemAttributes.put("PotentialNullMessageSendReference", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE));
 		expectedProblemAttributes.put("PublicClassMustMatchFileName", SKIP);
 		expectedProblemAttributes.put("RawMemberTypeCannotBeParameterized", SKIP);
 		expectedProblemAttributes.put("RawTypeReference", new ProblemAttributes(JavaCore.COMPILER_PB_RAW_TYPE_REFERENCE));
@@ -1455,11 +1479,16 @@ public void test012_compiler_problems_tuning() {
 		expectedProblemAttributes.put("RedefinedLocal", SKIP);
 		expectedProblemAttributes.put("RedundantSpecificationOfTypeArguments", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_TYPE_ARGUMENTS));
 		expectedProblemAttributes.put("RedundantLocalVariableNullAssignment", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("RedundantNullAnnotation", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION));
 		expectedProblemAttributes.put("RedundantNullCheckOnNonNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
+		expectedProblemAttributes.put("RedundantNullCheckOnNonNullMessageSend", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantNullCheckOnNullLocalVariable", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK));
 		expectedProblemAttributes.put("RedundantSuperinterface", new ProblemAttributes(JavaCore.COMPILER_PB_REDUNDANT_SUPERINTERFACE));
 		expectedProblemAttributes.put("ReferenceToForwardField", SKIP);
 		expectedProblemAttributes.put("ReferenceToForwardTypeVariable", SKIP);
+		expectedProblemAttributes.put("RequiredNonNullButProvidedNull", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedPotentialNull", new ProblemAttributes(JavaCore.COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION));
+		expectedProblemAttributes.put("RequiredNonNullButProvidedUnknown", new ProblemAttributes(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO));
 		expectedProblemAttributes.put("ResourceHasToImplementAutoCloseable", SKIP);
 		expectedProblemAttributes.put("ReturnTypeAmbiguous", SKIP);
 		expectedProblemAttributes.put("ReturnTypeCannotBeVoidArray", SKIP);
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
new file mode 100644
index 0000000..6c6bd01
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -0,0 +1,2651 @@
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 GK Software AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+
+import java.io.File;
+import java.util.Map;
+
+import junit.framework.Test;
+
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.jdt.core.JavaCore;
+
+// see bug 186342 - [compiler][null] Using annotations for null checking
+public class NullAnnotationTest extends AbstractComparableTest {
+
+// class libraries including our default null annotation types:
+String[] LIBS;
+
+// names and content of custom annotations used in a few tests:
+private static final String CUSTOM_NONNULL_NAME = "org/foo/NonNull.java";
+private static final String CUSTOM_NONNULL_CONTENT =
+	"package org.foo;\n" +
+	"import static java.lang.annotation.ElementType.*;\n" +
+	"import java.lang.annotation.*;\n" +
+	"@Retention(RetentionPolicy.CLASS)\n" +
+	"@Target({METHOD,PARAMETER,LOCAL_VARIABLE})\n" +
+	"public @interface NonNull {\n" +
+	"}\n";
+private static final String CUSTOM_NULLABLE_NAME = "org/foo/Nullable.java";
+private static final String CUSTOM_NULLABLE_CONTENT = "package org.foo;\n" +
+	"import static java.lang.annotation.ElementType.*;\n" +
+	"import java.lang.annotation.*;\n" +
+	"@Retention(RetentionPolicy.CLASS)\n" +
+	"@Target({METHOD,PARAMETER,LOCAL_VARIABLE})\n" +
+	"public @interface Nullable {\n" +
+	"}\n";
+
+public NullAnnotationTest(String name) {
+	super(name);
+}
+
+// Static initializer to specify tests subset using TESTS_* static variables
+// All specified tests which do not belong to the class are skipped...
+static {
+//		TESTS_NAMES = new String[] { "test_illegal_annotation_007" };
+//		TESTS_NUMBERS = new int[] { 561 };
+//		TESTS_RANGE = new int[] { 1, 2049 };
+}
+
+public static Test suite() {
+	return buildComparableTestSuite(testClass());
+}
+
+public static Class testClass() {
+	return NullAnnotationTest.class;
+}
+
+protected void setUp() throws Exception {
+	super.setUp();
+	if (this.LIBS == null) {
+		String[] defaultLibs = getDefaultClassPaths();
+		int len = defaultLibs.length;
+		this.LIBS = new String[len+1];
+		System.arraycopy(defaultLibs, 0, this.LIBS, 0, len);
+		File bundleFile = FileLocator.getBundleFile(Platform.getBundle("org.eclipse.jdt.annotation"));
+		if (bundleFile.isDirectory())
+			this.LIBS[len] = bundleFile.getPath()+"/bin";
+		else
+			this.LIBS[len] = bundleFile.getPath();
+	}
+}
+// Conditionally augment problem detection settings
+static boolean setNullRelatedOptions = true;
+protected Map getCompilerOptions() {
+    Map defaultOptions = super.getCompilerOptions();
+    if (setNullRelatedOptions) {
+    	defaultOptions.put(JavaCore.COMPILER_PB_NULL_REFERENCE, JavaCore.ERROR);
+	    defaultOptions.put(JavaCore.COMPILER_PB_POTENTIAL_NULL_REFERENCE, JavaCore.ERROR);
+	    defaultOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
+		defaultOptions.put(JavaCore.COMPILER_PB_INCLUDE_ASSERTS_IN_NULL_ANALYSIS, JavaCore.ENABLED);
+
+		defaultOptions.put(JavaCore.COMPILER_PB_MISSING_OVERRIDE_ANNOTATION_FOR_INTERFACE_METHOD_IMPLEMENTATION, JavaCore.DISABLED);
+
+		// enable null annotations:
+		defaultOptions.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+		// leave other new options at these defaults:
+//		defaultOptions.put(CompilerOptions.OPTION_ReportNullContractViolation, JavaCore.ERROR);
+//		defaultOptions.put(CompilerOptions.OPTION_ReportPotentialNullContractViolation, JavaCore.ERROR);
+//		defaultOptions.put(CompilerOptions.OPTION_ReportNullContractInsufficientInfo, CompilerOptions.WARNING);
+
+//		defaultOptions.put(CompilerOptions.OPTION_NullableAnnotationName, "org.eclipse.jdt.annotation.Nullable");
+//		defaultOptions.put(CompilerOptions.OPTION_NonNullAnnotationName, "org.eclipse.jdt.annotation.NonNull");
+    }
+    return defaultOptions;
+}
+void runNegativeTestWithLibs(String[] testFiles, String expectedErrorLog) {
+	runNegativeTest(
+			testFiles,
+			expectedErrorLog,
+			this.LIBS,
+			false /*shouldFlush*/);
+}
+void runNegativeTestWithLibs(boolean shouldFlushOutputDirectory, String[] testFiles, Map customOptions, String expectedErrorLog) {
+	runNegativeTest(
+			shouldFlushOutputDirectory,
+			testFiles,
+			this.LIBS,
+			customOptions,
+			expectedErrorLog,
+			// runtime options
+		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+void runNegativeTestWithLibs(String[] testFiles, Map customOptions, String expectedErrorLog) {
+	runNegativeTestWithLibs(false /* flush output directory */,	testFiles, customOptions, expectedErrorLog);
+}
+void runConformTestWithLibs(String[] testFiles, Map customOptions, String expectedCompilerLog) {
+	runConformTestWithLibs(false /* flush output directory */, testFiles, customOptions, expectedCompilerLog);
+}
+void runConformTestWithLibs(boolean shouldFlushOutputDirectory, String[] testFiles, Map customOptions, String expectedCompilerLog) {
+	runConformTest(
+			shouldFlushOutputDirectory,
+			testFiles,
+			this.LIBS,
+			customOptions,
+			expectedCompilerLog,
+			"",/* expected output */
+			"",/* expected error */
+		    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+void runConformTest(String[] testFiles, Map customOptions, String expectedOutputString) {
+	runConformTest(
+			testFiles,
+			expectedOutputString,
+			null /*classLibraries*/,
+			true /*shouldFlushOutputDirectory*/,
+			null /*vmArguments*/,
+			customOptions,
+			null /*customRequestor*/);
+
+}
+// a nullable argument is dereferenced without a check
+public void test_nullable_paramter_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    void foo(@Nullable Object o) {\n" +
+			  "        System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	System.out.print(o.toString());\n" +
+		"	                 ^\n" +
+		"Potential null pointer access: The variable o may be null at this location\n" +
+		"----------\n",
+		this.LIBS,
+		true /* shouldFlush*/);
+}
+
+// a null value is passed to a nullable argument
+public void test_nullable_paramter_002() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    void foo(@Nullable Object o) {\n" +
+			  "        // nop\n" +
+			  "    }\n" +
+			  "    void bar() {\n" +
+			  "        foo(null);\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "",
+	    this.LIBS,
+	    false/*shouldFlush*/,
+	    null/*vmArgs*/);
+}
+
+// a non-null argument is checked for null
+public void test_nonnull_parameter_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    void foo(@NonNull Object o) {\n" +
+			  "        if (o != null)\n" +
+			  "              System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	if (o != null)\n" +
+		"	    ^\n" +
+		"Redundant null check: The variable o cannot be null at this location\n" +
+		"----------\n",
+		this.LIBS,
+		true /* shouldFlush*/);
+}
+// a non-null argument is dereferenced without a check
+public void test_nonnull_parameter_002() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    void foo(@NonNull Object o) {\n" +
+			  "        System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "    public static void main(String... args) {\n" +
+			  "        new X().foo(\"OK\");\n" +
+			  "    }\n" +
+			  "}\n"},
+	    "OK",
+	    this.LIBS,
+	    false/*shouldFlush*/,
+	    null/*vmArgs*/);
+}
+// passing null to nonnull parameter - many fields in enclosing class
+public void test_nonnull_parameter_003() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    int i00, i01, i02, i03, i04, i05, i06, i07, i08, i09;" +
+			  "    int i10, i11, i12, i13, i14, i15, i16, i17, i18, i19;" +
+			  "    int i20, i21, i22, i23, i24, i25, i26, i27, i28, i29;" +
+			  "    int i30, i31, i32, i33, i34, i35, i36, i37, i38, i39;" +
+			  "    int i40, i41, i42, i43, i44, i45, i46, i47, i48, i49;" +
+			  "    int i50, i51, i52, i53, i54, i55, i56, i57, i58, i59;" +
+			  "    int i60, i61, i62, i63, i64, i65, i66, i67, i68, i69;" +
+			  "    void foo(@NonNull Object o) {\n" +
+			  "        System.out.print(o.toString());\n" +
+			  "    }\n" +
+			  "    void bar() {\n" +
+			  "        foo(null);\n" +
+			  "    }\n" +
+			  "}\n"},
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	foo(null);\n" +
+		"	    ^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n",
+		this.LIBS,
+		true /* shouldFlush*/);
+}
+// passing potential null to nonnull parameter - target method is consumed from .class
+public void test_nonnull_parameter_004() {
+	runConformTestWithLibs(
+			new String[] {
+				"Lib.java",
+					"import org.eclipse.jdt.annotation.*;\n" +
+				"public class Lib {\n" +
+				"    void setObject(@NonNull Object o) { }\n" +
+				"}\n"
+			},
+			null /*customOptions*/,
+			"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void bar(Lib l, boolean b) {\n" +
+			  "        Object o = null;\n" +
+			  "        if (b) o = new Object();\n" +
+			  "        l.setObject(o);\n" +
+			  "    }\n" +
+			  "}\n"},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 5)\n" +
+		"	l.setObject(o);\n" +
+		"	            ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n");
+}
+// passing unknown value to nonnull parameter  - target method is consumed from .class
+public void test_nonnull_parameter_005() {
+	runConformTestWithLibs(
+			new String[] {
+				"Lib.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class Lib {\n" +
+				"    void setObject(@NonNull Object o) { }\n" +
+				"}\n"
+			},
+			null /*customOptions*/,
+			"");
+	runConformTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			  "public class X {\n" +
+			  "    void bar(Lib l, Object o) {\n" +
+			  "        l.setObject(o);\n" +
+			  "    }\n" +
+			  "}\n"},
+		null /* options */,
+		"----------\n" +
+		"1. WARNING in X.java (at line 3)\n" +
+		"	l.setObject(o);\n" +
+		"	            ^\n" +
+		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"----------\n");
+}
+// a ternary non-null expression is passed to a nonnull parameter
+public void test_nonnull_parameter_006() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    	void m1(@NonNull String a) {}\n" +
+			  "		void m2(@Nullable String b) {\n" +
+			  "			m1(b == null ? \"\" : b);\n" +
+			  "		}\n" +
+			  "}\n"},
+		customOptions,
+		""  /* compiler output */);
+}
+// nullable value passed to a non-null parameter in a super-call
+public void test_nonnull_parameter_007() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"XSub.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class XSub extends XSuper {\n" +
+			  "    	XSub(@Nullable String b) {\n" +
+			  "			super(b);\n" +
+			  "		}\n" +
+			  "}\n",
+			"XSuper.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class XSuper {\n" +
+			  "    	XSuper(@NonNull String b) {\n" +
+			  "		}\n" +
+			  "}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in XSub.java (at line 4)\n" +
+		"	super(b);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n");
+}
+// a nullable value is passed to a non-null parameter in an allocation expression
+public void test_nonnull_parameter_008() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    	X(@NonNull String a) {}\n" +
+			  "		static X create(@Nullable String b) {\n" +
+			  "			return new X(b);\n" +
+			  "		}\n" +
+			  "}\n"},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 5)\n" +
+		"	return new X(b);\n" +
+		"	             ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n"  /* compiler output */);
+}
+// a nullable value is passed to a non-null parameter in a qualified allocation expression
+public void test_nonnull_parameter_009() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    class Local {\n" +
+			  "    	   Local(@NonNull String a) {}\n" +
+			  "    }\n" +
+			  "	   Local create(@Nullable String b) {\n" +
+			  "	       return this.new Local(b);\n" +
+			  "    }\n" +
+			  "}\n"},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	return this.new Local(b);\n" +
+		"	                      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n"  /* compiler output */);
+}
+// null is passed to a non-null parameter in a qualified allocation expression, across CUs
+public void test_nonnull_parameter_010() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"ContainingInner2.java",
+			"public class ContainingInner2 {\n" + 
+			"    public ContainingInner2 (@org.eclipse.jdt.annotation.NonNull Object o) {\n" + 
+			"    }\n" + 
+			"    public class Inner {\n" + 
+			"        public Inner (@org.eclipse.jdt.annotation.NonNull Object o) {\n" + 
+			"        }\n" + 
+			"    }\n" + 
+			"}\n",
+			"X.java",
+			"public class X {\n" +
+			"	 void create() {\n" +
+			"          ContainingInner2 container = new ContainingInner2(null);\n" +
+			"	       ContainingInner2.Inner inner = container.new Inner(null);\n" +
+			"    }\n" +
+		  	"}\n"},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	ContainingInner2 container = new ContainingInner2(null);\n" + 
+		"	                                                  ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 4)\n" + 
+		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
+		"	                                                   ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n"  /* compiler output */);
+}
+// null is passed to a non-null parameter in a qualified allocation expression, target class read from .class
+public void test_nonnull_parameter_011() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+			new String[] {
+				"ContainingInner2.java",
+				"public class ContainingInner2 {\n" + 
+				"    public ContainingInner2 (@org.eclipse.jdt.annotation.NonNull Object o) {\n" + 
+				"    }\n" + 
+				"    public class Inner {\n" + 
+				"        public Inner (@org.eclipse.jdt.annotation.NonNull Object o) {\n" + 
+				"        }\n" + 
+				"    }\n" + 
+				"}\n",
+			},
+			null /*customOptions*/,
+			"");
+	runNegativeTestWithLibs(
+		false, // flush directory
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void create() {\n" +
+			"          ContainingInner2 container = new ContainingInner2(null);\n" +
+			"	       ContainingInner2.Inner inner = container.new Inner(null);\n" +
+			"    }\n" +
+		  	"}\n"},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	ContainingInner2 container = new ContainingInner2(null);\n" + 
+		"	                                                  ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 4)\n" + 
+		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
+		"	                                                   ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n"  /* compiler output */);
+}
+// null is passed to a non-null parameter in a qualified allocation expression, generic constructor, target class read from .class
+public void test_nonnull_parameter_012() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+			new String[] {
+				"ContainingInner2.java",
+				"public class ContainingInner2 {\n" + 
+				"    public ContainingInner2 (@org.eclipse.jdt.annotation.NonNull Object o) {\n" + 
+				"    }\n" + 
+				"    public class Inner {\n" + 
+				"        public <T> Inner (@org.eclipse.jdt.annotation.NonNull T o) {\n" + 
+				"        }\n" + 
+				"    }\n" + 
+				"}\n",
+			},
+			null /*customOptions*/,
+			"");
+	runNegativeTestWithLibs(
+		false, // flush directory
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void create() {\n" +
+			"          ContainingInner2 container = new ContainingInner2(null);\n" +
+			"	       ContainingInner2.Inner inner = container.new Inner(null);\n" +
+			"    }\n" +
+		  	"}\n"},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	ContainingInner2 container = new ContainingInner2(null);\n" + 
+		"	                                                  ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 4)\n" + 
+		"	ContainingInner2.Inner inner = container.new Inner(null);\n" + 
+		"	                                                   ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n"  /* compiler output */);
+}
+// a method of a local class has a non-null parameter, client passes null
+public void test_nonnull_parameter_013() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"B.java",
+			"class B {\n" +
+			"    void bar () {\n" +
+			"        class Local {\n" +
+			"            void callMe(@org.eclipse.jdt.annotation.NonNull Object o){\n" +
+			"            }\n" +
+			"        }\n" +
+			"        Local l = new Local();\n" +
+			"        l.callMe(null);\n" +
+			"    } \n" +
+			"}\n"
+		},
+		"----------\n" + 
+		"1. ERROR in B.java (at line 8)\n" + 
+		"	l.callMe(null);\n" + 
+		"	         ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// assigning potential null to a nonnull local variable
+public void test_nonnull_local_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			  "import org.eclipse.jdt.annotation.*;\n" +
+			  "public class X {\n" +
+			  "    void foo(boolean b, Object p) {\n" +
+			  "        @NonNull Object o1 = b ? null : new Object();\n" +
+			  "        @NonNull String o2 = \"\";\n" +
+			  "        o2 = null;\n" +
+			  "        @NonNull Object o3 = p;\n" +
+			  "    }\n" +
+			  "}\n"},
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	@NonNull Object o1 = b ? null : new Object();\n" +
+		"	                     ^^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 6)\n" +
+		"	o2 = null;\n" +
+		"	     ^^^^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value is null\n" +
+		"----------\n" +
+		"3. WARNING in X.java (at line 7)\n" +
+		"	@NonNull Object o3 = p;\n" +
+		"	                     ^\n" +
+		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"----------\n",
+		this.LIBS,
+		true /* shouldFlush*/);
+}
+
+// a method tries to tighten the type specification, super declares parameter o as @Nullable
+// other parameters: s is redefined from not constrained to @Nullable which is OK
+//                   third is redefined from not constrained to @NonNull which is bad, too
+public void test_parameter_specification_inheritance_001() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    void foo(String s, @Nullable Object o, Object third) { }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    void foo(@Nullable String s, @NonNull Object o, @NonNull Object third) { System.out.print(o.toString()); }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	void foo(@Nullable String s, @NonNull Object o, @NonNull Object third) { System.out.print(o.toString()); }\n" +
+		"	                             ^^^^^^^^^^^^^^^\n" +
+		"Illegal redefinition of parameter o, inherited method from Lib declares this parameter as @Nullable\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 4)\n" +
+		"	void foo(@Nullable String s, @NonNull Object o, @NonNull Object third) { System.out.print(o.toString()); }\n" +
+		"	                                                ^^^^^^^^^^^^^^^\n" +
+		"Illegal redefinition of parameter third, inherited method from Lib does not constrain this parameter\n" +
+		"----------\n");
+}
+// a method body fails to redeclare the inherited null annotation, super declares parameter as @Nullable
+public void test_parameter_specification_inheritance_002() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    void foo(@Nullable Object o) { }\n" +
+			"}\n"
+		},
+		"",
+	    this.LIBS,
+	    false/*shouldFlush*/,
+	    null/*vmArgs*/);
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    void foo(Object o) {\n" +
+			"        System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	void foo(Object o) {\n" +
+		"	         ^^^^^^\n" +
+		"Missing nullable annotation: inherited method from Lib declares this parameter as @Nullable\n" +
+		"----------\n");
+}
+// a method relaxes the parameter null specification, super interface declares parameter o as @NonNull
+// other (first) parameter just repeats the inherited @NonNull
+public void test_parameter_specification_inheritance_003() {
+	runConformTest(
+		new String[] {
+			"IX.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IX {\n" +
+			"    void foo(@NonNull String s, @NonNull Object o);\n" +
+			"}\n",
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X implements IX {\n" +
+			"    public void foo(@NonNull String s, @Nullable Object o) { ; }\n" +
+			"    void bar() { foo(\"OK\", null); }\n" +
+			"}\n"
+		},
+		"",
+	    this.LIBS,
+	    false/*shouldFlush*/,
+	    null/*vmArgs*/);
+}
+// a method adds a @NonNull annotation, super interface has no null annotation
+// changing other from unconstrained to @Nullable is OK
+public void test_parameter_specification_inheritance_004() {
+	runConformTest(
+		new String[] {
+			"IX.java",
+			"public interface IX {\n" +
+			"    void foo(Object o, Object other);\n" +
+			"}\n"
+		});
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X implements IX {\n" +
+			"    public void foo(@NonNull Object o, @Nullable Object other) { System.out.print(o.toString()); }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	public void foo(@NonNull Object o, @Nullable Object other) { System.out.print(o.toString()); }\n" +
+		"	                ^^^^^^^^^^^^^^^\n" +
+		"Illegal redefinition of parameter o, inherited method from IX does not constrain this parameter\n" +
+		"----------\n");
+}
+// a method tries to relax the null contract, super declares @NonNull return
+public void test_parameter_specification_inheritance_005() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, //dont' flush
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	@Nullable Object getObject() { return null; }\n" +
+		"	^^^^^^^^^^^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from Lib.getObject()\n" +
+		"----------\n");
+}
+
+// super has no constraint for return, sub method confirms the null contract as @Nullable
+public void test_parameter_specification_inheritance_006() {
+	runConformTest(
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return null; }\n" +
+			"}\n"
+		});
+	runConformTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+// a method body violates the inherited null specification, super declares @NonNull return, missing redeclaration
+public void test_parameter_specification_inheritance_007() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	Object getObject() { return null; }\n" +
+		"	^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from Lib.getObject()\n" +
+		"----------\n");
+}
+//a method body violates the @NonNull return specification (repeated from super)
+public void test_parameter_specification_inheritance_007a() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X extends Lib {\n" +
+			"    @Override\n" +
+			"    @NonNull Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	@NonNull Object getObject() { return null; }\n" +
+		"	                                     ^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n");
+}
+// a client potentially violates the inherited null specification, super interface declares @NonNull parameter
+public void test_parameter_specification_inheritance_008() {
+	Map options = getCompilerOptions();
+	options.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+			"IX.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IX {\n" +
+			"    void printObject(@NonNull Object o);\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"public class X implements IX {\n" +
+			"    public void printObject(Object o) { System.out.print(o.toString()); }\n" +
+			"}\n",
+			"M.java",
+			"public class M{\n" +
+			"    void foo(IX x, Object o) {\n" +
+			"        x.printObject(o);\n" +
+			"    }\n" +
+			"}\n"
+		},
+		options,
+		"----------\n" +
+		// additional error:
+		"1. ERROR in X.java (at line 2)\n" +
+		"	public void printObject(Object o) { System.out.print(o.toString()); }\n" +
+		"	                        ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from IX declares this parameter as @NonNull\n" +
+		"----------\n" +
+		// main error:
+		"----------\n" +
+		"1. ERROR in M.java (at line 3)\n" +
+		"	x.printObject(o);\n" +
+		"	              ^\n" +
+		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"----------\n");
+}
+// a static method has a more relaxed null contract than a like method in the super class, but no overriding.
+public void test_parameter_specification_inheritance_009() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    @NonNull static Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X extends Lib {\n" +
+			"    @Nullable static Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+}
+// class default is nonnull, method and its super both use the default
+public void test_parameter_specification_inheritance_010() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected String getString(String s) {\n" +
+			"        if (Character.isLowerCase(s.charAt(0)))\n" +
+			"	        return getString(s);\n" +
+			"	     return s;\n" +
+			"    }\n" +
+			"}\n",
+	"p1/Y.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class Y extends X {\n" +
+			"    @Override\n" +
+			"    protected String getString(String s) {\n" +
+			"	     return super.getString(s);\n" +
+			"    }\n" +
+			"}\n",
+		},
+		customOptions,
+		"");
+}
+// class default is nonnull, method and its super both use the default, super-call passes null
+public void test_parameter_specification_inheritance_011() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected String getString(String s) {\n" +
+			"        if (Character.isLowerCase(s.charAt(0)))\n" +
+			"	        return getString(s);\n" +
+			"	     return s;\n" +
+			"    }\n" +
+			"}\n",
+	"p1/Y.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class Y extends X {\n" +
+			"    @Override\n" +
+			"    protected String getString(String s) {\n" +
+			"	     return super.getString(null);\n" +
+			"    }\n" +
+			"}\n",
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p1\\Y.java (at line 7)\n" +
+		"	return super.getString(null);\n" +
+		"	                       ^^^^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value is null\n" +
+		"----------\n");
+}
+// methods from two super types have different null contracts.
+// sub-class merges both using the weakest common contract
+public void test_parameter_specification_inheritance_012() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    public @Nullable String getString(String s1, @Nullable String s2, @NonNull String s3) {\n" +
+			"	     return s1;\n" +
+			"    }\n" +
+			"}\n",
+	"p1/IY.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IY {\n" +
+			"    @NonNull String getString(@NonNull String s1, @NonNull String s2, @Nullable String s3);\n" +
+			"}\n",
+	"p1/Y.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends X implements IY {\n" +
+			"    @Override\n" +
+			"    public @NonNull String getString(@Nullable String s1, @Nullable String s2, @Nullable String s3) {\n" +
+			"	     return \"\";\n" +
+			"    }\n" +
+			"}\n",
+		},
+		customOptions,
+		"");
+}
+// methods from two super types have different null contracts.
+// sub-class overrides this method in non-conforming ways
+public void test_parameter_specification_inheritance_013() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    public @Nullable String getString(String s1, @Nullable String s2, @NonNull String s3) {\n" +
+			"	     return s1;\n" +
+			"    }\n" +
+			"}\n",
+	"p1/IY.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IY {\n" +
+			"    @NonNull String getString(@NonNull String s1, @NonNull String s2, @Nullable String s3);\n" +
+			"}\n",
+	"p1/Y.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends X implements IY {\n" +
+			"    @Override\n" +
+			"    public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
+			"	     return \"\";\n" +
+			"    }\n" +
+			"}\n",
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p1\\Y.java (at line 5)\n" +
+		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
+		"	       ^^^^^^^^^^^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from IY.getString(String, String, String)\n" +
+		"----------\n" +
+		"2. ERROR in p1\\Y.java (at line 5)\n" +
+		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
+		"	                                  ^^^^^^\n" +
+		"Missing non-null annotation: inherited method from IY declares this parameter as @NonNull\n" +
+		"----------\n" +
+		"3. ERROR in p1\\Y.java (at line 5)\n" +
+		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
+		"	                                             ^^^^^^^^^^^^^^^\n" +
+		"Illegal redefinition of parameter s2, inherited method from X declares this parameter as @Nullable\n" +
+		"----------\n" +
+		"4. ERROR in p1\\Y.java (at line 5)\n" +
+		"	public @Nullable String getString(String s1, @NonNull String s2, @NonNull String s3) {\n" +
+		"	                                                                 ^^^^^^^^^^^^^^^\n" +
+		"Illegal redefinition of parameter s3, inherited method from IY declares this parameter as @Nullable\n" +
+		"----------\n");
+}
+// methods from two super types have different null contracts.
+// sub-class does not override, but should to bridge the incompatibility
+public void test_parameter_specification_inheritance_014() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/IY.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public interface IY {\n" +
+			"    public @NonNull String getString1(String s);\n" +
+			"    public @NonNull String getString2(String s);\n" +
+			"    public String getString3(@Nullable String s);\n" +
+			"    public @NonNull String getString4(@Nullable String s);\n" +
+			"    public @NonNull String getString5(@Nullable String s);\n" +
+			"    public @Nullable String getString6(@NonNull String s);\n" +
+			"}\n",
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    public @Nullable String getString1(String s) {\n" + // incomp. return
+			"	     return s;\n" +
+			"    }\n" +
+			"    public String getString2(String s) {\n" +			 // incomp. return
+			"	     return s;\n" +
+			"    }\n" +
+			"    public String getString3(String s) {\n" +			 // incomp. arg
+			"	     return \"\";\n" +
+			"    }\n" +
+			"    public @NonNull String getString4(@Nullable String s) {\n" +
+			"	     return \"\";\n" +
+			"    }\n" +
+			"    public @NonNull String getString5(@NonNull String s) {\n" + // incomp. arg
+			"	     return s;\n" +
+			"    }\n" +
+			"    public @NonNull String getString6(@Nullable String s) {\n" +
+			"	     return \"\";\n" +
+			"    }\n" +
+			"}\n",
+	"p1/Y.java",
+			"package p1;\n" +
+			"public class Y extends X implements IY {\n" +
+			"}\n",
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p1\\Y.java (at line 2)\n" +
+		"	public class Y extends X implements IY {\n" +
+		"	             ^\n" +
+		"The method getString1(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
+		"----------\n" +
+		"2. ERROR in p1\\Y.java (at line 2)\n" +
+		"	public class Y extends X implements IY {\n" +
+		"	             ^\n" +
+		"The method getString2(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
+		"----------\n" +
+		"3. ERROR in p1\\Y.java (at line 2)\n" +
+		"	public class Y extends X implements IY {\n" +
+		"	             ^\n" +
+		"The method getString5(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
+		"----------\n" +
+		"4. ERROR in p1\\Y.java (at line 2)\n" +
+		"	public class Y extends X implements IY {\n" +
+		"	             ^\n" +
+		"The method getString3(String) from X cannot implement the corresponding method from IY due to incompatible nullness constraints\n" +
+		"----------\n");
+}
+// a nullable return value is dereferenced without a check
+public void test_nullable_return_001() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"    void foo() {\n" +
+			"        Object o = getObject();\n" +
+			"        System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 6)\n" +
+		"	System.out.print(o.toString());\n" +
+		"	                 ^\n" +
+		"Potential null pointer access: The variable o may be null at this location\n" +
+		"----------\n");
+}
+// a nullable return value is dereferenced without a check, method is read from .class file
+public void test_nullable_return_002() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    @Nullable Object getObject() { return null; }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(Lib l) {\n" +
+			"        Object o = l.getObject();\n" +
+			"        System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	System.out.print(o.toString());\n" +
+		"	                 ^\n" +
+		"Potential null pointer access: The variable o may be null at this location\n" +
+		"----------\n");
+}
+// a non-null return value is checked for null, method is read from .class file
+public void test_nonnull_return_001() {
+	runConformTestWithLibs(
+		new String[] {
+			"Lib.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"");
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    void foo(Lib l) {\n" +
+			"        Object o = l.getObject();\n" +
+			"        if (o != null)\n" +
+			"            System.out.print(o.toString());\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	if (o != null)\n" +
+		"	    ^\n" +
+		"Redundant null check: The variable o cannot be null at this location\n" +
+		"----------\n");
+}
+// a non-null method returns null
+public void test_nonnull_return_003() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(boolean b) {\n" +
+			"        if (b)\n" +
+			"            return null;\n" + // definite specification violation despite enclosing "if"
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 5)\n" +
+		"	return null;\n" +
+		"	       ^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n");
+}
+// a non-null method potentially returns null
+public void test_nonnull_return_004() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(@Nullable Object o) {\n" +
+			"        return o;\n" + // 'o' is only potentially null
+			"    }\n" +
+			"}\n"
+		},
+		null /*customOptions*/,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	return o;\n" +
+		"	       ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n");
+}
+// a non-null method returns its non-null argument
+public void test_nonnull_return_005() {
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(@NonNull Object o) {\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null, // options
+		"");
+}
+//a non-null method has insufficient nullness info for its return value
+public void test_nonnull_return_006() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(Object o) {\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. WARNING in X.java (at line 4)\n" +
+		"	return o;\n" +
+		"	       ^\n" +
+		"Potential type mismatch: required \'@NonNull Object\' but nullness of the provided value is unknown\n" +
+		"----------\n");
+}
+// a result from a nullable method is directly dereferenced
+public void test_nonnull_return_007() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object getObject() {\n" +
+			"        return null;\n" +
+			"    }\n" +
+			"    void test() {\n" +
+			"        getObject().toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	getObject().toString();\n" +
+		"	^^^^^^^^^^^\n" +
+		"Potential null pointer access: The method getObject() may return null\n" +
+		"----------\n");
+}
+// a result from a nonnull method is directly checked for null: redundant
+public void test_nonnull_return_008() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject() {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"    void test() {\n" +
+			"        if (getObject() == null)\n" +
+			"		     throw new RuntimeException();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	if (getObject() == null)\n" +
+		"	    ^^^^^^^^^^^\n" +
+		"Redundant null check: The method getObject() cannot return null\n" +
+		"----------\n");
+}
+// a result from a nonnull method is directly checked for null (from local): redundant
+public void test_nonnull_return_009() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject() {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"    void test() {\n" +
+			"        Object left = null;\n" +
+			"        if (left != getObject())\n" +
+			"		     throw new RuntimeException();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 8)\n" +
+		"	if (left != getObject())\n" +
+		"	    ^^^^\n" +
+		"Redundant null check: The variable left can only be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 8)\n" +
+		"	if (left != getObject())\n" +
+		"	            ^^^^^^^^^^^\n" +
+		"Redundant null check: The method getObject() cannot return null\n" +
+		"----------\n");
+}
+// a result from a nonnull method is directly checked for null (from local): not redundant due to loop
+public void test_nonnull_return_009a() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject() {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"    void test() {\n" +
+			"        Object left = null;\n" +
+			"        for (int i=0; i<3; i++) {\n" +
+			"            if (left != getObject())\n" +
+			"	    	     throw new RuntimeException();\n" +
+			"            left = new Object();\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"");
+}
+// a result from a nonnull method is directly checked for null (from local): redundant despite loop
+// disabled because only one of two desirable errors is raised
+// need to integrate @NonNull expressions (MessageSend and more) into deferred analysis by FlowContext
+public void _test_nonnull_return_009b() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject() {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"    void test() {\n" +
+			"        Object left = null;\n" +
+			"        for (int i=0; i<3; i++) {\n" +
+			"            if (left != getObject())\n" +
+			"	    	     throw new RuntimeException();\n" +
+			"            // left remains null\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 9)\n" +
+		"	if (left != getObject())\n" +
+		"	    ^^^^\n" +
+		"Redundant null check: The variable left can only be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 9)\n" +
+		"	if (left != getObject())\n" +
+		"	            ^^^^^^^^^^^\n" +
+		"Redundant null check: The method getObject() cannot return null\n" +
+		"----------\n");
+}
+// a result from a nullable method is assigned and checked for null (from local): not redundant
+// see also Bug 336428 - [compiler][null] bogus warning "redundant null check" in condition of do {} while() loop
+public void test_nonnull_return_010() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_CHECK, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable X getX() {\n" +
+			"        return new X();\n" +
+			"    }\n" +
+			"    void test() {\n" +
+			"        X left = this;\n" +
+			"        do {\n" +
+			"            if (left == null) \n" +
+			"	   	         throw new RuntimeException();\n" +
+			"        } while ((left = left.getX()) != null);\n" + // no warning/error here!
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 9)\n" +
+		"	if (left == null) \n" +
+		"	    ^^^^\n" +
+		"Null comparison always yields false: The variable left cannot be null at this location\n" +
+		"----------\n");
+}
+// a non-null method returns a checked-for null value, but that branch is dead code
+public void test_nonnull_return_011() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    Object getObject(Object dubious) {\n" +
+			"        if (dubious == null)\n" + // redundant
+			"            return dubious;\n" + // definitely null, but not reported inside dead code
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 5)\n" +
+		"	if (dubious == null)\n" +
+		"	    ^^^^^^^\n" +
+		"Null comparison always yields false: The variable dubious cannot be null at this location\n" +
+		"----------\n" +
+		"2. WARNING in X.java (at line 6)\n" +
+		"	return dubious;\n" +
+		"	^^^^^^^^^^^^^^^\n" +
+		"Dead code\n" +
+		"----------\n");
+}
+// a non-null method returns a definite null from a conditional expression
+// requires the fix for Bug 354554 - [null] conditional with redundant condition yields weak error message
+// TODO(SH): ENABLE!
+public void _test_nonnull_return_012() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    Object getObject(Object dubious) {\n" +
+			"        return dubious == null ? dubious : null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 5)\n" +
+		"	return dubious == null ? dubious : null;\n" +
+		"	       ^^^^^^^\n" +
+		"Null comparison always yields false: The variable dubious cannot be null at this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 5)\n" +
+		"	return dubious == null ? dubious : null;\n" +
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n");
+}
+// don't apply any default annotations to return void
+public void test_nonnull_return_013() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    void getObject() {}\n" +
+			"}\n",
+			"Y.java",
+			"public class Y extends X {\n" +
+			"    @Override\n" +
+			"    void getObject() {}\n" + // don't complain, void takes no (default) annotation
+			"}\n"
+		},
+		customOptions,
+		"");
+}
+//suppress an error regarding null-spec violation
+public void test_suppress_001() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_SUPPRESS_OPTIONAL_ERRORS, JavaCore.ENABLED);
+	runConformTestWithLibs(
+			new String[] {
+				"X.java",
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class X {\n" +
+				"    @SuppressWarnings(\"null\")\n" +
+				"    @NonNull Object getObject(@Nullable Object o) {\n" +
+				"        return o;\n" + // 'o' is only potentially null
+				"    }\n" +
+				"}\n"
+			},
+			customOptions,
+			"");
+}
+// mixed use of fully qualified name / explicit import
+public void test_annotation_import_001() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	runConformTestWithLibs(
+		new String[] {
+			CUSTOM_NULLABLE_NAME,
+			CUSTOM_NULLABLE_CONTENT,
+			CUSTOM_NONNULL_NAME,
+			CUSTOM_NONNULL_CONTENT,
+			"Lib.java",
+			"public class Lib {\n" +
+			"    @org.foo.NonNull Object getObject() { return new Object(); }\n" + 	// FQN
+			"}\n",
+			"X.java",
+			"import org.foo.NonNull;\n" +											// explicit import
+			"public class X {\n" +
+			"    @NonNull Object getObject(@NonNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"");
+}
+
+// use of explicit imports throughout
+public void test_annotation_import_002() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.Nullable");
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	runConformTest(
+		new String[] {
+			CUSTOM_NULLABLE_NAME,
+			CUSTOM_NULLABLE_CONTENT,
+			CUSTOM_NONNULL_NAME,
+			CUSTOM_NONNULL_CONTENT,
+			"Lib.java",
+			"import org.foo.NonNull;\n" +
+			"public class Lib {\n" +
+			"    @NonNull Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"import org.foo.NonNull;\n" +
+			"public class X {\n" +
+			"    @NonNull Object getObject(@org.foo.Nullable String dummy, @NonNull Lib l) {\n" +
+			"        Object o = l.getObject();" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"");
+}
+// explicit import of existing annotation types
+// using a Lib without null specifications
+public void test_annotation_import_005() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"org/foo/MayBeNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"public @interface MayBeNull {}\n",
+
+			"org/foo/MustNotBeNull.java",
+			"package org.foo;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"public @interface MustNotBeNull {}\n",
+
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"import org.foo.*;\n" +
+			"public class X {\n" +
+			"    @MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		null /*no libs*/,
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	return l.getObject();\n" +
+		"	       ^^^^^^^^^^^^^\n" +
+		"Potential type mismatch: required \'@MustNotBeNull Object\' but nullness of the provided value is unknown\n" +
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// a non-null method returns a value obtained from an unannotated method, missing annotation types
+public void test_annotation_import_006() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"public class X {\n" +
+			"    @MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		null /* no libs */,
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 2)\n" +
+		"	@MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+		"	 ^^^^^^^^^^^^^\n" +
+		"MustNotBeNull cannot be resolved to a type\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 2)\n" +
+		"	@MustNotBeNull Object getObject(@MustNotBeNull Lib l) {\n" +
+		"	                                 ^^^^^^^^^^^^^\n" +
+		"MustNotBeNull cannot be resolved to a type\n" +
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+// using nullness defaulting to nonnull, missing annotation types
+public void test_annotation_import_007() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "org.foo.MayBeNull");
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.MustNotBeNull");
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	runNegativeTest(
+		true/*shouldFlushOutputDirectory*/,
+		new String[] {
+			"Lib.java",
+			"public class Lib {\n" +
+			"    Object getObject() { return new Object(); }\n" +
+			"}\n",
+			"X.java",
+			"public class X {\n" +
+			"    Object getObject(Lib l) {\n" +
+			"        return l.getObject();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		this.LIBS,
+		customOptions,
+		"----------\n" +
+		"1. ERROR in Lib.java (at line 1)\n" +
+		"	public class Lib {\n" +
+		"	^\n" +
+		"Buildpath problem: the type org.foo.MustNotBeNull, which is configured as a null annotation type, cannot be resolved\n" +
+		"----------\n",
+		JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
+}
+
+// a null annotation is illegally used on a class:
+public void test_illegal_annotation_001() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNull public class X {\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 2)\n" +
+		"	@NonNull public class X {\n" +
+		"	^^^^^^^^\n" +
+		"The annotation @NonNull is disallowed for this location\n" +
+		"----------\n",
+		this.LIBS,
+		false/*shouldFlush*/);
+}
+// this test has been removed:
+// setting default to nullable, default applies to a parameter
+// public void test_default_nullness_001()
+
+// a null annotation is illegally defined by its simple name
+// disabled because specific error is not currently raised
+public void _test_illegal_annotation_002() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "NichtNull");
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 1)\n" +
+		"	public class X {\n" +
+		"	^\n" +
+		"Cannot use the unqualified name \'NichtNull\' as an annotation name for null specification\n" +
+		"----------\n");
+}
+
+// a null annotation is illegally used on a void method:
+public void test_illegal_annotation_003() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	@NonNull void foo() {}\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	@NonNull void foo() {}\n" +
+		"	^^^^^^^^^^^^^\n" +
+		"The nullness annotation @NonNull is not applicable for the primitive type void\n" +
+		"----------\n",
+		this.LIBS,
+		false/*shouldFlush*/);
+}
+
+// a null annotation is illegally used on a primitive type parameter
+public void test_illegal_annotation_004() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	void foo(@Nullable int i) {}\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 3)\n" +
+		"	void foo(@Nullable int i) {}\n" +
+		"	         ^^^^^^^^^^^^^\n" +
+		"The nullness annotation @Nullable is not applicable for the primitive type int\n" +
+		"----------\n",
+		this.LIBS,
+		false/*shouldFlush*/);
+}
+
+// a null annotation is illegally used on a primitive type local var
+public void test_illegal_annotation_005() {
+	runNegativeTest(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"	int foo() {\n" +
+			"       @Nullable int i = 3;\n" +
+			"       return i;\n" +
+			"   }\n" +
+			"}\n"
+		},
+		"----------\n" +
+		"1. ERROR in X.java (at line 4)\n" +
+		"	@Nullable int i = 3;\n" +
+		"	^^^^^^^^^^^^^\n" +
+		"The nullness annotation @Nullable is not applicable for the primitive type int\n" +
+		"----------\n",
+		this.LIBS,
+		false/*shouldFlush*/);
+}
+
+// a configured annotation type does not exist
+// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342#c133
+public void test_illegal_annotation_006() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME, "nullAnn.Nullable");
+	runNegativeTestWithLibs(
+		new String[] {
+			"p/Test.java",
+			"package p;\n" +
+			"import nullAnn.*;  // 1 \n" +
+			"\n" +
+			"public class Test { \n" +
+			"\n" +
+			"        void foo(@nullAnn.Nullable  Object o) {   // 2\n" +
+			"            o.toString();           \n" +
+			"        }\n" +
+			"}"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p\\Test.java (at line 2)\n" +
+		"	import nullAnn.*;  // 1 \n" +
+		"	       ^^^^^^^\n" +
+		"The import nullAnn cannot be resolved\n" +
+		"----------\n" +
+		"2. ERROR in p\\Test.java (at line 6)\n" +
+		"	void foo(@nullAnn.Nullable  Object o) {   // 2\n" +
+		"	          ^^^^^^^\n" +
+		"nullAnn cannot be resolved to a type\n" +
+		"----------\n");
+}
+
+// a configured annotation type does not exist
+// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342#c186
+public void test_illegal_annotation_007() {
+	Map customOptions = getCompilerOptions();
+	runNegativeTestWithLibs(
+		new String[] {
+			"p/Test.java",
+			"package p;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"interface TestInt{\n" +
+			"	@NonNull Object foo();\n" +
+			"}\n" +
+			"\n" +
+			"public class Test { \n" +
+			"	void bar() {" +
+			"		new TestInt() {\n" +
+			"        	@org public Object foo() {\n" +
+			"        	}\n" +
+			"		};\n" +
+			"	}\n" +
+			"}"
+		},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in p\\Test.java (at line 9)\n" + 
+		"	@org public Object foo() {\n" + 
+		"	 ^^^\n" + 
+		"org cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in p\\Test.java (at line 9)\n" + 
+		"	@org public Object foo() {\n" + 
+		"	            ^^^^^^\n" + 
+		"The return type is incompatible with the @NonNull return from TestInt.foo()\n" + 
+		"----------\n");
+}
+
+public void test_default_nullness_002() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    Object getObject(@Nullable Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n",
+			"Y.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends X {\n" +
+			"    @Override\n" +
+			"    @Nullable Object getObject(Object o) {\n" + // complain illegal return redef and inherited annot is not repeated
+			"        return o;\n" +
+			"    }\n" +
+			"}\n",
+		},
+		customOptions,
+		// main error:
+		"----------\n" +
+		"1. ERROR in Y.java (at line 4)\n" +
+		"	@Nullable Object getObject(Object o) {\n" +
+		"	^^^^^^^^^^^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from X.getObject(Object)\n" +
+		"----------\n" +
+		// additional error:
+		"2. ERROR in Y.java (at line 4)\n" +
+		"	@Nullable Object getObject(Object o) {\n" +
+		"	                           ^^^^^^\n" +
+		"Illegal redefinition of parameter o, inherited method from X declares this parameter as @Nullable\n" +
+		"----------\n");
+}
+// package default is non-null
+public void test_default_nullness_003() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected Object getObject(@Nullable Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n",
+	"p2/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p2;\n",
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends p1.X {\n" +
+			"    @Override\n" +
+			"    protected @Nullable Object getObject(@Nullable Object o) {\n" +
+			"        bar(o);\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"	 void bar(Object o2) { }\n" + // parameter is nonnull per package default
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p2\\Y.java (at line 5)\n" +
+		"	protected @Nullable Object getObject(@Nullable Object o) {\n" +
+		"	          ^^^^^^^^^^^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from X.getObject(Object)\n" +
+		"----------\n" +
+		"2. ERROR in p2\\Y.java (at line 6)\n" +
+		"	bar(o);\n" +
+		"	    ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n");
+}
+// package level default is consumed from package-info.class
+public void test_default_nullness_003a() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected Object getObject(@Nullable Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"	 protected void bar(Object o2) { }\n" + // parameter is nonnull per type default
+			"}\n",
+	"p2/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p2;\n",
+			},
+			customOptions,
+			"");
+	// check if default is visible from package-info.class.
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends p1.X {\n" +
+			"    @Override\n" +
+			"    protected @Nullable Object getObject(@Nullable Object o) {\n" + // can't override inherited default nonnull
+			"        bar(o);\n" + // parameter is nonnull in super class's .class file
+			"        accept(o);\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"    void accept(Object a) {}\n" + // governed by package level default
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p2\\Y.java (at line 5)\n" +
+		"	protected @Nullable Object getObject(@Nullable Object o) {\n" +
+		"	          ^^^^^^^^^^^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from X.getObject(Object)\n" +
+		"----------\n" +
+		"2. ERROR in p2\\Y.java (at line 6)\n" +
+		"	bar(o);\n" +
+		"	    ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n" +
+		"3. ERROR in p2\\Y.java (at line 7)\n" +
+		"	accept(o);\n" +
+		"	       ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n");
+}
+//same as test_default_nullness_003b, but default-induced annotations are combined with explicit ones (not null related)
+public void test_default_nullness_003b() {
+	Map customOptions = getCompilerOptions();
+	runConformTestWithLibs(
+		new String[] {
+	"p1/Annot.java",
+			"package p1;\n" +
+			"import static java.lang.annotation.ElementType.*;\n" +
+			"import java.lang.annotation.*;\n" +
+			"@Retention(RetentionPolicy.CLASS)\n" +
+			"@Target({METHOD,PARAMETER})\n" +
+			"public @interface Annot {}\n",
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected @Annot Object getObject(@Annot @Nullable Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"	 protected @Annot void bar(@Annot Object o2) { }\n" + // parameter is nonnull per type default
+			"}\n",
+	"p2/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p2;\n",
+			},
+			customOptions,
+			"");
+	// check if default is visible from package-info.class.
+	runNegativeTestWithLibs(
+		false, // don't flush
+		new String[] {
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends p1.X {\n" +
+			"    @Override\n" +
+			"    protected @Nullable Object getObject(@Nullable Object o) {\n" + // can't override inherited default nonnull
+			"        bar(o);\n" + // parameter is nonnull in super class's .class file
+			"        accept(o);\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"    void accept(@p1.Annot Object a) {}\n" + // governed by package level default
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p2\\Y.java (at line 5)\n" +
+		"	protected @Nullable Object getObject(@Nullable Object o) {\n" +
+		"	          ^^^^^^^^^^^^^^^^\n" +
+		"The return type is incompatible with the @NonNull return from X.getObject(Object)\n" +
+		"----------\n" +
+		"2. ERROR in p2\\Y.java (at line 6)\n" +
+		"	bar(o);\n" +
+		"	    ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n" +
+		"3. ERROR in p2\\Y.java (at line 7)\n" +
+		"	accept(o);\n" +
+		"	       ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n");
+}
+// don't apply type-level default to non-reference type
+public void test_default_nullness_004() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    protected Object getObject(boolean o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n",
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class Y extends p1.X {\n" +
+			"    @Override\n" +
+			"    protected @NonNull Object getObject(boolean o) {\n" +
+			"        return o ? this : new Object();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"");
+}
+// package default is non-null
+// see also Bug 354536 - compiling package-info.java still depends on the order of compilation units
+public void test_default_nullness_005() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"public class X {\n" +
+			"    class Inner {" +
+			"        protected Object getObject(String s) {\n" +
+			"            return null;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+	"p1/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p1;\n",
+	CUSTOM_NONNULL_NAME,
+			CUSTOM_NONNULL_CONTENT
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p1\\X.java (at line 4)\n" +
+		"	return null;\n" +
+		"	       ^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n");
+}
+// package default is non-null, package-info.java read before the annotation type
+// compile order: beginToCompile(X.Inner) triggers reading of package-info.java before the annotation type was read
+public void test_default_nullness_006() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "org.foo.NonNull");
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p1;\n",
+	"p1/X.java",
+			"package p1;\n" +
+			"public class X {\n" +
+			"    class Inner {" +
+			"        protected Object getObject(String s) {\n" +
+			"            return null;\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n",
+	CUSTOM_NONNULL_NAME,
+			CUSTOM_NONNULL_CONTENT
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p1\\X.java (at line 4)\n" +
+		"	return null;\n" +
+		"	       ^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n");
+}
+// global default nonnull, but return may be null
+public void test_default_nullness_007() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    @Nullable Object dangerous() {\n" +
+			"        return null;\n" +
+			"    }\n" +
+			"    Object broken() {\n" +
+			"        return dangerous();\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 7)\n" +
+		"	return dangerous();\n" +
+		"	       ^^^^^^^^^^^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value can be null\n" +
+		"----------\n");
+}
+
+// cancel type level default to comply with super specification
+public void test_default_nullness_008() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"public class X {\n" +
+			"    protected Object getObject(Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n",
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class Y extends p1.X {\n" +
+			"    @Override\n" +
+			"    @NonNullByDefault(false)\n" +
+			"    protected Object getObject(Object o) {\n" +
+			"        if (o.toString().length() == 0)\n" + // dereference without a warning
+			"	        return null;\n" + // return null without a warning
+			"        return o.toString();\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"");
+}
+
+// cancel outer type level default to comply with super specification
+public void test_default_nullness_009() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	runNegativeTestWithLibs(
+		new String[] {
+	"p1/X.java",
+			"package p1;\n" +
+			"public class X {\n" +
+			"    protected Object getObject(Object o) {\n" +
+			"        return new Object();\n" +
+			"    }\n" +
+			"}\n",
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class Y { \n" +
+			"    @NonNullByDefault(false)\n" +
+			"    static class Z extends p1.X {\n" +
+			"        @Override\n" +
+			"        protected Object getObject(Object o) {\n" +
+			"            if (o.toString().length() == 0) {\n" +
+			"                o = null;\n" + // assign null without a warning
+			"                bar(o); // error: arg is declared @NonNull\n" +
+			"	             return null;\n" +
+			"            }\n" +
+			"            return o.toString();\n" +
+			"        }\n" +
+			"        String bar(@NonNull Object o) {\n" +
+			"            return getObject(o).toString();" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in p2\\Y.java (at line 11)\n" +
+		"	bar(o); // error: arg is declared @NonNull\n" +
+		"	    ^\n" +
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" +
+		"----------\n");
+}
+// non-null declarations are redundant within a default scope.
+public void test_default_nullness_010() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	runConformTestWithLibs(
+		new String[] {
+	"p2/Y.java",
+			"package p2;\n" +
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class Y {\n" +
+			"    protected @NonNull Object getObject(@NonNull Object o) {\n" +
+			"        return o;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		customOptions,
+		"----------\n" +
+		"1. WARNING in p2\\Y.java (at line 5)\n" +
+		"	protected @NonNull Object getObject(@NonNull Object o) {\n" +
+		"	          ^^^^^^^^^^^^^^^\n" +
+		"The nullness annotation is redundant with a default that applies to this location\n" +
+		"----------\n" +
+		"2. WARNING in p2\\Y.java (at line 5)\n" +
+		"	protected @NonNull Object getObject(@NonNull Object o) {\n" +
+		"	                                    ^^^^^^^^^^^^^^^^^\n" +
+		"The nullness annotation is redundant with a default that applies to this location\n" +
+		"----------\n");
+}
+// package-info declares nonnull-by-default
+// special compile order due to import of type from that package
+// cf. https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342#add_comment
+public void test_default_nullness_011() {
+	runNegativeTestWithLibs(
+		new String[] {
+			"Main.java",
+			"import p1.C;\n" +
+			"public class Main {\n" +
+			"    void test(@org.eclipse.jdt.annotation.NonNull Object o) {\n" +
+			"        o = null;\n" +
+			"        new C(null);\n" +
+			"    }\n" +
+			"}\n",
+			"p1/C.java",
+			"package p1;\n" +
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"public class C {\n" +
+			"    public C (Object o) {}\n" +
+			"}\n",
+			"p1/package-info.java",
+			"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+			"package p1;\n"
+		},
+		"----------\n" + 
+		"1. ERROR in Main.java (at line 4)\n" + 
+		"	o = null;\n" + 
+		"	    ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in Main.java (at line 5)\n" + 
+		"	new C(null);\n" + 
+		"	      ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n");
+}
+// a nonnull variable is dereferenced in a loop
+public void test_nonnull_var_in_constrol_structure_1() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void print4(@NonNull String s) {\n" +
+			"        for (int i=0; i<4; i++)\n" +
+			"             print(s);\n" +
+			"    }\n" +
+			"    void print5(@Nullable String s) {\n" +
+			"        for (int i=0; i<5; i++)\n" +
+			"             print(s);\n" +
+			"    }\n" +
+			"    void print6(boolean b) {\n" +
+			"        String s = b ? null : \"\";\n" +
+			"        for (int i=0; i<5; i++)\n" +
+			"             print(s);\n" +
+			"    }\n" +
+			"    void print(@NonNull String s) {\n" +
+			"        System.out.print(s);\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		customOptions,
+		"----------\n" +
+		"1. WARNING in X.java (at line 3)\n" +
+		"	void print4(@NonNull String s) {\n" +
+		"	            ^^^^^^^^^^^^^^^^^\n" +
+		"The nullness annotation is redundant with a default that applies to this location\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 9)\n" +
+		"	print(s);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n" +
+		"3. ERROR in X.java (at line 14)\n" +
+		"	print(s);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n" +
+		"4. WARNING in X.java (at line 16)\n" +
+		"	void print(@NonNull String s) {\n" +
+		"	           ^^^^^^^^^^^^^^^^^\n" +
+		"The nullness annotation is redundant with a default that applies to this location\n" +
+		"----------\n");
+}
+// a nonnull variable is dereferenced in a finally block
+public void test_nonnull_var_in_constrol_structure_2() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void print4(String s) {\n" +
+			"        try { /*empty*/ } finally {\n" +
+			"             print(s);\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print5(@Nullable String s) {\n" +
+			"        try { /*empty*/ } finally {\n" +
+			"             print(s);\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print6(boolean b) {\n" +
+			"        String s = b ? null : \"\";\n" +
+			"        try { /*empty*/ } finally {\n" +
+			"             print(s);\n" +
+			"        }\n" +
+			"    }\n" +
+			"    void print(String s) {\n" +
+			"        System.out.print(s);\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 10)\n" +
+		"	print(s);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 16)\n" +
+		"	print(s);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n");
+}
+// a nonnull variable is dereferenced in a finally block inside a loop
+public void test_nonnull_var_in_constrol_structure_3() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	customOptions.put(JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION, JavaCore.IGNORE);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"public class X {\n" +
+			"    void print4(@NonNull String s) {\n" +
+			"        for (int i=0; i<4; i++)\n" +
+			"            try { /*empty*/ } finally {\n" +
+			"                 print(s);\n" +
+			"            }\n" +
+			"    }\n" +
+			"    void print5(@Nullable String s) {\n" +
+			"        for (int i=0; i<5; i++)\n" +
+			"            try { /*empty*/ } finally {\n" +
+			"                 print(s);\n" +
+			"            }\n" +
+			"    }\n" +
+			"    void print6(boolean b) {\n" +
+			"        String s = b ? null : \"\";\n" +
+			"        for (int i=0; i<4; i++)\n" +
+			"            try { /*empty*/ } finally {\n" +
+			"                 print(s);\n" +
+			"            }\n" +
+			"    }\n" +
+			"    void print(@NonNull String s) {\n" +
+			"        System.out.print(s);\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 12)\n" +
+		"	print(s);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 19)\n" +
+		"	print(s);\n" +
+		"	      ^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n");
+}
+// a nonnull variable is dereferenced method of a nested type
+public void test_nesting_1() {
+	Map customOptions = getCompilerOptions();
+//	customOptions.put(CompilerOptions.OPTION_ReportPotentialNullSpecViolation, JavaCore.ERROR);
+	customOptions.put(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+	runNegativeTestWithLibs(
+		new String[] {
+			"X.java",
+			"import org.eclipse.jdt.annotation.*;\n" +
+			"@NonNullByDefault\n" +
+			"public class X {\n" +
+			"    void print4(final String s1) {\n" +
+			"        for (int i=0; i<3; i++)\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     print(s1);\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"    }\n" +
+			"    void print8(final @Nullable String s2) {\n" +
+			"        for (int i=0; i<3; i++)\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     print(s2);\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"    }\n" +
+			"    void print16(boolean b) {\n" +
+			"        final String s3 = b ? null : \"\";\n" +
+			"        for (int i=0; i<3; i++)\n" +
+			"            new Runnable() {\n" +
+			"                public void run() {\n" +
+			"                     @NonNull String s3R = s3;\n" +
+			"                }\n" +
+			"            }.run();\n" +
+			"    }\n" +
+			"    void print(String s) {\n" +
+			"        System.out.print(s);\n" +
+			"    }\n" +
+			"}\n",
+
+		},
+		customOptions,
+		"----------\n" +
+		"1. ERROR in X.java (at line 16)\n" +
+		"	print(s2);\n" +
+		"	      ^^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n" +
+		"2. ERROR in X.java (at line 25)\n" +
+		"	@NonNull String s3R = s3;\n" +
+		"	                      ^^\n" +
+		"Type mismatch: required \'@NonNull String\' but the provided value can be null\n" +
+		"----------\n");
+}
+// Test a regression incurred to the OT/J based implementation
+// by the fix in Bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+public void test_constructor_with_nested_class() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"    final Object o1;\n" +
+			"    final Object o2;\n" +
+			"    public X() {\n" +
+			"         this.o1 = new Object() {\n" +
+			"             public String toString() { return \"O1\"; }\n" +
+			"         };\n" +
+			"         this.o2 = new Object();" +
+			"    }\n" +
+			"}\n"
+		},
+		"");
+}
+// test analysis disablement, binary type contains annotation
+public void test_options_01() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO, JavaCore.ERROR);
+	runConformTestWithLibs(
+			new String[] {
+				"ContainingInner2.java",
+				"public class ContainingInner2 {\n" + 
+				"    public ContainingInner2 (@org.eclipse.jdt.annotation.NonNull Object o) {\n" + 
+				"    }\n" + 
+				"    public class Inner {\n" + 
+				"        public <T> Inner (@org.eclipse.jdt.annotation.NonNull T o) {\n" + 
+				"        }\n" + 
+				"    }\n" + 
+				"}\n",
+			},
+			null /*customOptions*/,
+			"");
+	customOptions.put(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.DISABLED);
+	runConformTestWithLibs(
+		false, // flush directory
+		new String[] {
+			"X.java",
+			"public class X {\n" +
+			"	 void create() {\n" +
+			"          ContainingInner2 container = new ContainingInner2(null);\n" +
+			"	       ContainingInner2.Inner inner = container.new Inner(null);\n" +
+			"    }\n" +
+		  	"}\n"},
+		customOptions,
+		""  /* compiler output */);
+}
+// test illegally trying to ignore null spec violations
+public void test_options_02() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION, JavaCore.IGNORE); // has no effect
+	runNegativeTestWithLibs(
+		new String[] {
+			"Test.java",
+			"public class Test {\n" +
+			"    public void foo(@org.eclipse.jdt.annotation.NonNull Object o) {\n" +
+			"        o = null;\n" +
+			"        Object p = o;\n" +
+			"        if (p == null)\n" +
+			"            p.toString();\n" +
+			"    }\n" + 
+			"}\n",
+		},
+		customOptions,
+		"----------\n" + 
+		"1. ERROR in Test.java (at line 3)\n" + 
+		"	o = null;\n" + 
+		"	    ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 5)\n" + 
+		"	if (p == null)\n" + 
+		"	    ^\n" + 
+		"Null comparison always yields false: The variable p cannot be null at this location\n" + 
+		"----------\n" + 
+		"3. WARNING in Test.java (at line 6)\n" + 
+		"	p.toString();\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+// test setting null spec violations to "warning"
+public void test_options_03() {
+	Map customOptions = getCompilerOptions();
+	customOptions.put(JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION, JavaCore.WARNING); // OK
+	runNegativeTestWithLibs(
+		new String[] {
+			"Test.java",
+			"public class Test {\n" +
+			"    public void foo(@org.eclipse.jdt.annotation.NonNull Object o) {\n" +
+			"        o = null;\n" +
+			"        Object p = o;\n" +
+			"        if (p == null)\n" +
+			"            p.toString();\n" +
+			"    }\n" + 
+			"}\n",
+		},
+		customOptions,
+		"----------\n" + 
+		"1. WARNING in Test.java (at line 3)\n" + 
+		"	o = null;\n" + 
+		"	    ^^^^\n" + 
+		"Type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
+		"----------\n" + 
+		"2. ERROR in Test.java (at line 5)\n" + 
+		"	if (p == null)\n" + 
+		"	    ^\n" + 
+		"Null comparison always yields false: The variable p cannot be null at this location\n" + 
+		"----------\n" + 
+		"3. WARNING in Test.java (at line 6)\n" + 
+		"	p.toString();\n" + 
+		"	^^^^^^^^^^^^\n" + 
+		"Dead code\n" + 
+		"----------\n");
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
index 28a772e..4dbf8ba 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/TestAll.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.compiler.regression;
 
@@ -96,6 +97,7 @@ public static Test suite() {
 	since_1_5.add(InnerEmulationTest_1_5.class);
 	since_1_5.add(AssignmentTest_1_5.class);
 	since_1_5.add(InnerClass15Test.class);
+	since_1_5.add(NullAnnotationTest.class);
 
 	// Tests to run when compliance is greater than 1.5
 	ArrayList since_1_6 = new ArrayList();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
index 00678f7..1e06c11 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15JLS4Test.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.dom;
 
@@ -7494,7 +7495,10 @@ public class ASTConverter15JLS4Test extends ConverterTestSetup {
 				buffer.append(typeBinding.getAnnotations().length);
 				typeBinding= typeBinding.getSuperclass();
 			}
-			assertEquals("Wrong number of annotations", "000", String.valueOf(buffer));
+			// initially, this test expected "000", but after https://bugs.eclipse.org/186342
+			// annotations are resolved more eagerly, which makes the annotations on Test2 show up,
+			// which is actually the right outcome.
+			assertEquals("Wrong number of annotations", "020", String.valueOf(buffer));
 		}
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
index 2af2c81..e89ba8f 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter15Test.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for 
  *     							Bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
  *     							Bug 353474 - type converters should include more annotations
+ *     							Bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.core.tests.dom;
 
@@ -7497,7 +7498,10 @@ public class ASTConverter15Test extends ConverterTestSetup {
 				buffer.append(typeBinding.getAnnotations().length);
 				typeBinding= typeBinding.getSuperclass();
 			}
-			assertEquals("Wrong number of annotations", "000", String.valueOf(buffer));
+			// initially, this test expected "000", but after https://bugs.eclipse.org/186342
+			// annotations are resolved more eagerly, which makes the annotations on Test2 show up,
+			// which is actually the right outcome.
+			assertEquals("Wrong number of annotations", "020", String.valueOf(buffer));
 		}
 	}
 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
index d3e6b2b..537f730 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AllJavaModelTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -185,6 +185,9 @@ private static Class[] getAllTestClasses() {
 		UtilTests.class,
 		
 		JavaCoreOptionsTests.class,
+		
+		// Tests regarding null-annotations:
+		NullAnnotationModelTests.class,
 	};
 
 	Class[] deprecatedClasses = getDeprecatedJDOMTestClasses();
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
new file mode 100644
index 0000000..d38f045
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NullAnnotationModelTests.java
@@ -0,0 +1,484 @@
+/*******************************************************************************
+ * Copyright (c) 2011 GK Software AG and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     Stephan Herrmann - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.model;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.ByteArrayInputStream;
+import java.net.URL;
+import java.util.Hashtable;
+import java.util.List;
+
+import junit.framework.Test;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IMarker;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaModelMarker;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.compiler.IProblem;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.MarkerAnnotation;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.Modifier;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+
+public class NullAnnotationModelTests extends ReconcilerTests {
+
+	String ANNOTATION_LIB;
+
+	public static Test suite() {
+		return buildModelTestSuite(NullAnnotationModelTests.class);
+	}
+
+	public NullAnnotationModelTests(String name) {
+		super(name);
+	}
+
+	static {
+//		TESTS_NAMES = new String[] { "testMissingAnnotation5" };
+	}
+
+	public void setUp() throws Exception {
+		super.setUp();
+		File bundleFile = FileLocator.getBundleFile(Platform.getBundle("org.eclipse.jdt.annotation"));
+		this.ANNOTATION_LIB = bundleFile.isDirectory() ? bundleFile.getPath()+"/bin" : bundleFile.getPath();
+	}
+
+	protected String testJarPath(String jarName) throws IOException {
+		URL libEntry = Platform.getBundle("org.eclipse.jdt.core.tests.model").getEntry("/workspace/NullAnnotations/lib/"+jarName);
+		return FileLocator.toFileURL(libEntry).getPath();
+	}
+
+
+	public void testConvertedSourceType1() throws CoreException, InterruptedException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+
+			this.createFolder("/P/p1");
+			String c1SourceString =
+				"package p1;\n" +
+				"import org.eclipse.jdt.annotation.*;\n" +
+				"public class C1 {\n" +
+				"	 public String foo(@Nullable Object arg) {\n" + // this is consumed via SourceTypeConverter
+				"		return arg == null ? \"\" : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p1/C1.java",
+	    			c1SourceString);
+
+			this.createFolder("/P/p2");
+			String c2SourceString =
+				"package p2;\n" +
+				"public class C2 {\n" +
+				"	 String bar(p1.C1 c, C2 c2) {;\n" +
+				"        return c.foo(null);\n" + // don't complain despite default nonnull, foo has explicit @Nullable
+				"    }\n" +
+				"	 String foo(Object arg) {\n" +
+				"		return arg == null ? null : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p2/C2.java",
+	    			c2SourceString);
+
+			char[] c2SourceChars = c2SourceString.toCharArray();
+			this.problemRequestor.initialize(c2SourceChars);
+
+			getCompilationUnit("/P/p2/C2.java").getWorkingCopy(this.wcOwner, null);
+
+			assertProblems("Unexpected problems", "----------\n" +
+					"1. WARNING in /P/p2/C2.java (at line 7)\n" +
+					"	return arg == null ? null : arg.toString();\n" +
+					"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
+					"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" +
+					"----------\n");
+    	} finally {
+    		deleteProject("P");
+    	}
+    }
+
+	public void testBinaryType1() throws CoreException, InterruptedException, IOException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""},
+											   new String[] {"JCL15_LIB", this.ANNOTATION_LIB, testJarPath("example.jar")},
+											   "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_IS_DEFAULT, JavaCore.ENABLED);
+
+			// example.jar contains p1/C1.java just like testConvertedSourceType1()
+
+			this.createFolder("/P/p2");
+			String c2SourceString =
+				"package p2;\n" +
+				"public class C2 {\n" +
+				"	 String bar(p1.C1 c) {;\n" +
+				"        return c.foo(null);\n" + // don't complain despite default nonnull, foo has explicit @Nullable
+				"    }\n" +
+				"	 String foo(Object arg) {\n" +
+				"		return arg == null ? null : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p2/C2.java",
+	    			c2SourceString);
+
+			char[] c2SourceChars = c2SourceString.toCharArray();
+			this.problemRequestor.initialize(c2SourceChars);
+
+			getCompilationUnit("/P/p2/C2.java").getWorkingCopy(this.wcOwner, null);
+
+			assertProblems("Unexpected problems", "----------\n" +
+					"1. WARNING in /P/p2/C2.java (at line 7)\n" +
+					"	return arg == null ? null : arg.toString();\n" +
+					"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" +
+					"Potential type mismatch: required \'@NonNull String\' but nullness of the provided value is unknown\n" +
+					"----------\n");
+    	} finally {
+    		deleteProject("P");
+    	}
+    }
+
+	public void testMissingAnnotation1() throws CoreException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "in.valid");
+
+			this.createFolder("/P/p1");
+			String c1SourceString =
+				"package p1;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"public class C1 {\n" +
+				"	 public String foo(Object arg) {\n" +
+				"		return arg == null ? \"\" : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p1/C1.java",
+	    			c1SourceString);
+
+			this.problemRequestor.initialize(c1SourceString.toCharArray());
+
+			getCompilationUnit("/P/p1/C1.java").getWorkingCopy(this.wcOwner, null);
+
+			assertProblems("Unexpected problems",
+					"----------\n" +
+					"1. ERROR in /P/p1/C1.java (at line 1)\n" +
+					"	package p1;\n" +
+					"	^\n" +
+					"Buildpath problem: the type in.valid, which is configured as a null annotation type, cannot be resolved\n" +
+					"----------\n");
+    	} finally {
+    		deleteProject("P");
+    	}
+	}
+
+	public void testMissingAnnotation2() throws CoreException {
+		Hashtable javaOptions = JavaCore.getOptions();
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			IFile settings = (IFile) p.getProject().findMember(".settings/org.eclipse.jdt.core.prefs");
+			settings.appendContents(new ByteArrayInputStream("\norg.eclipse.jdt.core.compiler.annotation.nonnull=not.valid\n".getBytes()), 0, null);
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+
+			this.createFolder("/P/p1");
+			String c1SourceString =
+				"package p1;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"public class C1 {\n" +
+				"	 public String foo(Object arg) {\n" +
+				"		return arg == null ? \"\" : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p1/C1.java",
+	    			c1SourceString);
+
+			this.problemRequestor.initialize(c1SourceString.toCharArray());
+
+			getCompilationUnit("/P/p1/C1.java").getWorkingCopy(this.wcOwner, null);
+
+			assertProblems("Unexpected problems",
+					"----------\n" +
+					"1. ERROR in /P/p1/C1.java (at line 1)\n" +
+					"	package p1;\n" +
+					"	^\n" +
+					"Buildpath problem: the type not.valid, which is configured as a null annotation type, cannot be resolved\n" +
+					"----------\n");
+    	} finally {
+    		deleteProject("P");
+    		JavaCore.setOptions(javaOptions);
+    		// work against side-effect of JavaRuntime listening to change of prefs-file.
+    		// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=302850#c25
+    	}
+	}
+
+	// Bug 363858 - [dom] early throwing of AbortCompilation causes NPE in CompilationUnitResolver
+	// currently not actually challenging the NPE, because we no longer report
+	// "Cannot use the unqualified name \'invalid\' as an annotation name for null specification"
+	public void testMissingAnnotation3() throws CoreException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "invalid");
+
+			this.createFolder("/P/p1");
+			String c1SourceString =
+				"package p1;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"public class C1 {\n" +
+				"	 public String foo(Object arg) {\n" +
+				"		return arg == null ? \"\" : arg.toString();\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p1/C1.java",
+	    			c1SourceString);
+
+			this.problemRequestor.initialize(c1SourceString.toCharArray());
+
+			final ICompilationUnit unit = getCompilationUnit("/P/p1/C1.java").getWorkingCopy(this.wcOwner, null);
+			assertProblems("Unexpected problems",
+					"----------\n" +
+					"1. ERROR in /P/p1/C1.java (at line 1)\n" +
+					"	package p1;\n" +
+					"	^\n" +
+					"Buildpath problem: the type invalid, which is configured as a null annotation type, cannot be resolved\n" +
+					"----------\n");
+
+			ASTParser parser = ASTParser.newParser(AST.JLS4);
+			parser.setProject(p);
+			parser.setResolveBindings(true);
+			parser.setSource(unit);
+			CompilationUnit ast = (CompilationUnit) parser.createAST(null);
+			assertNotNull("ast should not be null", ast);
+			this.problemRequestor.reset();
+			this.problemRequestor.beginReporting();
+			IProblem[] problems = ast.getProblems();
+			for (int i=0; i<problems.length; i++)
+				this.problemRequestor.acceptProblem(problems[i]);
+			assertProblems("Unexpected problems (2)",
+					"----------\n" +
+					"1. ERROR in /P/p1/C1.java (at line 1)\n" +
+					"	package p1;\n" +
+					"	^\n" +
+					"Buildpath problem: the type invalid, which is configured as a null annotation type, cannot be resolved\n" +
+					"----------\n");
+    	} finally {
+    		deleteProject("P");
+    	}
+	}
+
+	// initialization of null annotations is triggered from package-info.java: illegal simple name
+	public void testMissingAnnotation4() throws CoreException, InterruptedException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "invalid");
+
+			this.createFolder("/P/p1");
+			String piSourceString =
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"package p1;\n";
+			this.createFile(
+				"/P/p1/package-info.java",
+	    			piSourceString);
+
+			this.problemRequestor.initialize(piSourceString.toCharArray());
+
+			// Challenge CompilationUnitProblemFinder:
+			final ICompilationUnit unit = getCompilationUnit("/P/p1/package-info.java").getWorkingCopy(this.wcOwner, null);
+// This error is not raised currently:
+//			String expectedError = "----------\n" +
+//								   "1. ERROR in /P/p1/package-info.java (at line 0)\n" +
+//								   "	@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+//								   "	^\n" +
+//								   "Cannot use the unqualified name \'invalid\' as an annotation name for null specification\n" +
+//								   "----------\n";
+//			assertProblems("Unexpected problems from CompilationUnitProblemFinder", expectedError);
+			assertNoProblem(unit.getBuffer().getCharacters(), unit);
+
+			// Challenge JavaBuilder:
+			p.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, true, IResource.DEPTH_INFINITE);
+//			assertMarkers("Unexpected markers",
+//					"Cannot use the unqualified name 'invalid' as an annotation name for null specification",
+//					markers);
+//			assertEquals("Unexpected marker path", "/P", markers[0].getResource().getFullPath().toString());
+			assertEquals("Should have no markers", 0, markers.length);
+
+			// Challenge CompilationUnitResolver:
+			ASTParser parser = ASTParser.newParser(AST.JLS4);
+			parser.setProject(p);
+			parser.setResolveBindings(true);
+			parser.setSource(unit);
+			CompilationUnit ast = (CompilationUnit) parser.createAST(null);
+			assertNotNull("ast should not be null", ast);
+//			this.problemRequestor.reset();
+//			this.problemRequestor.beginReporting();
+//			IProblem[] problems = ast.getProblems();
+//			for (int i=0; i<problems.length; i++)
+//				this.problemRequestor.acceptProblem(problems[i]);
+//			assertProblems("Unexpected problems from CompilationUnitResolver", expectedError);
+			assertEquals("Should have no problems", 0, ast.getProblems().length);
+    	} finally {
+    		deleteProject("P");
+    	}
+	}
+
+	// initialization of null annotations is
+	// - triggered from resolveTypesFor(MethodBinding)
+	// - default is defined in package-info.java:
+	// must detect missing non-null annotation and report against the project
+	public void testMissingAnnotation5() throws CoreException, InterruptedException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+			p.setOption(JavaCore.COMPILER_NONNULL_ANNOTATION_NAME, "pack.Missing");
+
+			this.createFolder("/P/p1");
+			String piSourceString =
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"package p1;\n";
+			this.createFile("/P/p1/package-info.java", piSourceString);
+
+			String c1SourceString =
+				"package p1;\n" +
+				"public class C1 {\n" +
+				"    String foo(String arg) { return arg; }\n" +
+				"}\n";
+			this.createFile("/P/p1/C1.java", c1SourceString);
+
+			this.problemRequestor.initialize(piSourceString.toCharArray());
+
+			// Challenge CompilationUnitProblemFinder:
+			assertNoProblem(piSourceString.toCharArray(), getCompilationUnit("/P/p1/package-info.java"));
+
+			this.problemRequestor.initialize(c1SourceString.toCharArray());
+
+			// Challenge CompilationUnitProblemFinder:
+			ICompilationUnit unit = getCompilationUnit("/P/p1/C1.java").getWorkingCopy(this.wcOwner, null);
+			String expectedError = "----------\n" +
+								   "1. ERROR in /P/p1/C1.java (at line 1)\n" +
+								   "	package p1;\n" +
+								   "	^\n" +
+								   "Buildpath problem: the type pack.Missing, which is configured as a null annotation type, cannot be resolved\n" +
+								   "----------\n";
+			assertProblems("Unexpected problems", expectedError);
+
+			// Challenge JavaBuilder:
+			p.getProject().build(IncrementalProjectBuilder.FULL_BUILD, null);
+			IMarker[] markers = p.getProject().findMarkers(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, true, IResource.DEPTH_INFINITE);
+			assertMarkers("Unexpected markers",
+					"Buildpath problem: the type pack.Missing, which is configured as a null annotation type, cannot be resolved",
+					markers);
+// toggle expectation depending on how CAT_BUILDPATH problems are reported (see AbstractImageBuilder.storeProblemsFor(..))
+//			assertEquals("Unexpected marker path", "/P", markers[0].getResource().getFullPath().toString());
+			assertEquals("Unexpected marker path", "/P/p1/C1.java", markers[0].getResource().getFullPath().toString());
+
+			// Challenge CompilationUnitResolver:
+			ASTParser parser = ASTParser.newParser(AST.JLS4);
+			parser.setProject(p);
+			parser.setResolveBindings(true);
+			parser.setSource(unit);
+			CompilationUnit ast = (CompilationUnit) parser.createAST(null);
+			assertNotNull("ast should not be null", ast);
+			this.problemRequestor.reset();
+			this.problemRequestor.beginReporting();
+			IProblem[] problems = ast.getProblems();
+			for (int i=0; i<problems.length; i++)
+				this.problemRequestor.acceptProblem(problems[i]);
+			assertProblems("Unexpected problems (2)", expectedError);
+    	} finally {
+    		deleteProject("P");
+    	}
+	}
+
+	// A synthetic annotation from a default should not be converted to DOM AST
+	public void testAnnotationAST1() throws CoreException, InterruptedException {
+    	try {
+			// Resources creation
+			IJavaProject p = createJavaProject("P", new String[] {""}, new String[] {"JCL15_LIB", this.ANNOTATION_LIB}, "bin", "1.5");
+			p.setOption(JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS, JavaCore.ENABLED);
+
+			this.createFolder("/P/p1");
+			// bug could only be triggered if ASTConvert actually finds a '@'
+			// so in addition to the synthetic annotation there must also be a real one:
+			String annotSourceString =
+				"package p1;\n" +
+				"import java.lang.annotation.ElementType;\n" + 
+				"import java.lang.annotation.Target;\n" + 
+				"@Target({ElementType.PARAMETER,ElementType.METHOD})\n" +
+				"public @interface Annot {}\n";
+			this.createFile(
+				"/P/p1/Annot.java",
+	    			annotSourceString);
+			String c1SourceString =
+				"package p1;\n" +
+				"@org.eclipse.jdt.annotation.NonNullByDefault\n" +
+				"public class C1 {\n" +
+				"	 public @Annot Object foo(@Annot Object arg) {\n" +
+				"         return this;\n" +
+				"	 }\n" +
+				"}\n";
+			this.createFile(
+				"/P/p1/C1.java",
+	    			c1SourceString);
+
+			this.problemRequestor.initialize(c1SourceString.toCharArray());
+
+			final ICompilationUnit unit = getCompilationUnit("/P/p1/C1.java").getWorkingCopy(this.wcOwner, null);
+			assertNoProblem(c1SourceString.toCharArray(), unit);
+
+			ASTParser parser = ASTParser.newParser(AST.JLS4);
+			parser.setProject(p);
+			parser.setResolveBindings(true);
+			parser.setSource(unit);
+			CompilationUnit ast = (CompilationUnit) parser.createAST(null);
+			assertNotNull("ast should not be null", ast);
+			TypeDeclaration type = (TypeDeclaration) ast.types().get(0);
+			assertNotNull("type should not be null", type);
+			MethodDeclaration method = (MethodDeclaration) type.bodyDeclarations().get(0);
+			assertNotNull("method should not be null", method);
+			SingleVariableDeclaration arg = (SingleVariableDeclaration) method.parameters().get(0);
+			assertNotNull("argument should not be null", arg);
+			List modifiers = arg.modifiers();
+			assertEquals("Should have exactly one modifier", 1, modifiers.size());
+			assertEquals("Unexpected modifier", "@Annot", ((MarkerAnnotation)modifiers.get(0)).toString());
+			modifiers = method.modifiers();
+			assertEquals("Method should have exactly two modifiers", 2, modifiers.size());
+			assertEquals("Unexpected modifier #1 for method", "public", ((Modifier)modifiers.get(0)).toString());
+			assertEquals("Unexpected modifier #2 for method", "@Annot", ((MarkerAnnotation)modifiers.get(1)).toString());
+    	} finally {
+    		deleteProject("P");
+    	}
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/example.jar b/org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/example.jar
new file mode 100644
index 0000000..4f9b0ca
Binary files /dev/null and b/org.eclipse.jdt.core.tests.model/workspace/NullAnnotations/lib/example.jar differ
diff --git a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
index 51b984e..88a28a6 100644
--- a/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
+++ b/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties
@@ -19,7 +19,7 @@
 #Format: compiler.name = word1 word2 word3
 compiler.name = Eclipse Compiler for Java(TM)
 #Format: compiler.version = 0.XXX[, other words (don't forget the comma if adding other words)]
-compiler.version = 0.C22, 3.8.0 M4
+compiler.version = 0.C23, 3.8.0 M4
 compiler.copyright = Copyright IBM Corp 2000, 2011. All rights reserved.
 
 ### progress
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 68b365b..63a3e7e 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -42,11 +42,311 @@
 	</td>
   </tr>
 </table>
+<a name="v_C23"></a>
+<hr><h1>
+Eclipse Platform Build Notes<br>
+Java development tools core</h1>
+Eclipse SDK 3.8.0 - %date% - 3.8.0 M4
+<br>Project org.eclipse.jdt.core v_C23
+(<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C23">cvs</a>).
+<h2>What's new in this drop</h2>
+<ul>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_ANNOTATION_NULL_ANALYSIS (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Annotation-based Null Analysis.
+     * 
+     * This option controls whether the compiler will use null annotations for
+     * improved analysis of (potential) null references.
+     * 
+     * If enabled the compiler will interpret the annotation types defined using
+     * {@link #COMPILER_NONNULL_ANNOTATION_NAME} and {@link #COMPILER_NULLABLE_ANNOTATION_NAME}
+     * as specifying whether or not a given type includes the value <code>null</code>.
+     * 
+     * The effect of these analyses is further controled by the options
+     * {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
+     * {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
+     * {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
+     * 
+     * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nullanalysis"</code>
+     * Possible values: <code>{ "disabled", "enabled" }</code>
+     * Default: <code>"disabled"</code>
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_ANNOTATION_NULL_ANALYSIS = PLUGIN_ID + ".compiler.annotation.nullanalysis";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_NULLABLE_ANNOTATION_NAME (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Name of Annotation Type for Nullable Types.
+     * 
+     * This option defines a fully qualified Java type name that the compiler may use
+     * to perform special null analysis.
+     * 
+     * If the annotation specified by this option is applied to a type in a method
+     * signature or variable declaration this will be interpreted as a specification
+     * that <code>null</code> is a legal value in that position. Currently supported
+     * positions are: method parameters, method return type and local variables.
+     * 
+     * If a value whose type
+     * is annotated with this annotation is dereferenced without checking for null
+     * the compiler will trigger a diagnostic as further controlled by
+     * {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}.
+     * 
+     * The compiler may furthermore check adherence to the null specification as
+     * further controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
+     * {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
+     * {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     * 
+     * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code>
+     * Possible values: any legal, fully qualified Java type name, must resolve to an annotation type.
+     * Default: <code>"org.eclipse.jdt.annotation.Nullable"</code>
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_NULLABLE_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nullable";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_NONNULL_ANNOTATION_NAME (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Name of Annotation Type for Non-Null Types.
+     * 
+     * This option defines a fully qualified Java type name that the compiler may use
+     * to perform special null analysis.
+     * 
+     * If the annotation specified by this option is applied to a type in a method
+     * signature or variable declaration this will be interpreted as a specification
+     * that <code>null</code> is <b>not</b> a legal value in that position. Currently
+     * supported positions are: method parameters, method return type and local variables.
+     * 
+     * For values declared with this annotation the compiler will never trigger a null
+     * reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
+     * and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
+     * will never occur at runtime in these positions.
+     * 
+     * The compiler may furthermore check adherence to the null specification as further
+     * controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
+     * {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
+     * {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     * 
+     * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code>
+     * Possible values: any legal, fully qualified Java type name, must resolve to an annotation type.
+     * Default: <code>"org.eclipse.jdt.annotation.NonNull"</code>
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_NONNULL_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnull";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Name of Annotation Type to specify a nullness default for unannotated types.
+     * 
+     * This option defines a fully qualified Java type name that the compiler may use
+     * to perform special null analysis.
+     * 
+     * If the annotation is applied without an argument all unannotated types in method signatures
+     * within the annotated element will be treated as if they were specified with the non-null annotation
+     * (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).
+     * 
+     * If the annotation is applied with the constant <code>false</code> as its argument
+     * all corresponding defaults at outer scopes will be canceled for the annotated element.
+     * This includes defaults specified using this annotation type or a default defined using
+     * the compiler option {@link #COMPILER_NONNULL_IS_DEFAULT}.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     * 
+     * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"</code>
+     * Possible values: any legal, fully qualified Java type name, must resolve to an annotation type.
+     *     That annotation type should have exactly one boolean parameter.
+     * Default: <code>"org.eclipse.jdt.annotation.NonNullByDefault"</code>
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnullbydefault";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_NONNULL_IS_DEFAULT (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Globally specify non-null as the assumed default for unannotated types.
+     * 
+     * When enabled this option globally achieves the same effect 
+     * as specifying {@link #COMPILER_NONNULL_ANNOTATION_NAME} does for individual elements.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     *
+     * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault"</code>
+     * Possible values: <code>{ "disabled", "enabled" }</code>.
+     * Default: <code>"disabled"</code>
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_NONNULL_IS_DEFAULT = PLUGIN_ID + ".compiler.annotation.nonnullisdefault";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_NULL_SPECIFICATION_VIOLATION (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Reporting Violations of Null Specifications.
+     * 
+     * Depending on this option, the compiler will issue either an error or a warning
+     * whenever one of the following situations is detected:
+     * 
+     * 1. A method declared with a nonnull annotation returns an expression that is
+     *    statically known to evaluate to a null value.
+     * 2. An expression that is statically known to evaluate to a null value is passed
+     *    as an argument in a method call where the corresponding parameter of the called
+     *    method is declared with a nonnull annotation.
+     * 3. An expression that is statically known to evaluate to a null value is assigned
+     *    to a local variable that is declared with a nonnull annotation.
+     * 4. A method that overrides an inherited method declared with a nonnull annotation
+     *    tries to relax that contract by specifying a nullable annotation
+     *    (prohibition of contravariant return).
+     * 5. A method that overrides an inherited method which has a nullable declaration
+     *    for at least one of its parameters, tries to tighten that null contract by
+     *    specifying a nonnull annotation for its corresponding parameter
+     *    (prohibition of covariant parameters).
+     * 
+     * The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+     * {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+     * shall interpret as nonnull or nullable annotations, respectively.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     *
+     * Option id: <code>"org.eclipse.jdt.core.compiler.problem.nullSpecViolation"</code>
+     * Possible values: <code>{ "error", "warning" }</code>
+     * Default: <code>"error"</code>
+     * 
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_PB_NULL_SPECIFICATION_VIOLATION = PLUGIN_ID + ".compiler.problem.nullSpecViolation";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Reporting Violations of Null Specifications with Potential Null Value.
+     * 
+     * When enabled, the compiler will issue an error or a warning whenever one of the
+     * following situations is detected:
+     *
+     * 1. A method declared with a nonnull annotation returns an expression that is
+     *    statically known to evaluate to a null value on some flow.
+     * 2. An expression that is statically known to evaluate to a null value on some flow
+     *    is passed as an argument in a method call where the corresponding parameter of
+     *    the called method is declared with a nonnull annotation.
+     * 3. An expression that is statically known to evaluate to a null value on some flow
+     *    is assigned to a local variable that is declared with a nonnull annotation.
+     * 
+     * The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+     * {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+     * shall interpret as nonnull or nullable annotations, respectively.
+     * 
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     *
+     * Option id: <code>"org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation"</code>
+     * Possible values: <code>{ "error", "warning", "ignore" }</code>
+     * Default: <code>"error"</code>
+     * 
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION = PLUGIN_ID + ".compiler.problem.potentialNullSpecViolation";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Reporting Insufficient Information for Analysing Adherence to Null Specifications.
+     * 
+     * When enabled, the compiler will issue an error or a warning whenever one of the
+     * following situations is detected:
+     *
+     * 1. A method declared with a nonnull annotation returns an expression for which
+     *    insufficient nullness information is available for statically proving that no
+     *    flow will pass a null value at runtime.
+     * 2. An expression for which insufficient nullness information is available for
+     *    statically proving that it will never evaluate to a null value at runtime
+     *    is passed as an argument in a method call where the corresponding parameter of
+     *    the called method is declared with a nonnull annotation.
+     * 3. An expression for which insufficient nullness information is available for
+     *    statically proving that it will never evaluate to a null value at runtime
+     *    is assigned to a local variable that is declared with a nonnull annotation.
+     *
+     * Insufficient nullness information is usually a consequence of using other unannotated
+     * variables or methods.
+     * 
+     * The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+     * {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+     * shall interpret as nonnull or nullable annotations, respectively.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     * <dl>
+     * Option id: <code>"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo"</code>
+     * Possible values: <code>{ "error", "warning", "ignore" }</code>
+     * Default: <code>"warning"</code>
+     * 
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO = PLUGIN_ID + ".compiler.problem.nullSpecInsufficientInfo";
+</pre></li>
+<li>New Javacore option org.eclipse.jdt.core.JavaCore.COMPILER_PB_REDUNDANT_NULL_ANNOTATION (see bug <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a> for details):
+<pre>
+    /**
+     * Compiler option ID: Reporting Redundant Null Annotations.
+     * 
+     * When enabled, the compiler will issue an error or a warning when a non-null annotation
+     * (see {@link #COMPILER_NONNULL_ANNOTATION_NAME})
+     * is applied although the same effect is already achieved by a default applicable at the
+     * current location. Such default may be effective by enabling the option
+     * {@link #COMPILER_NONNULL_IS_DEFAULT} or by using the annotation specified by the option
+     * {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}.
+     * 
+     * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
+     * 
+     * Option id: <code>"org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation"</code>
+     * Possible values: <code>{ "error", "warning", "ignore" }</code>
+     * Default: <code>"warning"</code>
+     * 
+     * @since 3.8
+     * @category CompilerOptionID
+     */
+    public static final String COMPILER_PB_REDUNDANT_NULL_ANNOTATION = PLUGIN_ID + ".compiler.problem.redundantNullAnnotation";
+</pre>
+</li>
+<li>New API added to org.eclipse.jdt.core.compiler.IProblem to signal null-related issues:
+	<ul>
+	<li> int RequiredNonNullButProvidedNull</li>
+	<li> int RequiredNonNullButProvidedPotentialNull</li>
+	<li> int RequiredNonNullButProvidedUnknown</li>
+	<li> int MissingNullAnnotationType</li>
+	<li> int IllegalReturnNullityRedefinition</li>
+	<li> int IllegalRedefinitionToNonNullParameter</li>
+	<li> int IllegalDefinitionToNonNullParameter</li>
+	<li> int ParameterLackingNonNullAnnotation</li>
+	<li> int ParameterLackingNullableAnnotation</li>
+	<li> int PotentialNullMessageSendReference</li>
+	<li> int RedundantNullCheckOnNonNullMessageSend</li>
+	<li> int CannotImplementIncompatibleNullness</li>
+	<li> int RedundantNullAnnotation</li>
+	<li> int IllegalAnnotationForBaseType</li>
+	</ul>
+</ul>
+
+<h3>Problem Reports Fixed</h3>
+<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342">186342</a>
+[compiler][null] Using annotations for null checking
+
 <a name="v_C22"></a>
 <hr><h1>
 Eclipse Platform Build Notes<br>
 Java development tools core</h1>
-Eclipse SDK 3.8.0 - November 29, 2011 - 3.8.0 M4
+Eclipse SDK 3.8.0 - November 29, 2011
 <br>Project org.eclipse.jdt.core v_C22
 (<a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.jdt.core/?only_with_tag=v_C22">cvs</a>).
 <h2>What's new in this drop</h2>
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
index 077c771..6b2f414 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/core/compiler/IProblem.java
@@ -122,6 +122,20 @@
  *									UnclosedCloseable
  *									UnclosedCloseableAtExit
  *									ExplicitlyClosedAutoCloseable
+ * 								    RequiredNonNullButProvidedNull
+ * 									RequiredNonNullButProvidedPotentialNull
+ * 									RequiredNonNullButProvidedUnknown
+ * 									MissingNullAnnotationType
+ * 									NullAnnotationNameMustBeQualified
+ * 									IllegalReturnNullityRedefinition
+ * 									IllegalRedefinitionToNonNullParameter
+ * 									IllegalDefinitionToNonNullParameter
+ * 									ParameterLackingNonNullAnnotation
+ * 									ParameterLackingNullableAnnotation
+ * 									PotentialNullMessageSendReference
+ * 									RedundantNullCheckOnNonNullMessageSend
+ * 									CannotImplementIncompatibleNullness
+ * 									RedundantNullAnnotation
  *******************************************************************************/
 package org.eclipse.jdt.core.compiler;
 
@@ -1416,6 +1430,38 @@ void setSourceStart(int sourceStart);
 	/** @since 3.8 */
 	int SwitchOnEnumNotBelow15 = TypeRelated + 890;	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=360317
 	/**
+	 * Errors/warnings from annotation based null analysis
+	 */
+	/** @since 3.8 */
+	int RequiredNonNullButProvidedNull = TypeRelated + 910;
+	/** @since 3.8 */
+	int RequiredNonNullButProvidedPotentialNull = TypeRelated + 911;
+	/** @since 3.8 */
+	int RequiredNonNullButProvidedUnknown = TypeRelated + 912;
+	/** @since 3.8 */
+	int MissingNullAnnotationType = ImportRelated + 913;
+	/** @since 3.8 */
+	int IllegalReturnNullityRedefinition = MethodRelated + 914;
+	/** @since 3.8 */
+	int IllegalRedefinitionToNonNullParameter = MethodRelated + 915;
+	/** @since 3.8 */
+	int IllegalDefinitionToNonNullParameter = MethodRelated + 916;
+	/** @since 3.8 */
+	int ParameterLackingNonNullAnnotation = MethodRelated + 917;
+	/** @since 3.8 */
+	int ParameterLackingNullableAnnotation = MethodRelated + 918;
+	/** @since 3.8 */
+	int PotentialNullMessageSendReference = Internal + 919;
+	/** @since 3.8 */
+	int RedundantNullCheckOnNonNullMessageSend = Internal + 920;
+	/** @since 3.8 */
+	int CannotImplementIncompatibleNullness = Internal + 921;
+	/** @since 3.8 */
+	int RedundantNullAnnotation = MethodRelated + 922;
+	/** @since 3.8 */
+	int IllegalAnnotationForBaseType = TypeRelated + 923;
+
+	/**
 	 * External problems -- These are problems defined by other plugins
 	 */
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
index 44a69a0..cbe6196 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/Compiler.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - contribution for bug 337868 - [compiler][model] incomplete support for package-info.java when using SearchableEnvironment
+ *     Stephan Herrmann - contributions for 
+ *     							bug 337868 - [compiler][model] incomplete support for package-info.java when using SearchableEnvironment
+ *     							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler;
 
@@ -695,6 +697,7 @@ public class Compiler implements ITypeRequestor, ProblemSeverities {
 
 		// Switch the current policy and compilation result for this unit to the requested one.
 		for (int i = 0; i < maxUnits; i++) {
+			CompilationResult unitResult = null;
 			try {
 				if (this.options.verbose) {
 					this.out.println(
@@ -707,8 +710,7 @@ public class Compiler implements ITypeRequestor, ProblemSeverities {
 				}
 				// diet parsing for large collection of units
 				CompilationUnitDeclaration parsedUnit;
-				CompilationResult unitResult =
-					new CompilationResult(sourceUnits[i], i, maxUnits, this.options.maxProblemsPerUnit);
+				unitResult = new CompilationResult(sourceUnits[i], i, maxUnits, this.options.maxProblemsPerUnit);
 				long parseStart = System.currentTimeMillis();
 				if (this.totalUnits < this.parseThreshold) {
 					parsedUnit = this.parser.parse(sourceUnits[i], unitResult);
@@ -727,6 +729,11 @@ public class Compiler implements ITypeRequestor, ProblemSeverities {
 				}
 				//} catch (AbortCompilationUnit e) {
 				//	requestor.acceptResult(unitResult.tagAsAccepted());
+			} catch (AbortCompilation a) {
+				// best effort to find a way for reporting this problem:
+				if (a.compilationResult == null)
+					a.compilationResult = unitResult;
+				throw a;
 			} finally {
 				sourceUnits[i] = null; // no longer hold onto the unit
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 892538a..4cedddc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -9,7 +9,9 @@
  *     IBM Corporation - initial API and implementation
  *     Matt McCutchen - partial fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=122995
  *     Karen Moore - fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=207411
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
+ *     							bug 185682 - Increment/decrement operators mark local variables as read
+ *     							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -254,6 +256,11 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	// this is only used for method invocation as the expression inside an expression statement
 	public static final int InsideExpressionStatement = Bit5;
 
+	// for annotation reference, signal if annotation was created from a default:
+	public static final int IsSynthetic = ASTNode.Bit7;
+	// for name reference within a memberValuePair of an annotation:
+	public static final int IsMemberValueReference = ASTNode.Bit15;
+
 	public ASTNode() {
 
 		super();
@@ -601,7 +608,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 					local.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
 					if (length > 0) {
 						annotations = new AnnotationBinding[length];
-						local.setAnnotations(annotations);
+						local.setAnnotations(annotations, scope);
 					}
 					break;
 				default :
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
index 995b093..f6d98fd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
@@ -7,11 +7,15 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
+import java.util.Arrays;
+
 import org.eclipse.jdt.core.compiler.*;
 import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.*;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.codegen.*;
@@ -68,6 +72,61 @@ public abstract class AbstractMethodDeclaration
 	}
 
 	/**
+	 * Materialize a null annotation that has been added from the current default,
+	 * in order to ensure that this annotation will be generated into the .class file, too.
+	 */
+	public void addNullnessAnnotation(ReferenceBinding annotationBinding) {
+		this.annotations = addAnnotation(this, this.annotations, annotationBinding);
+	}
+
+	/**
+	 * Materialize a null parameter annotation that has been added from the current default,
+	 * in order to ensure that this annotation will be generated into the .class file, too.
+	 */
+	public void addParameterNonNullAnnotation(int i, ReferenceBinding annotationBinding) {
+		Argument argument = this.arguments[i];
+		if (argument.type != null) // null happens for constructors of anonymous classes
+			argument.annotations = addAnnotation(argument.type, argument.annotations, annotationBinding);
+	}
+
+	private Annotation[] addAnnotation(ASTNode location, Annotation[] oldAnnotations, ReferenceBinding annotationBinding) {
+		long pos = ((long)location.sourceStart<<32) + location.sourceEnd;
+		long[] poss = new long[annotationBinding.compoundName.length];
+		Arrays.fill(poss, pos);
+		MarkerAnnotation annotation = new MarkerAnnotation(new QualifiedTypeReference(annotationBinding.compoundName, poss), location.sourceStart);
+		annotation.declarationSourceEnd = location.sourceEnd;
+		annotation.resolvedType = annotationBinding;
+		annotation.bits = IsSynthetic;
+		if (oldAnnotations == null) {
+			oldAnnotations = new Annotation[] {annotation};
+		} else {
+			int len = oldAnnotations.length;
+			System.arraycopy(oldAnnotations, 0, oldAnnotations=new Annotation[len+1], 1, len);
+			oldAnnotations[0] = annotation;
+		}
+		return oldAnnotations;
+	}
+
+	/**
+	 * When a method is accessed via SourceTypeBinding.resolveTypesFor(MethodBinding)
+	 * we create the argument binding and resolve annotations in order to compute null annotation tagbits.
+	 */
+	public void createArgumentBindings() {
+		if (this.arguments != null && this.binding != null) {
+			for (int i = 0, length = this.arguments.length; i < length; i++) {
+				Argument argument = this.arguments[i];
+				argument.createBinding(this.scope, this.binding.parameters[i]);
+				// createBinding() has resolved annotations, now transfer nullness info from the argument to the method:
+				if ((argument.binding.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) != 0) {
+					if (this.binding.parameterNonNullness == null)
+						this.binding.parameterNonNullness = new Boolean[this.arguments.length];
+					this.binding.parameterNonNullness[i] = Boolean.valueOf((argument.binding.tagBits & TagBits.AnnotationNonNull) != 0);
+				}
+			}
+		}
+	}
+
+	/**
 	 * Bind and add argument's binding into the scope of the method
 	 */
 	public void bindArguments() {
@@ -143,6 +202,28 @@ public abstract class AbstractMethodDeclaration
 		}
 	}
 
+	/**
+	 * Feed null information from argument annotations into the analysis and mark arguments as assigned.
+	 */
+	void analyseArguments(FlowInfo flowInfo) {
+		if (this.arguments != null) {
+			for (int i = 0, count = this.arguments.length; i < count; i++) {
+				if (this.binding.parameterNonNullness != null) {
+					// leverage null-info from parameter annotations:
+					Boolean nonNullNess = this.binding.parameterNonNullness[i];
+					if (nonNullNess != null) {
+						if (nonNullNess.booleanValue())
+							flowInfo.markAsDefinitelyNonNull(this.arguments[i].binding);
+						else
+							flowInfo.markPotentiallyNullBit(this.arguments[i].binding);
+					}
+				}
+				// tag parameters as being set:
+				flowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);
+			}
+		}
+	}
+
 	public CompilationResult compilationResult() {
 
 		return this.compilationResult;
@@ -415,6 +496,7 @@ public abstract class AbstractMethodDeclaration
 			bindThrownExceptions();
 			resolveJavadoc();
 			resolveAnnotations(this.scope, this.annotations, this.binding);
+			validateAnnotations();
 			resolveStatements();
 			// check @Deprecated annotation presence
 			if (this.binding != null
@@ -478,4 +560,17 @@ public abstract class AbstractMethodDeclaration
 	public TypeParameter[] typeParameters() {
 	    return null;
 	}
+
+	void validateAnnotations() {
+		// null annotations on parameters?
+		if (this.binding != null && this.binding.parameterNonNullness != null) {
+			for (int i=0; i<this.binding.parameters.length; i++) {
+				if (this.binding.parameterNonNullness[i] != null) {
+					long nullAnnotationTagBit =  this.binding.parameterNonNullness[i].booleanValue()
+							? TagBits.AnnotationNonNull : TagBits.AnnotationNullable;
+					this.scope.validateNullAnnotation(nullAnnotationTagBit, this.arguments[i].type, this.arguments[i].annotations);
+				}
+			}
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 6baa903..e811ea9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -7,10 +7,11 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contributions for 
+ *     Stephan Herrmann - Contributions for
  *     						bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
  *     						bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     						bug 349326 - [1.7] new warning for missing try-with-resources
+ * 							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -53,6 +54,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
 			}
 		}
+		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
 	// record some dependency information for exception types
 	ReferenceBinding[] thrownExceptions;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
index d19c24c..bc76ad7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Annotation.java
@@ -7,6 +7,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -173,6 +174,22 @@ public abstract class Annotation extends Expression {
 			case TypeIds.T_JavaxAnnotationPreDestroy :
 				tagBits |= TagBits.AnnotationPreDestroy;
 				break;
+			case TypeIds.T_ConfiguredAnnotationNullable :
+				tagBits |= TagBits.AnnotationNullable;
+				break;
+			case TypeIds.T_ConfiguredAnnotationNonNull :
+				tagBits |= TagBits.AnnotationNonNull;
+				break;
+			case TypeIds.T_ConfiguredAnnotationNonNullByDefault :
+				if (valueAttribute != null 
+					&& valueAttribute.value instanceof FalseLiteral) 
+				{
+					// parameter 'false' means: this annotation cancels any defaults
+					tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
+					break;
+				}
+				tagBits |= TagBits.AnnotationNonNullByDefault;
+				break;
 		}
 		return tagBits;
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
index acad2e6..8b5f9e1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Argument.java
@@ -4,9 +4,10 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -30,7 +31,25 @@ public class Argument extends LocalDeclaration {
 		this.bits |= (IsLocalDeclarationReachable | IsArgument);
 	}
 
+	public void createBinding(MethodScope scope, TypeBinding typeBinding) {
+		if (this.binding == null) {
+			// for default constructors and fake implementation of abstract methods 
+			this.binding = new LocalVariableBinding(this, typeBinding, this.modifiers, true);
+		} else if (!this.binding.type.isValidBinding()) {
+			AbstractMethodDeclaration methodDecl = scope.referenceMethod();
+			if (methodDecl != null) {
+				MethodBinding methodBinding = methodDecl.binding;
+				if (methodBinding != null) {
+					methodBinding.tagBits |= TagBits.HasUnresolvedArguments;
+				}
+			}
+		}
+		resolveAnnotations(scope, this.annotations, this.binding);
+		this.binding.declaration = this;
+	}
+
 	public void bind(MethodScope scope, TypeBinding typeBinding, boolean used) {
+		createBinding(scope, typeBinding); // basically a no-op if createBinding() was called before
 
 		// record the resolved type into the type reference
 		Binding existingVariable = scope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);
@@ -52,22 +71,8 @@ public class Argument extends LocalDeclaration {
 				scope.problemReporter().localVariableHiding(this, existingVariable, isSpecialArgument);
 			}
 		}
-
-		if (this.binding == null) {
-			this.binding = new LocalVariableBinding(this, typeBinding, this.modifiers, true);
-		} else if (!this.binding.type.isValidBinding()) {
-			AbstractMethodDeclaration methodDecl = scope.referenceMethod();
-			if (methodDecl != null) {
-				MethodBinding methodBinding = methodDecl.binding;
-				if (methodBinding != null) {
-					methodBinding.tagBits |= TagBits.HasUnresolvedArguments;
-				}
-			}
-		}
 		scope.addLocalVariable(this.binding);
-		resolveAnnotations(scope, this.annotations, this.binding);
 		//true stand for argument instead of just local
-		this.binding.declaration = this;
 		this.binding.useFlag = used ? LocalVariableBinding.USED : LocalVariableBinding.UNUSED;
 	}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 6a8fa14..970fc24 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -4,15 +4,16 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Genady Beriozkin - added support for reporting assignment with no effect
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  * 							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  * 							bug 292478 - Report potentially null across variable assignment
  *     						bug 335093 - [compiler][null] minimal hook for future null annotation support
  *     						bug 349326 - [1.7] new warning for missing try-with-resources
+ *							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -65,7 +66,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 				FlowContext.CAN_ONLY_NULL | FlowContext.IN_ASSIGNMENT, flowInfo);
 		}
 	}
-	nullStatus = checkAgainstNullAnnotation(currentScope, local, nullStatus);
+	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, local, nullStatus, this.expression);
 	if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(local, nullStatus);
 		if (flowContext.initsOnFinally != null)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
index 8de8919..05659ad 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConstructorDeclaration.java
@@ -7,9 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contributions for 
+ *     Stephan Herrmann - Contributions for
  *     							bug 343713 - [compiler] bogus line number in constructor of inner class in 1.5 compliance
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -113,12 +114,8 @@ public void analyseCode(ClassScope classScope, InitializationFlowContext initial
 			}
 		}
 
-		// tag parameters as being set
-		if (this.arguments != null) {
-			for (int i = 0, count = this.arguments.length; i < count; i++) {
-				flowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);
-			}
-		}
+		// nullity and mark as assigned
+		analyseArguments(flowInfo);
 
 		// propagate to constructor call
 		if (this.constructorCall != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
index a9ce3fc..e521d40 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -23,14 +24,28 @@ public class EqualExpression extends BinaryExpression {
 		super(left,right,operator);
 	}
 	private void checkNullComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse) {
+		int rightStatus = this.right.nullStatus(flowInfo);
+		int leftStatus = this.left.nullStatus(flowInfo);
+		// check if either method is annotated @NonNull and compared to null:
+		if (leftStatus == FlowInfo.NON_NULL && rightStatus == FlowInfo.NULL) {
+			if (this.left instanceof MessageSend) { 
+				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.left).binding, this.left);
+			}
+			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
+		} else if (leftStatus == FlowInfo.NULL && rightStatus == FlowInfo.NON_NULL) {
+			if (this.right instanceof MessageSend) {
+				scope.problemReporter().messageSendRedundantCheckOnNonNull(((MessageSend) this.right).binding, this.right);
+			}
+			// TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326)
+		}
 
 		LocalVariableBinding local = this.left.localVariableBinding();
 		if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, this.right.nullStatus(flowInfo), this.left);
+			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, rightStatus, this.left);
 		}
 		local = this.right.localVariableBinding();
 		if (local != null && (local.type.tagBits & TagBits.IsBaseType) == 0) {
-			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, this.left.nullStatus(flowInfo), this.right);
+			checkVariableComparison(scope, flowContext, flowInfo, initsWhenTrue, initsWhenFalse, local, leftStatus, this.right);
 		}
 	}
 	private void checkVariableComparison(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo, FlowInfo initsWhenTrue, FlowInfo initsWhenFalse, LocalVariableBinding local, int nullStatus, Expression reference) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index ba2219f..3f4a46a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *     Stephan Herrmann - Contributions for
+ *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -81,6 +83,7 @@ public class ExplicitConstructorCall extends Statement implements InvocationSite
 						this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
 					}
 				}
+				analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 			}
 
 			ReferenceBinding[] thrownExceptions;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
index 2d0066b..dac029c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
@@ -7,11 +7,12 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
- *     						bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
- *     						bug 292478 - Report potentially null across variable assignment
- *     						bug 335093 - [compiler][null] minimal hook for future null annotation support
- *     						bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *							bug 292478 - Report potentially null across variable assignment
+ *							bug 335093 - [compiler][null] minimal hook for future null annotation support
+ *							bug 349326 - [1.7] new warning for missing try-with-resources
+ *							bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -85,7 +86,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		this.bits &= ~FirstAssignmentToLocal;  // int i = (i = 0);
 	}
 	flowInfo.markAsDefinitelyAssigned(this.binding);
-	nullStatus = checkAgainstNullAnnotation(currentScope, this.binding, nullStatus);		
+	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, this.binding, nullStatus, this.initialization);
 	if ((this.binding.type.tagBits & TagBits.IsBaseType) == 0) {
 		flowInfo.markNullStatus(this.binding, nullStatus);
 		// no need to inform enclosing try block since its locals won't get
@@ -250,6 +251,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		}
 		// only resolve annotation at the end, for constant to be positioned before (96991)
 		resolveAnnotations(scope, this.annotations, this.binding);
+		scope.validateNullAnnotation(this.binding.tagBits, this.type, this.annotations);
 	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
index a083742..0902e21 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MemberValuePair.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -41,6 +42,9 @@ public class MemberValuePair extends ASTNode {
 		if (value instanceof ArrayInitializer) {
 			value.bits |= IsAnnotationDefaultValue;
 		}
+		if (value instanceof NameReference) {
+			value.bits |= IsMemberValueReference;
+		}
 	}
 
 	/* (non-Javadoc)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 795a345..59a7ecd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -9,8 +9,9 @@
  *     IBM Corporation - initial API and implementation
  *     Nick Teryaev - fix for bug (https://bugs.eclipse.org/bugs/show_bug.cgi?id=40752)
  *     Stephan Herrmann - Contributions for
- *     	 						bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
- *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -99,6 +100,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 			flowInfo = FakedTrackingVariable.markPassedToOutside(currentScope, this.arguments[i], flowInfo);
 			flowInfo = this.arguments[i].analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
 		}
+		analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 	}
 	ReferenceBinding[] thrownExceptions;
 	if ((thrownExceptions = this.binding.thrownExceptions) != Binding.NO_EXCEPTIONS) {
@@ -115,6 +117,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	manageSyntheticAccessIfNecessary(currentScope, flowInfo);
 	return flowInfo;
 }
+public void checkNPE(BlockScope scope, FlowContext flowContext, FlowInfo flowInfo) {
+	super.checkNPE(scope, flowContext, flowInfo);
+	if (nullStatus(flowInfo) == FlowInfo.POTENTIALLY_NULL)
+		scope.problemReporter().messageSendPotentialNullReference(this.binding, this);
+}
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
  */
@@ -268,9 +275,16 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 	}
 }
 public int nullStatus(FlowInfo flowInfo) {
+	if (this.binding.isValidBinding()) {
+		// try to retrieve null status of this message send from an annotation of the called method:
+		long tagBits = this.binding.tagBits;
+		if ((tagBits & TagBits.AnnotationNonNull) != 0)
+			return FlowInfo.NON_NULL;
+		if ((tagBits & TagBits.AnnotationNullable) != 0)
+			return FlowInfo.POTENTIALLY_NULL;
+	}
 	return FlowInfo.UNKNOWN;
 }
-
 /**
  * @see org.eclipse.jdt.internal.compiler.ast.Expression#postConversionType(Scope)
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
index 5a5c24c..6cbc638 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MethodDeclaration.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann - Contributions for
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -79,10 +81,11 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 					this.scope,
 					FlowInfo.DEAD_END);
 
-			// tag parameters as being set
+			// nullity and mark as assigned
+			analyseArguments(flowInfo);
+
 			if (this.arguments != null) {
 				for (int i = 0, count = this.arguments.length; i < count; i++) {
-					flowInfo.markAsDefinitelyAssigned(this.arguments[i].binding);
 					// if this method uses a type parameter declared by the declaring class,
 					// it can't be static. https://bugs.eclipse.org/bugs/show_bug.cgi?id=318682
 					if (this.arguments[i].binding != null && (this.arguments[i].binding.type instanceof TypeVariableBinding)) {
@@ -307,4 +310,11 @@ public class MethodDeclaration extends AbstractMethodDeclaration {
 	public TypeParameter[] typeParameters() {
 	    return this.typeParameters;
 	}
+	
+	void validateAnnotations() {
+		super.validateAnnotations();
+		// null-annotations on the return type?
+		if (this.binding != null)
+			this.scope.validateNullAnnotation(this.binding.tagBits, this.returnType, this.annotations);
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 93bf5b5..3a2a0ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -86,6 +87,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					this.arguments[i].checkNPE(currentScope, flowContext, flowInfo);
 				}
 			}
+			analyseArguments(currentScope, flowContext, flowInfo, this.binding, this.arguments);
 		}
 
 		// analyse the anonymous nested type
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
index 1b4a530..330cafd 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contribution for bug 185682 - Increment/decrement operators mark local variables as read
+ *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
+ *     							bug 185682 - Increment/decrement operators mark local variables as read
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -963,7 +965,11 @@ public TypeBinding resolveType(BlockScope scope) {
 							&& methodScope.lastVisibleFieldID >= 0
 							&& fieldBinding.id >= methodScope.lastVisibleFieldID
 							&& (!fieldBinding.isStatic() || methodScope.isStatic)) {
-						scope.problemReporter().forwardReference(this, this.indexOfFirstFieldBinding-1, fieldBinding);
+						if ((this.bits & IsMemberValueReference) != 0 && fieldBinding.id == methodScope.lastVisibleFieldID) {
+							// false alarm, location is NOT a field initializer but the value in a memberValuePair
+						} else {
+							scope.problemReporter().forwardReference(this, this.indexOfFirstFieldBinding-1, fieldBinding);
+						}
 					}
 					if (isFieldUseDeprecated(fieldBinding, scope, this.indexOfFirstFieldBinding == this.tokens.length ? this.bits : 0)) {
 						scope.problemReporter().deprecatedField(fieldBinding, this);	
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
index 520cf38..57f4d89 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java
@@ -7,10 +7,11 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contributions for 
+ *     Stephan Herrmann - Contributions for
  *     							bug 319201 - [null] no warning when unboxing SingleNameReference causes NPE
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *     							bug 360328 - [compiler][null] detect null problems in nested code (local class inside a loop)
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -44,6 +45,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 		if ((this.expression.implicitConversion & TypeIds.UNBOXING) != 0) {
 			this.expression.checkNPE(currentScope, flowContext, flowInfo);
 		}
+		if (flowInfo.reachMode() == FlowInfo.REACHABLE)
+			checkAgainstNullAnnotation(currentScope, this.expression.nullStatus(flowInfo));
 		FakedTrackingVariable trackingVariable = FakedTrackingVariable.getCloseTrackingVariable(this.expression);
 		if (trackingVariable != null) {
 			if (methodScope != trackingVariable.methodScope)
@@ -119,6 +122,23 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, Fl
 	currentScope.checkUnclosedCloseables(flowInfo, this, currentScope);
 	return FlowInfo.DEAD_END;
 }
+void checkAgainstNullAnnotation(BlockScope scope, int nullStatus) {
+	if (nullStatus != FlowInfo.NON_NULL) {
+		// if we can't prove non-null check against declared null-ness of the enclosing method:
+		long tagBits;
+		MethodBinding methodBinding;
+		try {
+			methodBinding = scope.methodScope().referenceMethod().binding;
+			tagBits = methodBinding.tagBits;
+		} catch (NullPointerException npe) {
+			return;
+		}
+		if ((tagBits & TagBits.AnnotationNonNull) != 0) {
+			char[][] annotationName = scope.environment().getNonNullAnnotationName();
+			scope.problemReporter().nullityMismatch(this.expression, methodBinding.returnType, nullStatus, annotationName);
+		}
+	}
+}
 
 /**
  * Retrun statement code generation
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
index c723aff..073ecc1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java
@@ -7,9 +7,10 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contributions for 
+ *     Stephan Herrmann - Contributions for
  *     							bug 335093 - [compiler][null] minimal hook for future null annotation support
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.ast;
 
@@ -57,8 +58,34 @@ public abstract FlowInfo analyseCode(BlockScope currentScope, FlowContext flowCo
 	public static final int COMPLAINED_FAKE_REACHABLE = 1;
 	public static final int COMPLAINED_UNREACHABLE = 2;
 	
-/** Empty hook for checking null status against declaration using null annotations, once this will be supported. */
-protected int checkAgainstNullAnnotation(BlockScope currentScope, LocalVariableBinding local, int nullStatus) {
+
+/** Analysing arguments of MessageSend, ExplicitConstructorCall, AllocationExpression. */
+protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)
+{
+	// compare actual null-status against parameter annotations of the called method:
+	if (arguments != null && methodBinding.parameterNonNullness != null) {
+		for (int i = 0; i < arguments.length; i++) {
+			if (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
+				TypeBinding expectedType = methodBinding.parameters[i];
+				Expression argument = arguments[i];
+				int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
+				if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
+					flowContext.recordNullityMismatch(currentScope, argument, nullStatus, expectedType);
+			}
+		}
+	}
+}
+
+/** Check null-ness of 'local' against a possible null annotation */
+protected int checkAssignmentAgainstNullAnnotation(BlockScope currentScope, FlowContext flowContext,
+												   LocalVariableBinding local, int nullStatus, Expression expression)
+{
+	if (local != null
+			&& (local.tagBits & TagBits.AnnotationNonNull) != 0
+			&& nullStatus != FlowInfo.NON_NULL) {
+		flowContext.recordNullityMismatch(currentScope, expression, nullStatus, local.type);
+		nullStatus=FlowInfo.NON_NULL;
+	}
 	return nullStatus;
 }
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
index 26da081..3cd62b0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfo.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -270,6 +271,9 @@ public int getModifiers() {
 public IBinaryAnnotation[] getParameterAnnotations(int index) {
 	return null;
 }
+public int getNumParameterAnnotations() {
+	return 0;
+}
 /**
  * Answer the name of the method.
  *
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
index 9d871b1..2aad9f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/MethodInfoWithParameterAnnotations.java
@@ -8,6 +8,7 @@
  * Contributors:
  *    tyeung@bea.com  - initial API and implementation
  *    IBM Corporation - fix for bug 342757
+ *    Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.classfmt;
 
@@ -36,6 +37,9 @@ MethodInfoWithParameterAnnotations(MethodInfo methodInfo, AnnotationInfo[] annot
 public IBinaryAnnotation[] getParameterAnnotations(int index) {
 	return this.parameterAnnotations[index];
 }
+public int getNumParameterAnnotations() {
+	return this.parameterAnnotations == null ? 0 : this.parameterAnnotations.length;
+}
 protected void initialize() {
 	for (int i = 0, l = this.parameterAnnotations == null ? 0 : this.parameterAnnotations.length; i < l; i++) {
 		AnnotationInfo[] infos = this.parameterAnnotations[i];
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
index d75686b..68b63f6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/env/IBinaryMethod.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.env;
 
@@ -66,6 +67,13 @@ char[] getMethodDescriptor();
 IBinaryAnnotation[] getParameterAnnotations(int index);
 
 /**
+ * Answer the number of parameter annotations that can be retrieved
+ * using {@link #getParameterAnnotations(int)}.
+ * @return one beyond the highest legal argument to {@link #getParameterAnnotations(int)}.
+ */
+int getNumParameterAnnotations();
+
+/**
  * Answer the name of the method.
  *
  * For a constructor, answer <init> & <clinit> for a clinit method.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
index 7f7638d..d148222 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FinallyFlowContext.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -17,6 +18,7 @@ import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 
@@ -83,8 +85,13 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 	// check inconsistent null checks
 	if ((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0) { // within an enclosing loop, be conservative
 		for (int i = 0; i < this.nullCount; i++) {
-			this.parent.recordUsingNullReference(scope, this.nullLocals[i],
-					this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
+			if (this.nullCheckTypes[i] == ASSIGN_TO_NONNULL)
+				this.parent.recordNullityMismatch(scope, this.nullReferences[i],
+						flowInfo.nullStatus(this.nullLocals[i]), this.expectedTypes[i]);
+			else
+				this.parent.recordUsingNullReference(scope, this.nullLocals[i],
+						this.nullReferences[i],	this.nullCheckTypes[i], flowInfo);
+
 		}
 	}
 	else { // no enclosing loop, be as precise as possible right now
@@ -167,6 +174,13 @@ public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
 						scope.problemReporter().localVariablePotentialNullReference(local, expression);
 					}
 					break;
+				case ASSIGN_TO_NONNULL:
+					int nullStatus = flowInfo.nullStatus(local);
+					if (nullStatus != FlowInfo.NON_NULL) {
+						char[][] annotationName = scope.environment().getNonNullAnnotationName();
+						scope.problemReporter().nullityMismatch(expression, this.expectedTypes[i], nullStatus, annotationName);
+					}
+					break;
 				default:
 					// should not happen
 			}
@@ -442,4 +456,14 @@ protected void recordNullReference(LocalVariableBinding local,
 	this.nullReferences[this.nullCount] = expression;
 	this.nullCheckTypes[this.nullCount++] = status;
 }
+protected boolean internalRecordNullityMismatch(Expression expression, int nullStatus, TypeBinding expectedType, int checkType) {
+	// cf. decision structure inside FinallyFlowContext.recordUsingNullReference(..)
+	if (nullStatus == FlowInfo.UNKNOWN ||
+			((this.tagBits & FlowContext.DEFER_NULL_DIAGNOSTIC) != 0 && nullStatus != FlowInfo.NULL)) {
+		recordExpectedType(expectedType, this.nullCount);
+		recordNullReference(expression.localVariableBinding(), expression, checkType);
+		return true;
+	}
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
index ccb5fb6..7df8a71 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
@@ -4,10 +4,12 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 358827 - [1.7] exception analysis for t-w-r spoils null analysis
+ *     Stephan Herrmann - Contributions for
+ *     							bug 358827 - [1.7] exception analysis for t-w-r spoils null analysis
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
@@ -52,6 +54,10 @@ public class FlowContext implements TypeConstants {
 		// any null related operation happening within the try block
 
 	public int tagBits;
+
+	// array to store the expected type from the potential error location (for display in error messages):
+	public TypeBinding[] expectedTypes = null;
+
 	public static final int DEFER_NULL_DIAGNOSTIC = 0x1;
 	public static final int PREEMPT_NULL_DIAGNOSTIC = 0x2;
 	/**
@@ -66,6 +72,8 @@ public static final int CAN_ONLY_NULL = 0x0001;
 public static final int CAN_ONLY_NON_NULL = 0x0002;
 //check against non null, with definite values -- comparisons
 public static final int MAY_NULL = 0x0003;
+//check binding a value to a @NonNull variable 
+public final static int ASSIGN_TO_NONNULL = 0x0080;
 // check against null, with potential values -- NPE guard
 public static final int CHECK_MASK = 0x00FF;
 public static final int IN_COMPARISON_NULL = 0x0100;
@@ -548,6 +556,21 @@ public void recordContinueFrom(FlowContext innerFlowContext, FlowInfo flowInfo)
 	// default implementation: do nothing
 }
 
+protected void recordExpectedType(TypeBinding expectedType, int nullCount) {
+	if (nullCount == 0) {
+		this.expectedTypes = new TypeBinding[5];
+	} else if (this.expectedTypes == null) {
+		int size = 5;
+		while (size <= nullCount) size *= 2;
+		this.expectedTypes = new TypeBinding[size];
+	}
+	else if (nullCount == this.expectedTypes.length) {
+		System.arraycopy(this.expectedTypes, 0,
+			this.expectedTypes = new TypeBinding[nullCount * 2], 0, nullCount);
+	}
+	this.expectedTypes[nullCount] = expectedType;
+}
+
 protected boolean recordFinalAssignment(VariableBinding variable, Reference finalReference) {
 	return true; // keep going
 }
@@ -746,4 +769,31 @@ public String toString() {
 	buffer.append(individualToString()).append('\n');
 	return buffer.toString();
 }
+
+/**
+ * Record that a nullity mismatch was detected against an annotated type reference.
+ * @param currentScope scope for error reporting
+ * @param expression the expression violating the specification
+ * @param nullStatus the null status of expression at the current location
+ * @param expectedType the declared type of the spec'ed variable, for error reporting.
+ */
+public void recordNullityMismatch(BlockScope currentScope, Expression expression, int nullStatus, TypeBinding expectedType) {
+	if (expression.localVariableBinding() != null) { // flowContext cannot yet handle non-localvar expressions (e.g., fields)
+		// find the inner-most flowContext that might need deferred handling:
+		FlowContext currentContext = this;
+		while (currentContext != null) {
+			// some flow contexts implement deferred checking, should we participate in that?
+			if (currentContext.internalRecordNullityMismatch(expression, nullStatus, expectedType, ASSIGN_TO_NONNULL))
+				return;
+			currentContext = currentContext.parent;
+		}
+	}
+	// no reason to defer, so report now:
+	char[][] annotationName = currentScope.environment().getNonNullAnnotationName();
+	currentScope.problemReporter().nullityMismatch(expression, expectedType, nullStatus, annotationName);
+}
+protected boolean internalRecordNullityMismatch(Expression expression, int nullStatus, TypeBinding expectedType, int checkType) {
+	// nop, to be overridden in subclasses
+	return false; // not recorded
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
index 919bb4c..38295c8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
@@ -7,11 +7,14 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - contribution for Bug 336428 - [compiler][null] bogus warning "redundant null check" in condition of do {} while() loop
+ *     Stephan Herrmann - contributions for
+ *     							bug 336428 - [compiler][null] bogus warning "redundant null check" in condition of do {} while() loop
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
 import java.util.ArrayList;
+
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Reference;
@@ -21,6 +24,7 @@ import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 
@@ -246,6 +250,9 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						continue;
 					}
 					break;
+				case ASSIGN_TO_NONNULL:
+					this.parent.recordNullityMismatch(scope, expression, flowInfo.nullStatus(local), this.expectedTypes[i]);
+					break;
 				default:
 					// never happens
 			}
@@ -339,6 +346,13 @@ public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo callerFlowIn
 						continue;
 					}
 					break;
+				case ASSIGN_TO_NONNULL:
+					int nullStatus = flowInfo.nullStatus(local);
+					if (nullStatus != FlowInfo.NON_NULL) {
+						char[][] annotationName = scope.environment().getNonNullAnnotationName();
+						scope.problemReporter().nullityMismatch(expression, this.expectedTypes[i], nullStatus, annotationName);
+					}
+					break;
 				default:
 					// never happens
 			}
@@ -667,4 +681,10 @@ public void recordUsingNullReference(Scope scope, LocalVariableBinding local,
 	public boolean hasEscapingExceptions() {
 		return this.escapingExceptionCatchSites != null;
 	}
+
+	protected boolean internalRecordNullityMismatch(Expression expression, int nullStatus, TypeBinding expectedType, int checkType) {
+		recordExpectedType(expectedType, this.nullCount);
+		recordNullReference(expression.localVariableBinding(), expression, checkType);
+		return true;
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
index b269d89..0ac09c9 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java
@@ -12,6 +12,7 @@
  *     							bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
  *     							bug 295551 - Add option to automatically promote all warnings to errors
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.impl;
 
@@ -26,6 +27,7 @@ import org.eclipse.jdt.internal.compiler.Compiler;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
+import org.eclipse.jdt.internal.compiler.lookup.TagBits;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -142,6 +144,19 @@ public class CompilerOptions {
 	public static final String OPTION_ReportUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.unclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportPotentiallyUnclosedCloseable = "org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable"; //$NON-NLS-1$
 	public static final String OPTION_ReportExplicitlyClosedAutoCloseable = "org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
+	public static final String OPTION_ReportNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.nullSpecViolation";  //$NON-NLS-1$
+	public static final String OPTION_ReportPotentialNullSpecViolation = "org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation";  //$NON-NLS-1$
+	public static final String OPTION_ReportNullSpecInsufficientInfo = "org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo";  //$NON-NLS-1$
+	public static final String OPTION_ReportRedundantNullAnnotation = "org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation";  //$NON-NLS-1$
+	public static final String OPTION_AnnotationBasedNullAnalysis = "org.eclipse.jdt.core.compiler.annotation.nullanalysis"; //$NON-NLS-1$
+	public static final String OPTION_NullableAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nullable"; //$NON-NLS-1$
+	public static final String OPTION_NonNullAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnull"; //$NON-NLS-1$
+	public static final String OPTION_NonNullByDefaultAnnotationName = "org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"; //$NON-NLS-1$
+	// defaults for the above:
+	static final char[][] DEFAULT_NULLABLE_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.Nullable".toCharArray()); //$NON-NLS-1$
+	static final char[][] DEFAULT_NONNULL_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNull".toCharArray()); //$NON-NLS-1$
+	static final char[][] DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME = CharOperation.splitOn('.', "org.eclipse.jdt.annotation.NonNullByDefault".toCharArray()); //$NON-NLS-1$
+	public static final String OPTION_NonNullIsDefault = "org.eclipse.jdt.core.compiler.annotation.nonnullisdefault";  //$NON-NLS-1$
 	/**
 	 * Possible values for configurable options
 	 */
@@ -245,10 +260,13 @@ public class CompilerOptions {
 	public static final int MethodCanBeStatic = IrritantSet.GROUP2 | ASTNode.Bit5;
 	public static final int MethodCanBePotentiallyStatic = IrritantSet.GROUP2 | ASTNode.Bit6;
 	public static final int RedundantSpecificationOfTypeArguments = IrritantSet.GROUP2 | ASTNode.Bit7;
-	// bits 8-10 reserved for https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342
-	public static final int UnclosedCloseable = IrritantSet.GROUP2 | ASTNode.Bit11;
-	public static final int PotentiallyUnclosedCloseable = IrritantSet.GROUP2 | ASTNode.Bit12;
-	public static final int ExplicitlyClosedAutoCloseable = IrritantSet.GROUP2 | ASTNode.Bit13;
+	public static final int UnclosedCloseable = IrritantSet.GROUP2 | ASTNode.Bit8;
+	public static final int PotentiallyUnclosedCloseable = IrritantSet.GROUP2 | ASTNode.Bit9;
+	public static final int ExplicitlyClosedAutoCloseable = IrritantSet.GROUP2 | ASTNode.Bit10;
+	public static final int NullSpecViolation = IrritantSet.GROUP2 | ASTNode.Bit11;
+	public static final int PotentialNullSpecViolation = IrritantSet.GROUP2 | ASTNode.Bit12;
+	public static final int NullSpecInsufficientInfo = IrritantSet.GROUP2 | ASTNode.Bit13;
+	public static final int RedundantNullAnnotation = IrritantSet.GROUP2 | ASTNode.Bit14;
 
 	// Severity level for handlers
 	/** 
@@ -371,6 +389,18 @@ public class CompilerOptions {
 	/** Controls whether forced generic type problems get reported  */
 	public boolean reportUnavoidableGenericTypeProblems;
 
+	// === Support for Null Annotations: ===
+	/** Master switch for null analysis based on annotations: */
+	public boolean isAnnotationBasedNullAnalysisEnabled;
+	/** Fully qualified name of annotation to use as marker for nullable types. */
+	public char[][] nullableAnnotationName;
+	/** Fully qualified name of annotation to use as marker for nonnull types. */
+	public char[][] nonNullAnnotationName;
+	/** Fully qualified name of annotation to use as marker for default nonnull. */
+	public char[][] nonNullByDefaultAnnotationName;
+	/** TagBits-encoded default for non-annotated types. */
+	public long defaultNonNullness; // 0 or TagBits#AnnotationNonNull
+
 	// keep in sync with warningTokenToIrritant and warningTokenFromIrritant
 	public final static String[] warningTokens = {
 		"all", //$NON-NLS-1$
@@ -567,6 +597,14 @@ public class CompilerOptions {
 				return OPTION_ReportPotentiallyUnclosedCloseable;
 			case ExplicitlyClosedAutoCloseable :
 				return OPTION_ReportExplicitlyClosedAutoCloseable;
+			case NullSpecViolation :
+				return OPTION_ReportNullSpecViolation;
+			case PotentialNullSpecViolation :
+				return OPTION_ReportPotentialNullSpecViolation;
+			case NullSpecInsufficientInfo :
+				return OPTION_ReportNullSpecInsufficientInfo;
+			case RedundantNullAnnotation :
+				return OPTION_ReportRedundantNullAnnotation;
 		}
 		return null;
 	}
@@ -733,6 +771,14 @@ public class CompilerOptions {
 			OPTION_ReportUnclosedCloseable,
 			OPTION_ReportPotentiallyUnclosedCloseable,
 			OPTION_ReportExplicitlyClosedAutoCloseable,
+			OPTION_AnnotationBasedNullAnalysis,
+			OPTION_NonNullAnnotationName,
+			OPTION_NullableAnnotationName,
+			OPTION_NonNullByDefaultAnnotationName,
+			OPTION_NonNullIsDefault,
+			OPTION_ReportNullSpecViolation,
+			OPTION_ReportPotentialNullSpecViolation,
+			OPTION_ReportRedundantNullAnnotation
 		};
 		return result;
 	}
@@ -795,6 +841,10 @@ public class CompilerOptions {
 			case NullReference :
 			case PotentialNullReference :
 			case RedundantNullCheck :
+			case NullSpecViolation :
+			case PotentialNullSpecViolation :
+			case NullSpecInsufficientInfo :
+			case RedundantNullAnnotation :
 				return "null"; //$NON-NLS-1$
 			case FallthroughCase :
 				return "fallthrough"; //$NON-NLS-1$
@@ -1008,6 +1058,18 @@ public class CompilerOptions {
 		optionsMap.put(OPTION_ReportUnclosedCloseable, getSeverityString(UnclosedCloseable));
 		optionsMap.put(OPTION_ReportPotentiallyUnclosedCloseable, getSeverityString(PotentiallyUnclosedCloseable));
 		optionsMap.put(OPTION_ReportExplicitlyClosedAutoCloseable, getSeverityString(ExplicitlyClosedAutoCloseable));
+		optionsMap.put(OPTION_AnnotationBasedNullAnalysis, this.isAnnotationBasedNullAnalysisEnabled ? ENABLED : DISABLED);
+		optionsMap.put(OPTION_ReportNullSpecViolation, getSeverityString(NullSpecViolation));
+		optionsMap.put(OPTION_ReportPotentialNullSpecViolation, getSeverityString(PotentialNullSpecViolation));
+		optionsMap.put(OPTION_ReportNullSpecInsufficientInfo, getSeverityString(NullSpecInsufficientInfo));
+		optionsMap.put(OPTION_ReportRedundantNullAnnotation, getSeverityString(RedundantNullAnnotation));
+		optionsMap.put(OPTION_NullableAnnotationName, String.valueOf(CharOperation.concatWith(this.nullableAnnotationName, '.')));
+		optionsMap.put(OPTION_NonNullAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullAnnotationName, '.')));
+		optionsMap.put(OPTION_NonNullByDefaultAnnotationName, String.valueOf(CharOperation.concatWith(this.nonNullByDefaultAnnotationName, '.')));
+		if (this.defaultNonNullness == TagBits.AnnotationNonNull)
+			optionsMap.put(OPTION_NonNullIsDefault, CompilerOptions.ENABLED);
+		else
+			optionsMap.put(OPTION_NonNullIsDefault, CompilerOptions.DISABLED);
 		return optionsMap;
 	}
 
@@ -1158,6 +1220,11 @@ public class CompilerOptions {
 		
 		// allow null info from asserts to be considered downstream by default
 		this.includeNullInfoFromAsserts = false;
+		
+		this.isAnnotationBasedNullAnalysisEnabled = false;
+		this.nullableAnnotationName = DEFAULT_NULLABLE_ANNOTATION_NAME;
+		this.nonNullAnnotationName = DEFAULT_NONNULL_ANNOTATION_NAME;
+		this.nonNullByDefaultAnnotationName = DEFAULT_NONNULLBYDEFAULT_ANNOTATION_NAME;
 	}
 
 	public void set(Map optionsMap) {
@@ -1441,6 +1508,39 @@ public class CompilerOptions {
 		if ((optionValue = optionsMap.get(OPTION_ReportUnclosedCloseable)) != null) updateSeverity(UnclosedCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportPotentiallyUnclosedCloseable)) != null) updateSeverity(PotentiallyUnclosedCloseable, optionValue);
 		if ((optionValue = optionsMap.get(OPTION_ReportExplicitlyClosedAutoCloseable)) != null) updateSeverity(ExplicitlyClosedAutoCloseable, optionValue);
+		if ((optionValue = optionsMap.get(OPTION_AnnotationBasedNullAnalysis)) != null) {
+			this.isAnnotationBasedNullAnalysisEnabled = ENABLED.equals(optionValue);
+		}
+		if (this.isAnnotationBasedNullAnalysisEnabled) {
+			if ((optionValue = optionsMap.get(OPTION_ReportNullSpecViolation)) != null) {
+				if (ERROR.equals(optionValue)) {
+					this.errorThreshold.set(NullSpecViolation);
+					this.warningThreshold.clear(NullSpecViolation);
+				} else if (WARNING.equals(optionValue)) {
+					this.errorThreshold.clear(NullSpecViolation);
+					this.warningThreshold.set(NullSpecViolation);
+				}
+				// "ignore" is not valid for this option
+			}
+			if ((optionValue = optionsMap.get(OPTION_ReportPotentialNullSpecViolation)) != null) updateSeverity(PotentialNullSpecViolation, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_ReportNullSpecInsufficientInfo)) != null) updateSeverity(NullSpecInsufficientInfo, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_ReportRedundantNullAnnotation)) != null) updateSeverity(RedundantNullAnnotation, optionValue);
+			if ((optionValue = optionsMap.get(OPTION_NullableAnnotationName)) != null) {
+				this.nullableAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+			}
+			if ((optionValue = optionsMap.get(OPTION_NonNullAnnotationName)) != null) {
+				this.nonNullAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+			}
+			if ((optionValue = optionsMap.get(OPTION_NonNullByDefaultAnnotationName)) != null) {
+				this.nonNullByDefaultAnnotationName = CharOperation.splitAndTrimOn('.', ((String)optionValue).toCharArray());
+			}
+			if ((optionValue = optionsMap.get(OPTION_NonNullIsDefault)) != null) {
+				if (CompilerOptions.ENABLED.equals(optionValue))
+					this.defaultNonNullness = TagBits.AnnotationNonNull;
+				else if (CompilerOptions.DISABLED.equals(optionValue))
+					this.defaultNonNullness = 0;
+			}
+		}
 
 		// Javadoc options
 		if ((optionValue = optionsMap.get(OPTION_DocCommentSupport)) != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
index 38dd14f..e8ae215 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/IrritantSet.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann - Contributions for
+ *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 
 package org.eclipse.jdt.internal.compiler.impl;
@@ -102,8 +104,14 @@ public class IrritantSet {
 			.set(
 				CompilerOptions.DeadCode
 				|CompilerOptions.Tasks
-				|CompilerOptions.UnclosedCloseable);
-			
+				|CompilerOptions.UnclosedCloseable
+				|CompilerOptions.NullSpecInsufficientInfo
+				|CompilerOptions.RedundantNullAnnotation);
+		// default errors IF AnnotationBasedNullAnalysis is enabled:
+		COMPILER_DEFAULT_ERRORS.set(
+				CompilerOptions.NullSpecViolation
+				|CompilerOptions.PotentialNullSpecViolation);
+
 		ALL.setAll();
 		HIDING
 			.set(CompilerOptions.FieldHiding)
@@ -111,7 +119,12 @@ public class IrritantSet {
 			.set(CompilerOptions.TypeHiding);
 		NULL
 			.set(CompilerOptions.PotentialNullReference)
-			.set(CompilerOptions.RedundantNullCheck);
+			.set(CompilerOptions.RedundantNullCheck)
+			.set(CompilerOptions.NullSpecViolation)
+			.set(CompilerOptions.PotentialNullSpecViolation)
+			.set(CompilerOptions.NullSpecInsufficientInfo)
+			.set(CompilerOptions.RedundantNullAnnotation);
+
 		RESTRICTION.set(CompilerOptions.DiscouragedReference);
 		STATIC_ACCESS.set(CompilerOptions.NonStaticAccessToStatic);
 		UNUSED
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
index b8581e3..4a1bad4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann - Contributions for
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -16,9 +18,11 @@ import java.util.ArrayList;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.*;
+import org.eclipse.jdt.internal.compiler.impl.BooleanConstant;
 import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
+import org.eclipse.jdt.internal.compiler.util.Util;
 
 /*
 Not all fields defined by this type are initialized when it is created.
@@ -383,6 +387,8 @@ void cachePartsFrom(IBinaryType binaryType, boolean needFieldsAndMethods) {
 		}
 		if (this.environment.globalOptions.storeAnnotations)
 			setAnnotations(createAnnotations(binaryType.getAnnotations(), this.environment, missingTypeNames));
+
+		scanTypeForNullAnnotation(binaryType);
 	} finally {
 		// protect against incorrect use of the needFieldsAndMethods flag, see 48459
 		if (this.fields == null)
@@ -589,6 +595,9 @@ private MethodBinding createMethod(IBinaryMethod method, long sourceLevel, char[
 	// fixup the declaring element of the type variable
 	for (int i = 0, length = typeVars.length; i < length; i++)
 		typeVars[i].declaringElement = result;
+
+	scanMethodForNullAnnotation(method, result);
+
 	return result;
 }
 
@@ -1142,6 +1151,105 @@ SimpleLookupTable storedAnnotations(boolean forceInitialize) {
 	}
 	return this.storedAnnotations;
 }
+void scanMethodForNullAnnotation(IBinaryMethod method, MethodBinding methodBinding) {
+	if (!this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
+		return;
+	char[][] nullableAnnotationName = this.environment.getNullableAnnotationName();
+	char[][] nonNullAnnotationName = this.environment.getNonNullAnnotationName();
+	if (nullableAnnotationName == null || nonNullAnnotationName == null)
+		return; // not well-configured to use null annotations
+
+	// return:
+	IBinaryAnnotation[] annotations = method.getAnnotations();
+	if (annotations != null) {
+		for (int i = 0; i < annotations.length; i++) {
+			char[] annotationTypeName = annotations[i].getTypeName();
+			if (annotationTypeName[0] != Util.C_RESOLVED)
+				continue;
+			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+			if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+				methodBinding.tagBits |= TagBits.AnnotationNonNull;
+				break;
+			}
+			if (CharOperation.equals(typeName, nullableAnnotationName)) {
+				methodBinding.tagBits |= TagBits.AnnotationNullable;
+				break;
+			}
+		}
+	}
+
+	// parameters:
+	TypeBinding[] parameters = methodBinding.parameters;
+	int numVisibleParams = parameters.length;
+	int numParamAnnotations = method.getNumParameterAnnotations();
+	if (numParamAnnotations > 0) {
+		int startIndex = numParamAnnotations - numVisibleParams;
+		for (int j = 0; j < numVisibleParams; j++) {
+			IBinaryAnnotation[] paramAnnotations = method.getParameterAnnotations(j+startIndex);
+			if (paramAnnotations != null) {
+				for (int i = 0; i < paramAnnotations.length; i++) {
+					char[] annotationTypeName = paramAnnotations[i].getTypeName();
+					if (annotationTypeName[0] != Util.C_RESOLVED)
+						continue;
+					char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+					if (CharOperation.equals(typeName, nonNullAnnotationName)) {
+						if (methodBinding.parameterNonNullness == null)
+							methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
+						methodBinding.parameterNonNullness[j] = Boolean.TRUE;
+						break;
+					} else if (CharOperation.equals(typeName, nullableAnnotationName)) {
+						if (methodBinding.parameterNonNullness == null)
+							methodBinding.parameterNonNullness = new Boolean[numVisibleParams];
+						methodBinding.parameterNonNullness[j] = Boolean.FALSE;
+						break;
+					}
+				}
+			}
+		}
+	}
+}
+void scanTypeForNullAnnotation(IBinaryType binaryType) {
+	if (!this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
+		return;
+	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
+	if (nonNullByDefaultAnnotationName == null)
+		return; // not well-configured to use null annotations
+
+	IBinaryAnnotation[] annotations = binaryType.getAnnotations();
+	if (annotations != null) {
+		long annotationBit = 0L;
+		TypeBinding defaultNullness = null;
+		for (int i = 0; i < annotations.length; i++) {
+			char[] annotationTypeName = annotations[i].getTypeName();
+			if (annotationTypeName[0] != Util.C_RESOLVED)
+				continue;
+			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
+			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
+				IBinaryElementValuePair[] elementValuePairs = annotations[i].getElementValuePairs();
+				if (elementValuePairs != null && elementValuePairs.length == 1) {
+					Object value = elementValuePairs[0].getValue();
+					if (value instanceof BooleanConstant
+						&& !((BooleanConstant)value).booleanValue())
+					{
+						// parameter is 'false': this means we cancel defaults from outer scopes:
+						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
+						defaultNullness = ReferenceBinding.NULL_UNSPECIFIED;
+						break;
+					}
+				}
+				annotationBit = TagBits.AnnotationNonNullByDefault;
+				defaultNullness = this.environment.getNullAnnotationBinding(TagBits.AnnotationNonNull, false/*resolve*/);
+				break;
+			}
+		}
+		if (annotationBit != 0L) {
+			this.tagBits |= annotationBit;
+			if (CharOperation.equals(this.sourceName(), TypeConstants.PACKAGE_INFO_NAME))
+				this.getPackage().nullnessDefaultAnnotation = defaultNullness;
+		}
+	}
+}
+
 /* Answer the receiver's superclass... null if the receiver is Object or an interface.
 *
 * NOTE: superclass of a binary type is resolved when needed
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
index b163168..5f6ea20 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
@@ -4,12 +4,13 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
  *     							bug 185682 - Increment/decrement operators mark local variables as read
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -158,7 +159,7 @@ public class LocalVariableBinding extends VariableBinding {
 					annotations = new AnnotationBinding[length];
 					for (int i = 0; i < length; i++)
 						annotations[i] = new AnnotationBinding(annotationNodes[i]);
-					setAnnotations(annotations);
+					setAnnotations(annotations, this.declaringScope);
 				}
 			}
 		}
@@ -212,10 +213,12 @@ public class LocalVariableBinding extends VariableBinding {
 		this.initializationCount++;
 	}
 
-	public void setAnnotations(AnnotationBinding[] annotations) {
-		if (this.declaringScope == null) return;
-
-		SourceTypeBinding sourceType = this.declaringScope.enclosingSourceType();
+	public void setAnnotations(AnnotationBinding[] annotations, Scope scope) {
+		// note: we don's use this.declaringScope because we might be called before Scope.addLocalVariable(this)
+		//       which is where this.declaringScope is set.
+		if (scope == null)
+			return;
+		SourceTypeBinding sourceType = scope.enclosingSourceType();
 		if (sourceType != null)
 			sourceType.storeAnnotations(this, annotations);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 2e7fe97..f4b99d8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -7,7 +7,9 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - contribution for bug 337868 - [compiler][model] incomplete support for package-info.java when using SearchableEnvironment
+ *     Stephan Herrmann - contributions for
+ *     							bug 337868 - [compiler][model] incomplete support for package-info.java when using SearchableEnvironment
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -76,6 +78,10 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	public boolean isProcessingAnnotations = false;
 	public boolean mayTolerateMissingType = false;
 
+	PackageBinding nullableAnnotationPackage;			// the package supposed to contain the Nullable annotation type
+	PackageBinding nonnullAnnotationPackage;			// the package supposed to contain the NonNull annotation type
+	PackageBinding nonnullByDefaultAnnotationPackage;	// the package supposed to contain the NonNullByDefault annotation type
+
 	final static int BUILD_FIELDS_AND_METHODS = 4;
 	final static int BUILD_TYPE_HIERARCHY = 1;
 	final static int CHECK_AND_SET_IMPORTS = 2;
@@ -84,6 +90,7 @@ public class LookupEnvironment implements ProblemReasons, TypeConstants {
 	static final ProblemPackageBinding TheNotFoundPackage = new ProblemPackageBinding(CharOperation.NO_CHAR, NotFound);
 	static final ProblemReferenceBinding TheNotFoundType = new ProblemReferenceBinding(CharOperation.NO_CHAR_CHAR, null, NotFound);
 
+
 public LookupEnvironment(ITypeRequestor typeRequestor, CompilerOptions globalOptions, ProblemReporter problemReporter, INameEnvironment nameEnvironment) {
 	this.typeRequestor = typeRequestor;
 	this.globalOptions = globalOptions;
@@ -1073,6 +1080,71 @@ public ReferenceBinding getCachedType(char[][] compoundName) {
 	return packageBinding.getType0(compoundName[compoundName.length - 1]);
 }
 
+public char[][] getNullableAnnotationName() {
+	return this.globalOptions.nullableAnnotationName;
+}
+
+public char[][] getNonNullAnnotationName() {
+	return this.globalOptions.nonNullAnnotationName;
+}
+
+public char[][] getNonNullByDefaultAnnotationName() {
+	return this.globalOptions.nonNullByDefaultAnnotationName;
+}
+
+/**
+ * Answer the type binding representing the null-annotation identified by the given tag bits.
+ * @param annotationTagBit tag bits potentially denoting a null-annotation
+ * @param resolve should the resulting type binding be resolved?
+ * @return the corresponding annotation type binding
+ * 		or <code>null</code> if no annotation bits are contained in the given tag bits.
+ */
+public TypeBinding getNullAnnotationBinding(long annotationTagBit, boolean resolve) {
+	char[][] name = null;
+	if (annotationTagBit == TagBits.AnnotationNonNull)
+		name = getNonNullAnnotationName();
+	else if (annotationTagBit == TagBits.AnnotationNullable)
+		name = getNullableAnnotationName();
+	else
+		return null;
+	if (resolve)
+		return getType(name);
+	else
+		return getTypeFromCompoundName(name, false, false);
+}
+
+/**
+ * Inspect the given tag bits and answer a corresponding null annotation type binding
+ * @param defaultTagBit tag bits representing the default applicable at the current code location
+ * @param resolve should the resulting type binding be resolved?
+ * @return the corresponding concrete annotation type binding (<code>@NonNull</code> or <code>@Nullable</code>)
+ * 		or <code>null</code> if no bits of a default-annotation are contained in the given tag bits.
+ */
+public TypeBinding getNullAnnotationBindingFromDefault(long defaultTagBit, boolean resolve) {
+	if ((defaultTagBit & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
+		return ReferenceBinding.NULL_UNSPECIFIED;
+	if ((defaultTagBit & TagBits.AnnotationNonNullByDefault) != 0)
+		return getNullAnnotationBinding(TagBits.AnnotationNonNull, resolve);
+	return null;
+}
+
+TypeBinding getNullAnnotationResolved(TypeBinding nullAnnotation, Scope scope) {
+	// avoid unspecific error "The type in.valid cannot be resolved. It is indirectly referenced from required .class files"
+	boolean tolerateMissing = this.mayTolerateMissingType;
+	this.mayTolerateMissingType = true;
+	try {
+		nullAnnotation = BinaryTypeBinding.resolveType(nullAnnotation, this, false);
+	} finally {
+		this.mayTolerateMissingType = tolerateMissing;
+	}
+	if (nullAnnotation instanceof MissingTypeBinding) {
+		// convert error into a specific one:
+		scope.problemReporter().missingNullAnnotationType(((MissingTypeBinding)nullAnnotation).compoundName);
+		return null;
+	}
+	return nullAnnotation;
+}
+
 /* Answer the top level package named name if it exists in the cache.
 * Answer theNotFoundPackage if it could not be resolved the first time
 * it was looked up, otherwise answer null.
@@ -1454,6 +1526,7 @@ public void reset() {
 	this.unitBeingCompleted = null; // in case AbortException occurred
 
 	this.classFilePool.reset();
+
 	// name environment has a longer life cycle, and must be reset in
 	// the code which created it.
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
index 33c56ef..0e1140d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
@@ -4,9 +4,10 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -34,6 +35,9 @@ public class MethodBinding extends Binding {
 	char[] signature;
 	public long tagBits;
 
+	/** Store nullness information from annotation (incl. applicable default). */
+	public Boolean[] parameterNonNullness;  // TRUE means @NonNull declared, FALSE means @Nullable declared, null means nothing declared
+
 protected MethodBinding() {
 	// for creating problem or synthetic method
 }
@@ -439,6 +443,41 @@ public final char[] constantPoolName() {
 	return this.selector;
 }
 
+/**
+ * After method verifier has finished, fill in missing nullness values from the applicable default.
+ * @param annotationBinding the null annotation specified to be the default at the current code location.
+ */
+protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
+	if (this.parameterNonNullness == null)
+		this.parameterNonNullness = new Boolean[this.parameters.length];
+	AbstractMethodDeclaration sourceMethod = sourceMethod();
+	for (int i = 0; i < this.parameterNonNullness.length; i++) {
+		if (this.parameters[i].isBaseType())
+			continue;
+		boolean added = false;
+		if (this.parameterNonNullness[i] == null) {
+			added = true;
+			this.parameterNonNullness[i] = Boolean.TRUE;
+			if (sourceMethod != null)
+				sourceMethod.addParameterNonNullAnnotation(i, (ReferenceBinding)annotationBinding);
+		} else if (this.parameterNonNullness[i].booleanValue()) {
+			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
+		}
+		if (added)
+			this.tagBits |= TagBits.HasParameterAnnotations;
+	}
+	if (   this.returnType != null
+		&& !this.returnType.isBaseType()
+		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
+	{
+		this.tagBits |= TagBits.AnnotationNonNull;
+		if (sourceMethod != null)
+			sourceMethod.addNullnessAnnotation((ReferenceBinding)annotationBinding);
+	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
+		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
+	}
+}
+
 public MethodBinding findOriginalInheritedMethod(MethodBinding inheritedMethod) {
 	MethodBinding inheritedOriginal = inheritedMethod.original();
 	TypeBinding superType = this.declaringClass.findSuperTypeOriginatingFrom(inheritedOriginal.declaringClass);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index 3b0cae1..a9da269 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -165,6 +166,8 @@ void checkConcreteInheritedMethod(MethodBinding concreteMethod, MethodBinding[]
 				|| this.type.superclass.erasure().findSuperTypeOriginatingFrom(originalInherited.declaringClass) == null)
 					this.type.addSyntheticBridgeMethod(originalInherited, concreteMethod.original());
 		}
+		if (!concreteMethod.isStatic() && !abstractMethod.isStatic())
+			checkNullSpecInheritance(concreteMethod, abstractMethod);
 	}
 }
 void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] allInheritedMethods) {
@@ -360,6 +363,100 @@ boolean checkInheritedReturnTypes(MethodBinding method, MethodBinding otherMetho
 
 	return false;
 }
+void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] allInheritedMethods)
+{
+	super.checkAgainstInheritedMethods(currentMethod, methods, length, allInheritedMethods);
+	for (int i = length; --i >= 0;)
+		if (!currentMethod.isStatic() && !methods[i].isStatic())
+			checkNullSpecInheritance(currentMethod, methods[i]);
+}
+
+void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod) {
+	long inheritedBits = inheritedMethod.tagBits;
+	long currentBits = currentMethod.tagBits;
+	AbstractMethodDeclaration srcMethod = null;
+	if (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?
+		srcMethod = currentMethod.sourceMethod();
+
+	// return type:
+	if ((inheritedBits & TagBits.AnnotationNonNull) != 0) {
+		long currentNullBits = currentBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);
+		if (currentNullBits != TagBits.AnnotationNonNull) {
+			if (srcMethod != null) {
+				this.type.scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,
+															this.environment.getNonNullAnnotationName());
+			} else {
+				this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+				return;
+			}
+		}
+	}
+
+	// parameters:
+	Argument[] currentArguments = srcMethod == null ? null : srcMethod.arguments;
+	if (inheritedMethod.parameterNonNullness != null) {
+		// inherited method has null-annotations, check compatibility:
+
+		for (int i = 0; i < inheritedMethod.parameterNonNullness.length; i++) {
+			Argument currentArgument = currentArguments == null ? null : currentArguments[i];
+
+			Boolean inheritedNonNullNess = inheritedMethod.parameterNonNullness[i];
+			Boolean currentNonNullNess = (currentMethod.parameterNonNullness == null)
+										? null : currentMethod.parameterNonNullness[i];
+			if (inheritedNonNullNess != null) {				// super has a null annotation
+				if (currentNonNullNess == null) {			// current parameter lacks null annotation
+					boolean needNonNull = false;
+					char[][] annotationName;
+					if (inheritedNonNullNess == Boolean.TRUE) {
+						needNonNull = true;
+						annotationName = this.environment.getNonNullAnnotationName();
+					} else {
+						annotationName = this.environment.getNullableAnnotationName();
+					}
+					if (currentArgument != null) {
+						this.type.scope.problemReporter().parameterLackingNonNullAnnotation(
+								currentArgument,
+								inheritedMethod.declaringClass,
+								needNonNull,
+								annotationName);
+						continue;
+					} else {
+						this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+						break;
+					}
+				}
+			}
+			if (inheritedNonNullNess != Boolean.TRUE) {		// super parameter is not restricted to @NonNull
+				if (currentNonNullNess == Boolean.TRUE) { 	// current parameter is restricted to @NonNull
+					if (currentArgument != null)
+						this.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(
+														currentArgument,
+														inheritedMethod.declaringClass,
+														inheritedNonNullNess == null
+														? null
+														: this.environment.getNullableAnnotationName());
+					else
+						this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+				}
+			}
+		}
+	} else if (currentMethod.parameterNonNullness != null) {
+		// super method has no annotations but current has
+		for (int i = 0; i < currentMethod.parameterNonNullness.length; i++) {
+			if (currentMethod.parameterNonNullness[i] == Boolean.TRUE) { // tightening from unconstrained to @NonNull
+				if (currentArguments != null) {
+					this.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(
+																	currentArguments[i],
+																	inheritedMethod.declaringClass,
+																	null);
+				} else {
+					this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
+					break;
+				}
+			}
+		}
+	}
+}
 
 void reportRawReferences() {
 	CompilerOptions compilerOptions = this.type.scope.compilerOptions();
@@ -935,7 +1032,7 @@ boolean isSubstituteParameterSubsignature(MethodBinding method, MethodBinding su
 boolean isUnsafeReturnTypeOverride(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	// called when currentMethod's return type is NOT compatible with inheritedMethod's return type
 
-	// JLS 3 8.4.5: more are accepted, with an unchecked conversion
+	// JLS 3 8.4.5: more are accepted, with an unchecked conversion
 	if (currentMethod.returnType == inheritedMethod.returnType.erasure()) {
 		TypeBinding[] currentParams = currentMethod.parameters;
 		TypeBinding[] inheritedParams = inheritedMethod.parameters;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
index 5efc685..37d0536 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MostSpecificExceptionMethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -27,6 +28,7 @@ public class MostSpecificExceptionMethodBinding  extends MethodBinding {
 				mostSpecificExceptions, 
 				originalMethod.declaringClass);
 		this.originalMethod = originalMethod;
+		this.parameterNonNullness = originalMethod.parameterNonNullness;
 	}
 	
 	public MethodBinding original() {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
index 0e59232..330d65e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PackageBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -22,6 +23,10 @@ public class PackageBinding extends Binding implements TypeConstants {
 	public LookupEnvironment environment;
 	HashtableOfType knownTypes;
 	HashtableOfPackage knownPackages;
+
+	// annotation type binding representing the default that has been defined for this package (using @NonNullByDefault)
+	protected TypeBinding nullnessDefaultAnnotation;
+
 protected PackageBinding() {
 	// for creating problem package
 }
@@ -36,6 +41,8 @@ public PackageBinding(char[][] compoundName, PackageBinding parent, LookupEnviro
 	this.environment = environment;
 	this.knownTypes = null; // initialized if used... class counts can be very large 300-600
 	this.knownPackages = new HashtableOfPackage(3); // sub-package counts are typically 0-3
+	if (compoundName != CharOperation.NO_CHAR_CHAR)
+		checkIfNullAnnotationPackage();
 }
 
 public PackageBinding(LookupEnvironment environment) {
@@ -58,6 +65,8 @@ void addType(ReferenceBinding element) {
 	if (this.knownTypes == null)
 		this.knownTypes = new HashtableOfType(25);
 	this.knownTypes.put(element.compoundName[element.compoundName.length - 1], element);
+	if (element.isAnnotationType() || element instanceof UnresolvedReferenceBinding) // unresolved types don't yet have the modifiers set
+		checkIfNullAnnotationType(element);
 }
 
 void clearMissingTagBit() {
@@ -230,6 +239,55 @@ public int problemId() {
 	return ProblemReasons.NoError;
 }
 
+
+void checkIfNullAnnotationPackage() {
+	LookupEnvironment env = this.environment;
+	if (env.globalOptions.isAnnotationBasedNullAnalysisEnabled) {
+		if (isPackageOfQualifiedTypeName(this.compoundName, env.getNullableAnnotationName()))
+			env.nullableAnnotationPackage = this;
+		if (isPackageOfQualifiedTypeName(this.compoundName, env.getNonNullAnnotationName()))
+			env.nonnullAnnotationPackage = this;
+		if (isPackageOfQualifiedTypeName(this.compoundName, env.getNonNullByDefaultAnnotationName()))
+			env.nonnullByDefaultAnnotationPackage = this;
+	}
+}
+
+private boolean isPackageOfQualifiedTypeName(char[][] packageName, char[][] typeName) {
+	if (typeName == null || typeName.length -1 != packageName.length)
+		return false;
+	for (int i=0; i<packageName.length; i++)
+		if (!CharOperation.equals(packageName[i], typeName[i]))
+			return false;
+	return true;
+}
+
+void checkIfNullAnnotationType(ReferenceBinding type) {
+	// check if type is one of the configured null annotation types
+	// if so mark as a well known type using the corresponding typeID:
+	if (this.environment.nullableAnnotationPackage == this
+			&& CharOperation.equals(type.compoundName, this.environment.getNullableAnnotationName())) {
+		type.id = TypeIds.T_ConfiguredAnnotationNullable;
+		if (!(type instanceof UnresolvedReferenceBinding)) // unresolved will need to check back for the resolved type
+			this.environment.nullableAnnotationPackage = null; // don't check again
+	} else if (this.environment.nonnullAnnotationPackage == this
+			&& CharOperation.equals(type.compoundName, this.environment.getNonNullAnnotationName())) {
+		type.id = TypeIds.T_ConfiguredAnnotationNonNull;
+		if (!(type instanceof UnresolvedReferenceBinding)) // unresolved will need to check back for the resolved type
+			this.environment.nonnullAnnotationPackage = null; // don't check again
+	} else if (this.environment.nonnullByDefaultAnnotationPackage == this
+			&& CharOperation.equals(type.compoundName, this.environment.getNonNullByDefaultAnnotationName())) {
+		type.id = TypeIds.T_ConfiguredAnnotationNonNullByDefault;
+		if (!(type instanceof UnresolvedReferenceBinding)) // unresolved will need to check back for the resolved type
+			this.environment.nonnullByDefaultAnnotationPackage = null; // don't check again
+	}
+}
+
+public TypeBinding getNullnessDefaultAnnotation(Scope scope) {
+	if (this.nullnessDefaultAnnotation instanceof UnresolvedReferenceBinding)
+		return this.nullnessDefaultAnnotation = this.environment.getNullAnnotationResolved(this.nullnessDefaultAnnotation, scope);
+	return this.nullnessDefaultAnnotation;
+}
+
 public char[] readableName() /*java.lang*/ {
 	return CharOperation.concatWith(this.compoundName, '.');
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 1eb176f..31710c4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -7,6 +7,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -301,6 +302,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	    									? originalMethod.returnType // no substitution if original was static
 	    									: Scope.substitute(rawType, originalMethod.returnType));
 	    this.wasInferred = false; // not resulting from method invocation inferrence
+	    this.parameterNonNullness = originalMethod.parameterNonNullness;
 	}
 
     /**
@@ -342,6 +344,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 			}
 		}
 	    this.wasInferred = true;// resulting from method invocation inferrence
+	    this.parameterNonNullness = originalMethod.parameterNonNullness;
 	}
 
 	/*
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
index 22b5afa..c7f8ad3 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedMethodBinding.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2010 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -38,6 +39,7 @@ public class ParameterizedMethodBinding extends MethodBinding {
 		 * is substituted by a raw type.
 		 */
 		this.tagBits = originalMethod.tagBits & ~TagBits.HasMissingType;
+		this.parameterNonNullness = originalMethod.parameterNonNullness;
 
 		final TypeVariableBinding[] originalVariables = originalMethod.typeVariables;
 		Substitution substitution = null;
@@ -150,6 +152,7 @@ public class ParameterizedMethodBinding extends MethodBinding {
 		 * is substituted by a raw type.
 		 */
 		this.tagBits = originalMethod.tagBits & ~TagBits.HasMissingType;
+		this.parameterNonNullness = originalMethod.parameterNonNullness;
 
 		final TypeVariableBinding[] originalVariables = originalMethod.typeVariables;
 		Substitution substitution = null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
index 1769362..75de854 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ReferenceBinding.java
@@ -4,10 +4,12 @@
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
+ *
  * Contributors:
  *     IBM Corporation - initial API and implementation
- *     Stephan Herrmann - Contribution for bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann - Contributions for
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -48,6 +50,14 @@ abstract public class ReferenceBinding extends TypeBinding {
 		public boolean hasTypeBit(int bit) { return false; }
 	};
 
+	/**
+	 * This faked annotation type binding marks types with unspecified nullness.
+	 * For use in {@link PackageBinding#nullnessDefaultAnnotation} and SourceTypeBinding#nullnessDefaultAnnotation
+	 */
+	final static ReferenceBinding NULL_UNSPECIFIED = new ReferenceBinding() { /* faked type binding */
+		public boolean hasTypeBit(int bit) { return false; }
+	};
+
 	private static final Comparator FIELD_COMPARATOR = new Comparator() {
 		public int compare(Object o1, Object o2) {
 			char[] n1 = ((FieldBinding) o1).name;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index bf6db63..25fee09 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -4290,4 +4291,18 @@ public abstract class Scope {
 		}
 		return visibleIndex == 1 ? visible[0] : mostSpecificMethodBinding(visible, visibleIndex, argumentTypes, allocationSite, allocationType);
 	}
+
+	public void validateNullAnnotation(long tagBits, TypeReference typeRef, Annotation[] annotations) {
+		long nullAnnotationTagBit = tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);
+		if (nullAnnotationTagBit != 0) {
+			TypeBinding type = typeRef.resolvedType;
+			if (type != null && type.isBaseType()) {
+				char[][] annotationName = (nullAnnotationTagBit == TagBits.AnnotationNonNull)
+						? environment().getNonNullAnnotationName()
+						: environment().getNullableAnnotationName();
+				problemReporter().illegalAnnotationForBaseType(typeRef, annotations,
+						annotationName[annotationName.length-1], nullAnnotationTagBit);
+			}
+		}
+	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
index d1f9cf4..094c155 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SourceTypeBinding.java
@@ -8,8 +8,9 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for
- *     							bug 328281 - visibility leaks not detected when analyzing unused field in private class
- *     							bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 328281 - visibility leaks not detected when analyzing unused field in private class
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -55,6 +56,9 @@ public class SourceTypeBinding extends ReferenceBinding {
 
 	private SimpleLookupTable storedAnnotations = null; // keys are this ReferenceBinding & its fields and methods, value is an AnnotationHolder
 
+	private TypeBinding nullnessDefaultAnnotation;
+	private int nullnessDefaultInitialized = 0; // 0: nothing; 1: type; 2: package
+
 public SourceTypeBinding(char[][] compoundName, PackageBinding fPackage, ClassScope scope) {
 	this.compoundName = compoundName;
 	this.fPackage = fPackage;
@@ -781,6 +785,7 @@ public long getAnnotationTagBits() {
 		}
 		if ((this.tagBits & TagBits.AnnotationDeprecated) != 0)
 			this.modifiers |= ClassFileConstants.AccDeprecated;
+		evaluateNullAnnotations(this.tagBits);
 	}
 	return this.tagBits;
 }
@@ -1088,6 +1093,8 @@ public void initializeDeprecatedAnnotationTagBits() {
 			this.modifiers |= ClassFileConstants.AccDeprecated;
 		}
 	}
+	if (CharOperation.equals(this.sourceName, TypeConstants.PACKAGE_INFO_NAME))
+		getAnnotationTagBits(); // initialize
 }
 
 // ensure the receiver knows its hierarchy & fields/methods so static imports can be resolved correctly
@@ -1590,12 +1597,102 @@ public MethodBinding resolveTypesFor(MethodBinding method) {
 				typeParameters[i].binding = null;
 		return null;
 	}
+	createArgumentBindings(method);
 	if (foundReturnTypeProblem)
 		return method; // but its still unresolved with a null return type & is still connected to its method declaration
 
 	method.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;
 	return method;
 }
+private void createArgumentBindings(MethodBinding method) {
+	// ensure nullness defaults are initialized at all enclosing levels:
+	switch (this.nullnessDefaultInitialized) {
+	case 0:
+		getAnnotationTagBits(); // initialize
+		//$FALL-THROUGH$
+	case 1:
+		getPackage().isViewedAsDeprecated(); // initialize annotations
+		this.nullnessDefaultInitialized = 2;
+	}
+	AbstractMethodDeclaration methodDecl = method.sourceMethod();
+	if (methodDecl != null) {
+		if (method.parameters != Binding.NO_PARAMETERS)
+			methodDecl.createArgumentBindings();
+		TypeBinding annotationBinding = findDefaultNullness(method, methodDecl.scope.environment());
+		if (annotationBinding != null && annotationBinding.id == TypeIds.T_ConfiguredAnnotationNonNull)
+			method.fillInDefaultNonNullness(annotationBinding);
+	}
+}
+private void evaluateNullAnnotations(long annotationTagBits) {
+	if (this.nullnessDefaultInitialized > 0)
+		return;
+	this.nullnessDefaultInitialized = 1;
+	// transfer nullness info from tagBits to this.nullnessDefaultAnnotation
+	TypeBinding defaultAnnotation = getPackage().environment
+						.getNullAnnotationBindingFromDefault(annotationTagBits, false/*resolve*/);
+	if (defaultAnnotation != null) {
+		if (CharOperation.equals(this.sourceName, TypeConstants.PACKAGE_INFO_NAME)) {
+			getPackage().nullnessDefaultAnnotation = defaultAnnotation;
+		} else {
+			this.nullnessDefaultAnnotation = defaultAnnotation;
+		}
+	}
+}
+private TypeBinding getNullnessDefaultAnnotation() {
+	if (this.nullnessDefaultAnnotation instanceof UnresolvedReferenceBinding)
+		this.nullnessDefaultAnnotation = this.scope.environment().getNullAnnotationResolved(this.nullnessDefaultAnnotation, this.scope);
+	return this.nullnessDefaultAnnotation;
+}
+/**
+ * Answer the nullness default applicable at the given method binding.
+ * Possible values:<ul>
+ * <li>the type binding for @NonNulByDefault</li>
+ * <li>the synthetic type {@link ReferenceBinding#NULL_UNSPECIFIED} if a default from outer scope has been canceled</li>
+ * <li>null if no default has been defined</li>
+ * </ul>
+ */
+private TypeBinding findDefaultNullness(MethodBinding methodBinding, LookupEnvironment environment) {
+	// find the applicable default inside->out:
+
+	// method
+	TypeBinding annotationBinding = environment.getNullAnnotationBindingFromDefault(methodBinding.tagBits, true/*resolve*/);
+	if (annotationBinding != null)
+		return annotationBinding;
+
+	// type
+	ReferenceBinding type = methodBinding.declaringClass;
+	ReferenceBinding currentType = type;
+	while (currentType instanceof SourceTypeBinding) {
+		annotationBinding = ((SourceTypeBinding) currentType).getNullnessDefaultAnnotation();
+		if (annotationBinding != null)
+			return annotationBinding;
+		currentType = currentType.enclosingType();
+	}
+
+	// package
+	annotationBinding = type.getPackage().getNullnessDefaultAnnotation(this.scope);
+	if (annotationBinding != null)
+		return annotationBinding;
+
+	// global
+	long defaultNullness = environment.globalOptions.defaultNonNullness;
+	if (defaultNullness != 0) {
+		// we have a default, so we need an annotation type to record this during compile and in the byte code
+		annotationBinding = environment.getNullAnnotationBinding(defaultNullness, true/*resolve*/);
+		if (annotationBinding != null)
+			return annotationBinding;
+
+		// on this branch default was not defined using an annotation, thus annotation type can still be missing
+		if (defaultNullness == TagBits.AnnotationNonNull)
+			this.scope.problemReporter().missingNullAnnotationType(environment.getNonNullAnnotationName());
+		else
+			this.scope.problemReporter().abortDueToInternalError("Illegal default nullness value: "+defaultNullness); //$NON-NLS-1$
+		// reset default to avoid duplicate errors:
+		environment.globalOptions.defaultNonNullness = 0;
+	}
+	return null;
+}
+
 public AnnotationHolder retrieveAnnotationHolder(Binding binding, boolean forceInitialization) {
 	if (forceInitialization)
 		binding.getAnnotationTagBits(); // ensure annotations are up to date
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
index 55d5b88..9ba6da0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TagBits.java
@@ -7,6 +7,7 @@
  * 
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -132,6 +133,14 @@ public interface TagBits {
 	long AnnotationPreDestroy = ASTNode.Bit54L;
 	/** @since 3.8 */
 	long AnnotationPostConstruct = ASTNode.Bit55L;
+	/** @since 3.8 null annotation for MethodBinding or LocalVariableBinding (argument): */
+	long AnnotationNullable = ASTNode.Bit56L;
+	/** @since 3.8 null annotation for MethodBinding or LocalVariableBinding (argument): */
+	long AnnotationNonNull = ASTNode.Bit57L;
+	/** @since 3.8 null-default annotation for PackageBinding or TypeBinding or MethodBinding: */
+	long AnnotationNonNullByDefault = ASTNode.Bit58L;
+	/** @since 3.8 canceling null-default annotation for PackageBinding or TypeBinding or MethodBinding: */
+	long AnnotationNullUnspecifiedByDefault = ASTNode.Bit59L;
 
 	long AllStandardAnnotationsMask =
 				  AnnotationTargetMASK
@@ -144,10 +153,14 @@ public interface TagBits {
 				| AnnotationSafeVarargs
 				| AnnotationPolymorphicSignature
 				| AnnotationPostConstruct
-				| AnnotationPreDestroy;
+				| AnnotationPreDestroy
+				| AnnotationNullable
+				| AnnotationNonNull
+				| AnnotationNonNullByDefault
+				| AnnotationNullUnspecifiedByDefault;
 
-	long DefaultValueResolved = ASTNode.Bit56L;
+	long DefaultValueResolved = ASTNode.Bit60L;
 
 	// set when type contains non-private constructor(s)
-	long HasNonPrivateConstructor = ASTNode.Bit57L;
+	long HasNonPrivateConstructor = ASTNode.Bit61L;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
index 115bf83..7fff434 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeIds.java
@@ -10,6 +10,7 @@
  *     Stephan Herrmann - Contributions for
  *     							bug 349326 - [1.7] new warning for missing try-with-resources
  *     							bug 359362 - FUP of bug 349326: Resource leak on non-Closeable resource
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
 
@@ -104,6 +105,11 @@ public interface TypeIds {
 	final int T_JavaxAnnotationPostConstruct = 63;
 
 	final int T_JavaxAnnotationPreDestroy = 64;
+	
+	// new in 3.8 for null annotations:
+	final int T_ConfiguredAnnotationNullable = 65;
+	final int T_ConfiguredAnnotationNonNull = 66;
+	final int T_ConfiguredAnnotationNonNullByDefault = 67;
 
 	final int NoId = Integer.MAX_VALUE;
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
index 26d3599..ca6b9fa 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/Scanner.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.parser;
 
@@ -546,11 +547,11 @@ public final int getLineEnd(int lineNumber) {
 
 	if (this.lineEnds == null || this.linePtr == -1)
 		return -1;
-	if (lineNumber > this.lineEnds.length+1)
+	if (lineNumber > this.linePtr + 2)
 		return -1;
 	if (lineNumber <= 0)
 		return -1;
-	if (lineNumber == this.lineEnds.length + 1)
+	if (lineNumber == this.linePtr + 2)
 		return this.eofPosition;
 	return this.lineEnds[lineNumber-1]; // next line start one character behind the lineEnd of the previous line
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index cbaf9aa..9b83933 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -8,10 +8,11 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Benjamin Muskalla - Contribution for bug 239066
- *     Stephan Herrmann  - Contributions for 
- *     						bug 236385 - 
- *     						bug 338303 - Warning about Redundant assignment conflicts with definite assignment
- *     						bug 349326 - [1.7] new warning for missing try-with-resources
+ *     Stephan Herrmann  - Contributions for
+ *	     						bug 236385 - [compiler] Warn for potential programming problem if an object is created but not used
+ *  	   						bug 338303 - Warning about Redundant assignment conflicts with definite assignment
+ *								bug 349326 - [1.7] new warning for missing try-with-resources
+ *								bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.problem;
 
@@ -84,6 +85,7 @@ import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.env.AccessRestriction;
 import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
+import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 import org.eclipse.jdt.internal.compiler.impl.ReferenceContext;
 import org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;
@@ -287,6 +289,7 @@ public static int getIrritant(int problemID) {
 			return CompilerOptions.NullReference;
 
 		case IProblem.PotentialNullLocalVariableReference:
+		case IProblem.PotentialNullMessageSendReference:
 			return CompilerOptions.PotentialNullReference;
 
 		case IProblem.RedundantLocalVariableNullAssignment:
@@ -295,8 +298,25 @@ public static int getIrritant(int problemID) {
 		case IProblem.NonNullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableComparisonYieldsFalse:
 		case IProblem.NullLocalVariableInstanceofYieldsFalse:
+		case IProblem.RedundantNullCheckOnNonNullMessageSend:
 			return CompilerOptions.RedundantNullCheck;
 
+		case IProblem.RequiredNonNullButProvidedNull:
+		case IProblem.IllegalReturnNullityRedefinition:
+		case IProblem.IllegalRedefinitionToNonNullParameter:
+		case IProblem.IllegalDefinitionToNonNullParameter:
+		case IProblem.ParameterLackingNonNullAnnotation:
+		case IProblem.ParameterLackingNullableAnnotation:
+		case IProblem.CannotImplementIncompatibleNullness:
+			return CompilerOptions.NullSpecViolation;
+
+		case IProblem.RequiredNonNullButProvidedPotentialNull:
+			return CompilerOptions.PotentialNullSpecViolation;
+		case IProblem.RequiredNonNullButProvidedUnknown:
+			return CompilerOptions.NullSpecInsufficientInfo;
+		case IProblem.RedundantNullAnnotation:
+			return CompilerOptions.RedundantNullAnnotation;
+
 		case IProblem.BoxingConversion :
 		case IProblem.UnboxingConversion :
 			return CompilerOptions.AutoBoxing;
@@ -541,7 +561,14 @@ public static int getProblemCategory(int severity, int problemID) {
 			case CompilerOptions.ForbiddenReference :
 			case CompilerOptions.DiscouragedReference :
 				return CategorizedProblem.CAT_RESTRICTION;
-			
+
+			case CompilerOptions.NullSpecViolation :
+			case CompilerOptions.PotentialNullSpecViolation :
+			case CompilerOptions.NullSpecInsufficientInfo :
+				return CategorizedProblem.CAT_POTENTIAL_PROGRAMMING_PROBLEM;
+			case CompilerOptions.RedundantNullAnnotation :
+				return CategorizedProblem.CAT_UNNECESSARY_CODE;
+
 			default:
 				break categorizeOnIrritant;
 		}
@@ -550,6 +577,7 @@ public static int getProblemCategory(int severity, int problemID) {
 	switch (problemID) {
 		case IProblem.IsClassPathCorrect :
 		case IProblem.CorruptedSignature :
+		case IProblem.MissingNullAnnotationType :
 			return CategorizedProblem.CAT_BUILDPATH;
 
 		default :
@@ -8043,4 +8071,175 @@ public void explicitlyClosedAutoCloseable(FakedTrackingVariable trackVar) {
 		trackVar.sourceStart,
 		trackVar.sourceEnd);	
 }
-}
\ No newline at end of file
+
+public void nullityMismatch(Expression expression, TypeBinding requiredType, int nullStatus, char[][] annotationName) {
+	int problemId = IProblem.RequiredNonNullButProvidedUnknown;
+	if ((nullStatus & FlowInfo.NULL) != 0)
+		problemId = IProblem.RequiredNonNullButProvidedNull;
+	if ((nullStatus & FlowInfo.POTENTIALLY_NULL) != 0)
+		problemId = IProblem.RequiredNonNullButProvidedPotentialNull;
+	String[] arguments = new String[] {
+			String.valueOf(CharOperation.concatWith(annotationName, '.')),
+			String.valueOf(requiredType.readableName())
+	};
+	String[] argumentsShort = new String[] {
+			String.valueOf(annotationName[annotationName.length-1]),
+			String.valueOf(requiredType.shortReadableName())
+	};
+	this.handle(
+		problemId,
+		arguments,
+		argumentsShort,
+		expression.sourceStart,
+		expression.sourceEnd);
+}
+public void illegalRedefinitionToNonNullParameter(Argument argument, ReferenceBinding declaringClass, char[][] inheritedAnnotationName) {
+	int sourceStart = argument.type.sourceStart;
+	if (argument.annotations != null) {
+		for (int i=0; i<argument.annotations.length; i++) {
+			Annotation annotation = argument.annotations[i];
+			if (   annotation.resolvedType.id == TypeIds.T_ConfiguredAnnotationNullable
+				|| annotation.resolvedType.id == TypeIds.T_ConfiguredAnnotationNonNull)
+			{
+				sourceStart = annotation.sourceStart;
+				break;
+			}
+		}
+	}
+	if (inheritedAnnotationName == null) {
+		this.handle(
+			IProblem.IllegalDefinitionToNonNullParameter, 
+			new String[] { new String(argument.name), new String(declaringClass.readableName()) },
+			new String[] { new String(argument.name), new String(declaringClass.shortReadableName()) },
+			sourceStart,
+			argument.type.sourceEnd);
+	} else {
+		this.handle(
+			IProblem.IllegalRedefinitionToNonNullParameter, 
+			new String[] { new String(argument.name), new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
+			new String[] { new String(argument.name), new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
+			sourceStart,
+			argument.type.sourceEnd);
+	}
+}
+public void parameterLackingNonNullAnnotation(Argument argument, ReferenceBinding declaringClass, boolean needNonNull, char[][] inheritedAnnotationName) {
+	this.handle(
+		needNonNull ? IProblem.ParameterLackingNonNullAnnotation : IProblem.ParameterLackingNullableAnnotation, 
+		new String[] { new String(argument.name), new String(declaringClass.readableName()), CharOperation.toString(inheritedAnnotationName)},
+		new String[] { new String(argument.name), new String(declaringClass.shortReadableName()), new String(inheritedAnnotationName[inheritedAnnotationName.length-1])},
+		argument.type.sourceStart,
+		argument.type.sourceEnd);
+}
+public void illegalReturnRedefinition(AbstractMethodDeclaration abstractMethodDecl,
+									  MethodBinding inheritedMethod, char[][] nonNullAnnotationName)
+{
+	MethodDeclaration methodDecl = (MethodDeclaration) abstractMethodDecl;
+	StringBuffer methodSignature = new StringBuffer();
+	methodSignature
+		.append(inheritedMethod.declaringClass.readableName())
+		.append('.')
+		.append(inheritedMethod.readableName());
+
+	StringBuffer shortSignature = new StringBuffer();
+	shortSignature
+		.append(inheritedMethod.declaringClass.shortReadableName())
+		.append('.')
+		.append(inheritedMethod.shortReadableName());
+	int sourceStart = methodDecl.returnType.sourceStart;
+	Annotation[] annotations = methodDecl.annotations;
+	sourceStart = findAnnotationSourceStart(annotations, sourceStart, TypeIds.T_ConfiguredAnnotationNullable);
+	this.handle(
+		IProblem.IllegalReturnNullityRedefinition, 
+		new String[] { methodSignature.toString(), CharOperation.toString(nonNullAnnotationName)},
+		new String[] { shortSignature.toString(), new String(nonNullAnnotationName[nonNullAnnotationName.length-1])},
+		sourceStart,
+		methodDecl.returnType.sourceEnd);
+}
+public void messageSendPotentialNullReference(MethodBinding method, ASTNode location) {
+	String[] arguments = new String[] {new String(method.readableName())};
+	this.handle(
+		IProblem.PotentialNullMessageSendReference,
+		arguments,
+		arguments,
+		location.sourceStart,
+		location.sourceEnd);
+}
+public void messageSendRedundantCheckOnNonNull(MethodBinding method, ASTNode location) {
+	String[] arguments = new String[] {new String(method.readableName())  };
+	this.handle(
+		IProblem.RedundantNullCheckOnNonNullMessageSend,
+		arguments,
+		arguments,
+		location.sourceStart,
+		location.sourceEnd);
+}
+
+public void missingNullAnnotationType(char[][] nullAnnotationName) {
+	String[] args = { new String(CharOperation.concatWith(nullAnnotationName, '.')) };
+	this.handle(IProblem.MissingNullAnnotationType, args, args, 0, 0);
+}
+
+public void cannotImplementIncompatibleNullness(MethodBinding currentMethod, MethodBinding inheritedMethod) {
+	int sourceStart = 0, sourceEnd = 0;
+	if (this.referenceContext instanceof TypeDeclaration) {
+		sourceStart = ((TypeDeclaration) this.referenceContext).sourceStart;
+		sourceEnd =   ((TypeDeclaration) this.referenceContext).sourceEnd;
+	}
+	String[] problemArguments = {
+			new String(currentMethod.readableName()),
+			new String(currentMethod.declaringClass.readableName()),
+			new String(inheritedMethod.declaringClass.readableName())
+		};
+	String[] messageArguments = {
+			new String(currentMethod.shortReadableName()),
+			new String(currentMethod.declaringClass.shortReadableName()),
+			new String(inheritedMethod.declaringClass.shortReadableName())
+		};
+	this.handle(
+			IProblem.CannotImplementIncompatibleNullness,
+			problemArguments,
+			messageArguments,
+			sourceStart,
+			sourceEnd);
+}
+
+public void nullAnnotationIsRedundant(AbstractMethodDeclaration sourceMethod, int i) {
+	int sourceStart, sourceEnd;
+	if (i == -1) {
+		MethodDeclaration methodDecl = (MethodDeclaration) sourceMethod;
+		sourceStart = findAnnotationSourceStart(methodDecl.annotations, methodDecl.returnType.sourceStart, TypeIds.T_ConfiguredAnnotationNonNull);
+		sourceEnd = methodDecl.returnType.sourceEnd;
+	} else {
+		Argument arg = sourceMethod.arguments[i];
+		sourceStart = arg.declarationSourceStart;
+		sourceEnd = arg.sourceEnd;
+	}
+	this.handle(IProblem.RedundantNullAnnotation, ProblemHandler.NoArgument, ProblemHandler.NoArgument, sourceStart, sourceEnd);
+}
+
+public void illegalAnnotationForBaseType(TypeReference type, Annotation[] annotations, char[] annotationName, long nullAnnotationTagBit)
+{
+	int typeId = (nullAnnotationTagBit == TagBits.AnnotationNullable) 
+			? TypeIds.T_ConfiguredAnnotationNullable : TypeIds.T_ConfiguredAnnotationNonNull;
+	String[] args = new String[] { new String(annotationName), new String(type.getLastToken()) };
+	this.handle(IProblem.IllegalAnnotationForBaseType,
+			args,
+			args,
+			findAnnotationSourceStart(annotations, type.sourceStart, typeId),
+			type.sourceEnd);
+}
+
+private int findAnnotationSourceStart(Annotation[] annotations, int startFallback, int typeId) {
+	int sourceStart = startFallback;
+	if (annotations != null) {
+		// should have a @NonNull/@Nullable annotation, search for it:
+		for (int j=0; j<annotations.length; j++) {
+			if (annotations[j].resolvedType != null && annotations[j].resolvedType.id == typeId) {
+				sourceStart = annotations[j].sourceStart;
+				break;
+			}
+		}
+	}
+	return sourceStart;
+}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
index 869cf2d..d05ebd2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/messages.properties
@@ -11,6 +11,7 @@
 #		Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
 #							bug 185682 - Increment/decrement operators mark local variables as read
 #							bug 349326 - [1.7] new warning for missing try-with-resources
+#							bug 186342 - [compiler][null] Using annotations for null checking
 ###############################################################################
 0 = {0}
 1 = super cannot be used in java.lang.Object
@@ -655,6 +656,22 @@
 889 = Resource ''{0}'' should be managed by try-with-resource
 890 = Cannot switch on an enum value for source level below 1.5. Only convertible int values are permitted
 
+### NULL ANNOTATIONS
+910 = Type mismatch: required ''@{0} {1}'' but the provided value is null
+911 = Type mismatch: required ''@{0} {1}'' but the provided value can be null
+912 = Potential type mismatch: required ''@{0} {1}'' but nullness of the provided value is unknown
+913 = Buildpath problem: the type {0}, which is configured as a null annotation type, cannot be resolved
+914 = The return type is incompatible with the @{1} return from {0}
+915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
+916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
+917 = Missing non-null annotation: inherited method from {1} declares this parameter as @{2}
+918 = Missing nullable annotation: inherited method from {1} declares this parameter as @{2}
+919 = Potential null pointer access: The method {0} may return null
+920 = Redundant null check: The method {0} cannot return null
+921 = The method {0} from {1} cannot implement the corresponding method from {2} due to incompatible nullness constraints
+922 = The nullness annotation is redundant with a default that applies to this location
+923 = The nullness annotation @{0} is not applicable for the primitive type {1}
+
 ### ELABORATIONS
 ## Access restrictions
 78592 = The type {1} is not accessible due to restriction on classpath entry {0}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
index b72a6fb..a2d1924 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/ASTConverter.java
@@ -4361,6 +4361,7 @@ class ASTConverter {
 			int indexInAnnotations = 0;
 			while ((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
 				IExtendedModifier modifier = null;
+				switchToken:
 				switch(token) {
 					case TerminalTokens.TokenNameabstract:
 						modifier = createModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD);
@@ -4398,7 +4399,13 @@ class ASTConverter {
 					case TerminalTokens.TokenNameAT :
 						// we have an annotation
 						if (annotations != null && indexInAnnotations < annotations.length) {
-							org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
+							// method may have synthetic annotations, skip them:
+							org.eclipse.jdt.internal.compiler.ast.Annotation annotation;
+							do {
+								if (indexInAnnotations == annotations.length)
+									break switchToken;
+								annotation = annotations[indexInAnnotations++];
+							} while ((annotation.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.IsSynthetic) != 0);
 							modifier = convert(annotation);
 							this.scanner.resetTo(annotation.declarationSourceEnd + 1, modifiersEnd);
 						}
@@ -4512,6 +4519,7 @@ class ASTConverter {
 					int token;
 					while ((token = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
 						IExtendedModifier modifier = null;
+						switchToken:
 						switch(token) {
 							case TerminalTokens.TokenNameabstract:
 								modifier = createModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD);
@@ -4549,7 +4557,13 @@ class ASTConverter {
 							case TerminalTokens.TokenNameAT :
 								// we have an annotation
 								if (annotations != null && indexInAnnotations < annotations.length) {
-									org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
+									// argument may have synthetic annotations, skip them:
+									org.eclipse.jdt.internal.compiler.ast.Annotation annotation;
+									do {
+										if (indexInAnnotations == annotations.length)
+											break switchToken;
+										annotation = annotations[indexInAnnotations++];
+									} while ((annotation.bits & org.eclipse.jdt.internal.compiler.ast.ASTNode.IsSynthetic) != 0);
 									modifier = convert(annotation);
 									this.scanner.resetTo(annotation.declarationSourceEnd + 1, this.compilationUnitSourceLength);
 								}
@@ -4623,6 +4637,7 @@ class ASTConverter {
 							break;
 						case TerminalTokens.TokenNameAT :
 							// we have an annotation
+							// (local variable has no synthetic annotations, no need to skip them)
 							if (annotations != null && indexInAnnotations < annotations.length) {
 								org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 								modifier = convert(annotation);
@@ -4725,6 +4740,7 @@ class ASTConverter {
 								break;
 							case TerminalTokens.TokenNameAT :
 								// we have an annotation
+								// (local variable has no synthetic annotations, no need to skip them)
 								if (annotations != null && indexInAnnotations < annotations.length) {
 									org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 									modifier = convert(annotation);
@@ -4806,6 +4822,7 @@ class ASTConverter {
 								break;
 							case TerminalTokens.TokenNameAT :
 								// we have an annotation
+								// (local variable has no synthetic annotations, no need to skip them)
 								if (annotations != null && indexInAnnotations < annotations.length) {
 									org.eclipse.jdt.internal.compiler.ast.Annotation annotation = annotations[indexInAnnotations++];
 									modifier = convert(annotation);
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
index 0fdbd0a..00b8222 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/CompilationUnitResolver.java
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 363858 - [dom] early throwing of AbortCompilation causes NPE in CompilationUnitResolver
  *******************************************************************************/
 package org.eclipse.jdt.core.dom;
 
@@ -99,6 +100,7 @@ class CompilationUnitResolver extends Compiler {
 	DefaultBindingResolver.BindingTables bindingTables;
 
 	boolean hasCompilationAborted;
+	CategorizedProblem abortProblem;
 
 	private IProgressMonitor monitor;
 	
@@ -364,6 +366,7 @@ class CompilationUnitResolver extends Compiler {
 			removeUnresolvedBindings(unit);
 		}
 		this.hasCompilationAborted = true;
+		this.abortProblem = abortException.problem;
 	}
 
 	public static void parse(ICompilationUnit[] compilationUnits, ASTRequestor astRequestor, int apiLevel, Map options, int flags, IProgressMonitor monitor) {
@@ -689,11 +692,16 @@ class CompilationUnitResolver extends Compiler {
 				// the bindings could not be resolved due to missing types in name environment
 				// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=86541
 				CompilationUnitDeclaration unitDeclaration = parse(sourceUnit, nodeSearcher, options, flags);
-				final int problemCount = unit.compilationResult.problemCount;
-				if (problemCount != 0) {
-					unitDeclaration.compilationResult.problems = new CategorizedProblem[problemCount];
-					System.arraycopy(unit.compilationResult.problems, 0, unitDeclaration.compilationResult.problems, 0, problemCount);
-					unitDeclaration.compilationResult.problemCount = problemCount;
+				if (unit != null) {
+					final int problemCount = unit.compilationResult.problemCount;
+					if (problemCount != 0) {
+						unitDeclaration.compilationResult.problems = new CategorizedProblem[problemCount];
+						System.arraycopy(unit.compilationResult.problems, 0, unitDeclaration.compilationResult.problems, 0, problemCount);
+						unitDeclaration.compilationResult.problemCount = problemCount;
+					}
+				} else if (resolver.abortProblem != null) {
+					unitDeclaration.compilationResult.problemCount = 1;
+					unitDeclaration.compilationResult.problems = new CategorizedProblem[] { resolver.abortProblem };
 				}
 				return unitDeclaration;
 			}
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
index e894759..e146520 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetSkeleton.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2011 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -7,6 +7,7 @@
  *
  * Contributors:
  *     IBM Corporation - initial API and implementation
+ *     Stephan Herrmann - Contribution for bug 186342 - [compiler][null] Using annotations for null checking
  *******************************************************************************/
 package org.eclipse.jdt.internal.eval;
 
@@ -64,6 +65,9 @@ public class CodeSnippetSkeleton implements IBinaryType, EvaluationConstants {
 		public IBinaryAnnotation[] getParameterAnnotations(int index) {
 			return null;
 		}
+		public int getNumParameterAnnotations() {
+			return 0;
+		}
 		public char[] getSelector() {
 			return this.selector;
 		}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 750cc95..570c5c6 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -87,6 +87,12 @@
  *     								COMPILER_PB_UNCLOSED_CLOSEABLE,
  *     								COMPILER_PB_POTENTIALLY_UNCLOSED_CLOSEABLE
  *     								COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE
+ *     								COMPILER_ANNOTATION_NULL_ANALYSIS
+ *     								COMPILER_NULLABLE_ANNOTATION_NAME
+ *     								COMPILER_NONNULL_ANNOTATION_NAME
+ *     								COMPILER_PB_NULL_SPECIFICATION_VIOLATION
+ *     								COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION
+ *     								COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO
  *******************************************************************************/
 
 package org.eclipse.jdt.core;
@@ -1407,6 +1413,224 @@ public final class JavaCore extends Plugin {
 	 */
 	public static final String COMPILER_PB_EXPLICITLY_CLOSED_AUTOCLOSEABLE = PLUGIN_ID + ".compiler.problem.explicitlyClosedAutoCloseable"; //$NON-NLS-1$
 	/**
+	 * Compiler option ID: Annotation-based Null Analysis.
+	 * <p>This option controls whether the compiler will use null annotations for
+	 *    improved analysis of (potential) null references.</p>
+	 * <p>If enabled the compiler will interpret the annotation types defined using
+	 *    {@link #COMPILER_NONNULL_ANNOTATION_NAME} and {@link #COMPILER_NULLABLE_ANNOTATION_NAME}
+	 *    as specifying whether or not a given type includes the value <code>null</code>.</p>
+	 * <p>The effect of these analyses is further controled by the options
+	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
+	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
+	 * </p>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullanalysis"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_ANNOTATION_NULL_ANALYSIS = PLUGIN_ID + ".compiler.annotation.nullanalysis"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Name of Annotation Type for Nullable Types.
+	 * <p>This option defines a fully qualified Java type name that the compiler may use
+	 *    to perform special null analysis.</p>
+	 * <p>If the annotation specified by this option is applied to a type in a method
+	 *    signature or variable declaration this will be interpreted as a specification
+	 *    that <code>null</code> is a legal value in that position. Currently supported
+	 *    positions are: method parameters, method return type and local variables.</p>
+	 * <p>If a value whose type
+	 *    is annotated with this annotation is dereferenced without checking for null
+	 *    the compiler will trigger a diagnostic as further controlled by
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}.</p>
+	 * <p>The compiler may furthermore check adherence to the null specification as
+	 *    further controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
+	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * </p>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code></dd>
+	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name, must resolve to an annotation type.</dd>
+	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.Nullable"</code></dd>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_NULLABLE_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nullable"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Name of Annotation Type for Non-Null Types.
+	 * <p>This option defines a fully qualified Java type name that the compiler may use
+	 *    to perform special null analysis.</p>
+	 * <p>If the annotation specified by this option is applied to a type in a method
+	 *    signature or variable declaration this will be interpreted as a specification
+	 *    that <code>null</code> is <b>not</b> a legal value in that position. Currently
+	 *    supported positions are: method parameters, method return type and local variables.</p>
+	 * <p>For values declared with this annotation the compiler will never trigger a null
+	 *    reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
+	 *    and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
+	 *    will never occur at runtime in these positions.</p>
+	 * <p>The compiler may furthermore check adherence to the null specification as further
+	 *    controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
+	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
+	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code></dd>
+	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name, must resolve to an annotation type.</dd>
+	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.NonNull"</code></dd>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_NONNULL_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnull"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Name of Annotation Type to specify a nullness default for unannotated types.
+	 * <p>This option defines a fully qualified Java type name that the compiler may use
+	 *    to perform special null analysis.</p>
+	 * <p>If the annotation is applied without an argument all unannotated types in method signatures
+	 *    within the annotated element will be treated as if they were specified with the non-null annotation
+	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
+	 * <p>If the annotation is applied with the constant <code>false</code> as its argument
+	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.
+	 *    This includes defaults specified using this annotation type or a default defined using
+	 *    the compiler option {@link #COMPILER_NONNULL_IS_DEFAULT}.</p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"</code></dd>
+	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name, must resolve to an annotation type.
+	 *     That annotation type should have exactly one boolean parameter.</dd>
+	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.NonNullByDefault"</code></dd></dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnullbydefault"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Globally specify non-null as the assumed default for unannotated types.
+	 * <p>When enabled this option globally achieves the same effect 
+	 *    as specifying {@link #COMPILER_NONNULL_ANNOTATION_NAME} does for individual elements.</p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code>.</dd>
+	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_NONNULL_IS_DEFAULT = PLUGIN_ID + ".compiler.annotation.nonnullisdefault"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Violations of Null Specifications.
+	 * <p>Depending on this option, the compiler will issue either an error or a warning
+	 *    whenever one of the following situations is detected:
+	 *    <ol>
+	 *    <li>A method declared with a nonnull annotation returns an expression	that is
+	 *          statically known to evaluate to a null value.</li>
+	 *    <li>An expression that is statically known to evaluate to a null value is	passed
+	 *        as an argument in a method call where the corresponding parameter of the called
+	 *        method is declared with a nonnull annotation.</li>
+	 *    <li>An expression that is statically known to evaluate to a null value is	assigned
+	 *        to a local variable that is declared with a nonnull annotation.</li>
+	 *    <li>A method that overrides an inherited method declared with a nonnull annotation
+	 *        tries to relax that contract by specifying a nullable annotation
+	 *        (prohibition of contravariant return).</li>
+	 *    <li>A method that overrides an inherited method which has a nullable declaration
+	 *        for at least one of its parameters, tries to tighten that null contract by
+	 *        specifying a nonnull annotation for its corresponding parameter
+	 *        (prohibition of covariant parameters).</li>
+	 *    </ol>
+	 * </p>
+	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+	 *    shall interpret as nonnull or nullable annotations, respectively.
+	 * </p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullSpecViolation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"error"</code></dd>
+	 * </dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NULL_SPECIFICATION_VIOLATION = PLUGIN_ID + ".compiler.problem.nullSpecViolation"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Violations of Null Specifications with Potential Null Value.
+	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the
+	 *    following situations is detected:
+	 *    <ol>
+	 *    <li>A method declared with a nonnull annotation returns an expression that is
+	 *          statically known to evaluate to a null value on some flow.</li>
+	 *    <li>An expression that is statically known to evaluate to a null value on some flow
+	 *        is passed as an argument in a method call where the corresponding parameter of
+	 *        the called method is declared with a nonnull annotation.</li>
+	 *    <li>An expression that is statically known to evaluate to a null value on some flow
+	 *        is assigned to a local variable that is declared with a nonnull annotation.</li>
+	 *    </ol>
+	 * </p>
+	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+	 *    shall interpret as nonnull or nullable annotations, respectively.
+	 * </p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"error"</code></dd>
+	 * </dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION = PLUGIN_ID + ".compiler.problem.potentialNullSpecViolation"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Insufficient Information for Analysing Adherence to Null Specifications.
+	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the
+	 *    following situations is detected:
+	 *    <ol>
+	 *    <li>A method declared with a nonnull annotation returns an expression for	which
+	 *        insufficient nullness information is available for statically proving that no
+	 *        flow will pass a null value at runtime.</li>
+	 *    <li>An expression for which insufficient nullness information is available for
+	 *        statically proving that it will never evaluate to a null value at runtime
+	 *        is passed as an argument in a method call where the corresponding	parameter of
+	 *        the called method is declared with a nonnull annotation.</li>
+	 *    <li>An expression for which insufficient nullness information is available for
+	 *        statically proving that it will never evaluate to a null value at runtime
+	 *        is assigned to a local variable that is declared with a nonnull annotation.</li>
+	 *    </ol>
+	 *    Insufficient nullness information is usually a consequence of using other unannotated
+	 *    variables or methods.
+	 * </p>
+	 * <p>The compiler options {@link #COMPILER_NONNULL_ANNOTATION_NAME} and
+	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
+	 *    shall interpret as nonnull or nullable annotations, respectively.
+	 * </p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO = PLUGIN_ID + ".compiler.problem.nullSpecInsufficientInfo"; //$NON-NLS-1$
+	/**
+	 * Compiler option ID: Reporting Redundant Null Annotations.
+	 * <p>When enabled, the compiler will issue an error or a warning when a non-null annotation
+	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME})
+	 *    is applied although the same effect is already achieved by a default applicable at the
+	 *    current location. Such default may be effective by enabling the option
+	 *    {@link #COMPILER_NONNULL_IS_DEFAULT} or by using the annotation specified by the option
+	 *    {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}.
+	 * </p>
+	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <dl>
+	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation"</code></dd>
+	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
+	 * <dt>Default:</dt><dd><code>"warning"</code></dd>
+	 * </dl>
+	 * @since 3.8
+	 * @category CompilerOptionID
+	 */
+	public static final String COMPILER_PB_REDUNDANT_NULL_ANNOTATION = PLUGIN_ID + ".compiler.problem.redundantNullAnnotation"; //$NON-NLS-1$
+	/**
 	 * Compiler option ID: Setting Source Compatibility Mode.
 	 * <p>Specify whether which source level compatibility is used. From 1.4 on, <code>'assert'</code> is a keyword
 	 *    reserved for assertion support. Also note, than when toggling to 1.4 mode, the target VM
commit a5faef70226b949f29a3fbd49fedef29783c89d7
Author: Markus Keller <mkeller>
Date:   Thu Dec 1 15:26:18 2011 +0100

    Bug 186342: [compiler][null] Using annotations for null checking
    - API cleanup
    - formatted code

16	11	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
20	14	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
15	10	org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
index ec5e934..78aa71c 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNull.java
@@ -1,20 +1,26 @@
 /*******************************************************************************
- * Copyright (c) 2011 Stephan Herrmann.
+ * Copyright (c) 2011 Stephan Herrmann and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     Stephan Herrmann - initial API and implementation 
+ *     Stephan Herrmann - initial API and implementation
+ *     IBM Corporation - bug fixes
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
-import static java.lang.annotation.ElementType.*;
-import java.lang.annotation.*;
+import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
  
 /**
- * <p>
  * Qualifier for a type in a method signature or a local variable declaration:
  * The entity (return value, parameter, local variable) whose type has this
  * annotation can never have the value <code>null</code> at runtime.
@@ -24,7 +30,7 @@ import java.lang.annotation.*;
  * <li>Dereferencing the entity is safe, i.e., no <code>NullPointerException</code> can occur at runtime.</li>
  * <li>An attempt to bind a <code>null</code> value to the entity is a compile time error.</li>
  * </ol>
- * For the second case diagnostics issued by the compiler should distinguish three situations:
+ * For the second case, diagnostics issued by the compiler should distinguish three situations:
  * <ol>
  * <li>Nullness of the value can be statically determined, the entity is definitely bound from either of:
  *     <ul><li>the value <code>null</code>, or</li>
@@ -34,12 +40,11 @@ import java.lang.annotation.*;
  *     null annotations are lacking.</li>
  * </ol>
  * </p>
- * @version 1.0
- * @author Stephan Herrmann
+ * @since 1.0
  */
-@Retention(RetentionPolicy.CLASS)
 @Documented
-@Target({METHOD,PARAMETER,LOCAL_VARIABLE})
+@Retention(RetentionPolicy.CLASS)
+@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface NonNull {
-
+	// marker annotation with no members
 }
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
index 7e15ab7..0ef1cac 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/NonNullByDefault.java
@@ -1,46 +1,52 @@
 /*******************************************************************************
- * Copyright (c) 2011 Stephan Herrmann.
+ * Copyright (c) 2011 Stephan Herrmann and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     Stephan Herrmann - initial API and implementation 
+ *     Stephan Herrmann - initial API and implementation
+ *     IBM Corporation - bug fixes
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
-import static java.lang.annotation.ElementType.*;
-import java.lang.annotation.*;
+import static java.lang.annotation.ElementType.CONSTRUCTOR;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PACKAGE;
+import static java.lang.annotation.ElementType.TYPE;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
  
 /**
- * <p>
  * This annotation can be applied to a package, type, method or constructor in order to 
  * define that all contained entities for which a null annotation is otherwise lacking
  * should be considered as {@link NonNull @NonNull}.
  * <dl>
  * <dt>Canceling a default</dt>
- * <dd>By using a <code>@NonNullByDefault</code> annotation with the parameter <code>false</code>
+ * <dd>By using a <code>@NonNullByDefault</code> annotation with the argument <code>false</code>,
  * a default from any enclosing scope can be canceled for the element being annotated.
  * <dt>Nested defaults</dt>
  * <dd>If a <code>@NonNullByDefault</code>
  * annotation is used within the scope of another <code>@NonNullByDefault</code>
- * annotation or a project wide default setting the inner most annotation defines the
+ * annotation or a project-wide default setting, the innermost annotation defines the
  * default applicable at any given position (depending on the parameter {@link #value()}).</dd>
  * </dl>
- * Note that for applying an annotation to a package a file by the name
+ * Note that for applying an annotation to a package, a file by the name
  * <code>package-info.java</code> is used.
  * 
- * @version 1.0
- * @author Stephan Herrmann
+ * @since 1.0
  */
-@Retention(RetentionPolicy.CLASS)
 @Documented
-@Target({PACKAGE,TYPE,METHOD,CONSTRUCTOR})
+@Retention(RetentionPolicy.CLASS)
+@Target({ PACKAGE, TYPE, METHOD, CONSTRUCTOR })
 public @interface NonNullByDefault {
 	/**
-	 * When parameterized with <code>false</code> the annotation specifies that the current element
-	 * should not apply any default to un-annotated types.
+	 * When parameterized with <code>false</code>, the annotation specifies that the current element should not apply
+	 * any default to un-annotated types.
 	 */
 	boolean value() default true;
 }
diff --git a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
index a719c90..41f93cd 100644
--- a/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
+++ b/org.eclipse.jdt.annotation/src/org/eclipse/jdt/annotation/Nullable.java
@@ -1,20 +1,26 @@
 /*******************************************************************************
- * Copyright (c) 2011 Stephan Herrmann.
+ * Copyright (c) 2011 Stephan Herrmann and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
- *     Stephan Herrmann - initial API and implementation 
+ *     Stephan Herrmann - initial API and implementation
+ *     IBM Corporation - bug fixes
  *******************************************************************************/
 package org.eclipse.jdt.annotation;
 
-import static java.lang.annotation.ElementType.*;
-import java.lang.annotation.*;
+import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
  
 /**
- * <p>
  * Qualifier for a type in a method signature or a local variable declaration:
  * The entity (return value, parameter, local variable) whose type has this
  * annotation is allowed to have the value <code>null</code> at runtime.
@@ -25,12 +31,11 @@ import java.lang.annotation.*;
  * <li>Dereferencing the entity is unsafe, i.e., a <code>NullPointerException</code> can occur at runtime.</li>
  * </ul>
  * </p>
- * @version 1.0
- * @author Stephan Herrmann
+ * @since 1.0
  */
-@Retention(RetentionPolicy.CLASS)
 @Documented
-@Target({METHOD,PARAMETER,LOCAL_VARIABLE})
+@Retention(RetentionPolicy.CLASS)
+@Target({ METHOD, PARAMETER, LOCAL_VARIABLE })
 public @interface Nullable {
-
+	// marker annotation with no members
 }
\ No newline at end of file
commit f1f57e41ab9863b278a86075e156c0add6e26b8f
Author: Markus Keller <mkeller>
Date:   Thu Dec 1 17:20:42 2011 +0100

    Bug 186342: [compiler][null] Using annotations for null checking
    - API cleanup

20	14	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 570c5c6..86bc69f 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1416,17 +1416,19 @@ public final class JavaCore extends Plugin {
 	 * Compiler option ID: Annotation-based Null Analysis.
 	 * <p>This option controls whether the compiler will use null annotations for
 	 *    improved analysis of (potential) null references.</p>
-	 * <p>If enabled the compiler will interpret the annotation types defined using
+	 * <p>When enabled, the compiler will interpret the annotation types defined using
 	 *    {@link #COMPILER_NONNULL_ANNOTATION_NAME} and {@link #COMPILER_NULLABLE_ANNOTATION_NAME}
 	 *    as specifying whether or not a given type includes the value <code>null</code>.</p>
-	 * <p>The effect of these analyses is further controled by the options
+	 * <p>The effect of these analyses is further controlled by the options
 	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
 	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
 	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
 	 * </p>
+	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullanalysis"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code></dd>
 	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
@@ -1436,11 +1438,11 @@ public final class JavaCore extends Plugin {
 	 * <p>This option defines a fully qualified Java type name that the compiler may use
 	 *    to perform special null analysis.</p>
 	 * <p>If the annotation specified by this option is applied to a type in a method
-	 *    signature or variable declaration this will be interpreted as a specification
+	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is a legal value in that position. Currently supported
 	 *    positions are: method parameters, method return type and local variables.</p>
 	 * <p>If a value whose type
-	 *    is annotated with this annotation is dereferenced without checking for null
+	 *    is annotated with this annotation is dereferenced without checking for null,
 	 *    the compiler will trigger a diagnostic as further controlled by
 	 *    {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}.</p>
 	 * <p>The compiler may furthermore check adherence to the null specification as
@@ -1448,10 +1450,11 @@ public final class JavaCore extends Plugin {
 	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
 	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
 	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
-	 * </p>
+	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code></dd>
-	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name, must resolve to an annotation type.</dd>
+	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name; must resolve to an annotation type.</dd>
 	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.Nullable"</code></dd>
+	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
@@ -1461,10 +1464,10 @@ public final class JavaCore extends Plugin {
 	 * <p>This option defines a fully qualified Java type name that the compiler may use
 	 *    to perform special null analysis.</p>
 	 * <p>If the annotation specified by this option is applied to a type in a method
-	 *    signature or variable declaration this will be interpreted as a specification
+	 *    signature or variable declaration, this will be interpreted as a specification
 	 *    that <code>null</code> is <b>not</b> a legal value in that position. Currently
 	 *    supported positions are: method parameters, method return type and local variables.</p>
-	 * <p>For values declared with this annotation the compiler will never trigger a null
+	 * <p>For values declared with this annotation, the compiler will never trigger a null
 	 *    reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
 	 *    and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
 	 *    will never occur at runtime in these positions.</p>
@@ -1475,8 +1478,9 @@ public final class JavaCore extends Plugin {
 	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code></dd>
-	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name, must resolve to an annotation type.</dd>
+	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name; must resolve to an annotation type.</dd>
 	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.NonNull"</code></dd>
+	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
@@ -1485,7 +1489,7 @@ public final class JavaCore extends Plugin {
 	 * Compiler option ID: Name of Annotation Type to specify a nullness default for unannotated types.
 	 * <p>This option defines a fully qualified Java type name that the compiler may use
 	 *    to perform special null analysis.</p>
-	 * <p>If the annotation is applied without an argument all unannotated types in method signatures
+	 * <p>If the annotation is applied without an argument, all unannotated types in method signatures
 	 *    within the annotated element will be treated as if they were specified with the non-null annotation
 	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).</p>
 	 * <p>If the annotation is applied with the constant <code>false</code> as its argument
@@ -1495,22 +1499,24 @@ public final class JavaCore extends Plugin {
 	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"</code></dd>
-	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name, must resolve to an annotation type.
+	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name; must resolve to an annotation type.
 	 *     That annotation type should have exactly one boolean parameter.</dd>
-	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.NonNullByDefault"</code></dd></dl>
+	 * <dt>Default:</dt><dd><code>"org.eclipse.jdt.annotation.NonNullByDefault"</code></dd>
+	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
 	public static final String COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME = PLUGIN_ID + ".compiler.annotation.nonnullbydefault"; //$NON-NLS-1$
 	/**
 	 * Compiler option ID: Globally specify non-null as the assumed default for unannotated types.
-	 * <p>When enabled this option globally achieves the same effect 
+	 * <p>When enabled, this option globally achieves the same effect 
 	 *    as specifying {@link #COMPILER_NONNULL_ANNOTATION_NAME} does for individual elements.</p>
 	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code>.</dd>
 	 * <dt>Default:</dt><dd><code>"disabled"</code></dd>
+	 * </dl>
 	 * @since 3.8
 	 * @category CompilerOptionID
 	 */
@@ -1616,7 +1622,7 @@ public final class JavaCore extends Plugin {
 	 * <p>When enabled, the compiler will issue an error or a warning when a non-null annotation
 	 *    (see {@link #COMPILER_NONNULL_ANNOTATION_NAME})
 	 *    is applied although the same effect is already achieved by a default applicable at the
-	 *    current location. Such default may be effective by enabling the option
+	 *    current location. Such a default may be set by enabling the option
 	 *    {@link #COMPILER_NONNULL_IS_DEFAULT} or by using the annotation specified by the option
 	 *    {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}.
 	 * </p>
commit 58f6afc12cba62ef8d27c501894e3dd000ed5c7a
Author: Stephan Herrmann <sherrmann>
Date:   Fri Dec 2 23:45:34 2011 +0100

    HEAD - Bug 186342: [compiler][null] Using annotations for null checking
    - adopt Markus' javadoc fixes into the buildnotes
    - more small javadoc fixes: removed stutter and cleanup white space

12	12	org.eclipse.jdt.core/buildnotes_jdt-core.html
10	10	org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
diff --git a/org.eclipse.jdt.core/buildnotes_jdt-core.html b/org.eclipse.jdt.core/buildnotes_jdt-core.html
index 8673444..b80f9d1 100644
--- a/org.eclipse.jdt.core/buildnotes_jdt-core.html
+++ b/org.eclipse.jdt.core/buildnotes_jdt-core.html
@@ -57,11 +57,11 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * This option controls whether the compiler will use null annotations for
      * improved analysis of (potential) null references.
      * 
-     * If enabled the compiler will interpret the annotation types defined using
+     * When enabled, the compiler will interpret the annotation types defined using
      * {@link #COMPILER_NONNULL_ANNOTATION_NAME} and {@link #COMPILER_NULLABLE_ANNOTATION_NAME}
      * as specifying whether or not a given type includes the value <code>null</code>.
      * 
-     * The effect of these analyses is further controled by the options
+     * The effect of these analyses is further controlled by the options
      * {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
      * {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
      * {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.
@@ -83,12 +83,12 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * to perform special null analysis.
      * 
      * If the annotation specified by this option is applied to a type in a method
-     * signature or variable declaration this will be interpreted as a specification
+     * signature or variable declaration, this will be interpreted as a specification
      * that <code>null</code> is a legal value in that position. Currently supported
      * positions are: method parameters, method return type and local variables.
      * 
      * If a value whose type
-     * is annotated with this annotation is dereferenced without checking for null
+     * is annotated with this annotation is dereferenced without checking for null,
      * the compiler will trigger a diagnostic as further controlled by
      * {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}.
      * 
@@ -100,7 +100,7 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
      * 
      * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code>
-     * Possible values: any legal, fully qualified Java type name, must resolve to an annotation type.
+     * Possible values: any legal, fully qualified Java type name; must resolve to an annotation type.
      * Default: <code>"org.eclipse.jdt.annotation.Nullable"</code>
      * @since 3.8
      * @category CompilerOptionID
@@ -116,11 +116,11 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * to perform special null analysis.
      * 
      * If the annotation specified by this option is applied to a type in a method
-     * signature or variable declaration this will be interpreted as a specification
+     * signature or variable declaration, this will be interpreted as a specification
      * that <code>null</code> is <b>not</b> a legal value in that position. Currently
      * supported positions are: method parameters, method return type and local variables.
      * 
-     * For values declared with this annotation the compiler will never trigger a null
+     * For values declared with this annotation, the compiler will never trigger a null
      * reference diagnostic (as controlled by {@link #COMPILER_PB_POTENTIAL_NULL_REFERENCE}
      * and {@link #COMPILER_PB_NULL_REFERENCE}), because the assumption is made that null
      * will never occur at runtime in these positions.
@@ -133,7 +133,7 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
      * 
      * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code>
-     * Possible values: any legal, fully qualified Java type name, must resolve to an annotation type.
+     * Possible values: any legal, fully qualified Java type name; must resolve to an annotation type.
      * Default: <code>"org.eclipse.jdt.annotation.NonNull"</code>
      * @since 3.8
      * @category CompilerOptionID
@@ -148,7 +148,7 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * This option defines a fully qualified Java type name that the compiler may use
      * to perform special null analysis.
      * 
-     * If the annotation is applied without an argument all unannotated types in method signatures
+     * If the annotation is applied without an argument, all unannotated types in method signatures
      * within the annotated element will be treated as if they were specified with the non-null annotation
      * (see {@link #COMPILER_NONNULL_ANNOTATION_NAME}).
      * 
@@ -160,7 +160,7 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
      * 
      * Option id: <code>"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"</code>
-     * Possible values: any legal, fully qualified Java type name, must resolve to an annotation type.
+     * Possible values: any legal, fully qualified Java type name; must resolve to an annotation type.
      *     That annotation type should have exactly one boolean parameter.
      * Default: <code>"org.eclipse.jdt.annotation.NonNullByDefault"</code>
      * @since 3.8
@@ -283,7 +283,7 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * shall interpret as nonnull or nullable annotations, respectively.
      * 
      * This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.
-     * <dl>
+     * 
      * Option id: <code>"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo"</code>
      * Possible values: <code>{ "error", "warning", "ignore" }</code>
      * Default: <code>"warning"</code>
@@ -301,7 +301,7 @@ Eclipse SDK 3.8.0 - December 2, 2011 - 3.8.0 M4
      * When enabled, the compiler will issue an error or a warning when a non-null annotation
      * (see {@link #COMPILER_NONNULL_ANNOTATION_NAME})
      * is applied although the same effect is already achieved by a default applicable at the
-     * current location. Such default may be effective by enabling the option
+     * current location. Such a default may be effective by enabling the option
      * {@link #COMPILER_NONNULL_IS_DEFAULT} or by using the annotation specified by the option
      * {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}.
      * 
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
index 86bc69f..5898902 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java
@@ -1449,7 +1449,7 @@ public final class JavaCore extends Plugin {
 	 *    further controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
 	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
 	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nullable"</code></dd>
 	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name; must resolve to an annotation type.</dd>
@@ -1475,7 +1475,7 @@ public final class JavaCore extends Plugin {
 	 *    controlled by {@link #COMPILER_PB_NULL_SPECIFICATION_VIOLATION},
 	 *    {@link #COMPILER_PB_POTENTIAL_NULL_SPECIFICATION_VIOLATION} and
 	 *    {@link #COMPILER_PB_NULL_SPECIFICATION_INSUFFICIENT_INFO}.</p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnull"</code></dd>
 	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name; must resolve to an annotation type.</dd>
@@ -1496,7 +1496,7 @@ public final class JavaCore extends Plugin {
 	 *    all corresponding defaults at outer scopes will be canceled for the annotated element.
 	 *    This includes defaults specified using this annotation type or a default defined using
 	 *    the compiler option {@link #COMPILER_NONNULL_IS_DEFAULT}.</p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullbydefault"</code></dd>
 	 * <dt>Possible values:</dt><dd>any legal, fully qualified Java type name; must resolve to an annotation type.
@@ -1511,7 +1511,7 @@ public final class JavaCore extends Plugin {
 	 * Compiler option ID: Globally specify non-null as the assumed default for unannotated types.
 	 * <p>When enabled, this option globally achieves the same effect 
 	 *    as specifying {@link #COMPILER_NONNULL_ANNOTATION_NAME} does for individual elements.</p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.annotation.nonnullisdefault"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "disabled", "enabled" }</code>.</dd>
@@ -1546,7 +1546,7 @@ public final class JavaCore extends Plugin {
 	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
 	 *    shall interpret as nonnull or nullable annotations, respectively.
 	 * </p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullSpecViolation"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning" }</code></dd>
@@ -1574,7 +1574,7 @@ public final class JavaCore extends Plugin {
 	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
 	 *    shall interpret as nonnull or nullable annotations, respectively.
 	 * </p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.potentialNullSpecViolation"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
@@ -1589,12 +1589,12 @@ public final class JavaCore extends Plugin {
 	 * <p>When enabled, the compiler will issue an error or a warning whenever one of the
 	 *    following situations is detected:
 	 *    <ol>
-	 *    <li>A method declared with a nonnull annotation returns an expression for	which
+	 *    <li>A method declared with a nonnull annotation returns an expression for which
 	 *        insufficient nullness information is available for statically proving that no
 	 *        flow will pass a null value at runtime.</li>
 	 *    <li>An expression for which insufficient nullness information is available for
 	 *        statically proving that it will never evaluate to a null value at runtime
-	 *        is passed as an argument in a method call where the corresponding	parameter of
+	 *        is passed as an argument in a method call where the corresponding parameter of
 	 *        the called method is declared with a nonnull annotation.</li>
 	 *    <li>An expression for which insufficient nullness information is available for
 	 *        statically proving that it will never evaluate to a null value at runtime
@@ -1607,7 +1607,7 @@ public final class JavaCore extends Plugin {
 	 *    {@link #COMPILER_NULLABLE_ANNOTATION_NAME} control which annotations the compiler
 	 *    shall interpret as nonnull or nullable annotations, respectively.
 	 * </p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.nullSpecInsufficientInfo"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
@@ -1626,7 +1626,7 @@ public final class JavaCore extends Plugin {
 	 *    {@link #COMPILER_NONNULL_IS_DEFAULT} or by using the annotation specified by the option
 	 *    {@link #COMPILER_NONNULL_BY_DEFAULT_ANNOTATION_NAME}.
 	 * </p>
-	 * <p>This option only has an effect if the the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
+	 * <p>This option only has an effect if the option {@link #COMPILER_ANNOTATION_NULL_ANALYSIS} is enabled.</p>
 	 * <dl>
 	 * <dt>Option id:</dt><dd><code>"org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation"</code></dd>
 	 * <dt>Possible values:</dt><dd><code>{ "error", "warning", "ignore" }</code></dd>
