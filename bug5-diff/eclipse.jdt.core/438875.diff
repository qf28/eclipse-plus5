commit f24a77ad357e70fcffddb8d1e5ab0bdc69ca2a2a
Author: Markus Keller <markus_keller@ch.ibm.com>
Date:   Thu Jul 3 20:52:54 2014 +0200

    Bug 438875: Set correct project/file encodings and use Unix line delimiter

2	0	org.eclipse.jdt.annotation/.settings/org.eclipse.core.resources.prefs
364	364	org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
2	0	org.eclipse.jdt.annotation_v1/.settings/org.eclipse.core.resources.prefs
364	364	org.eclipse.jdt.annotation_v1/.settings/org.eclipse.jdt.core.prefs
5	5	org.eclipse.jdt.apt.core/.settings/org.eclipse.core.resources.prefs
2	0	org.eclipse.jdt.apt.pluggable.core/.settings/org.eclipse.core.resources.prefs
2	0	org.eclipse.jdt.apt.pluggable.tests/.settings/org.eclipse.core.resources.prefs
2	0	org.eclipse.jdt.apt.tests/.settings/org.eclipse.core.resources.prefs
1	1	org.eclipse.jdt.apt.ui/.settings/org.eclipse.core.resources.prefs
2	0	org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.resources.prefs
2	2	org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.runtime.prefs
30	30	org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc
2	0	org.eclipse.jdt.compiler.apt/.settings/org.eclipse.core.resources.prefs
2	0	org.eclipse.jdt.compiler.tool.tests/.settings/org.eclipse.core.resources.prefs
2	0	org.eclipse.jdt.compiler.tool/.settings/org.eclipse.core.resources.prefs
4	4	org.eclipse.jdt.compiler.tool/forceQualifierUpdate.txt
2	0	org.eclipse.jdt.core.tests.builder/.settings/org.eclipse.core.resources.prefs
1	2	org.eclipse.jdt.core.tests.compiler/.settings/org.eclipse.core.resources.prefs
3792	3792	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
52	52	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InstanceofExpressionTest.java
4486	4486	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
2	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
3	3	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
3	5	org.eclipse.jdt.core.tests.model/.settings/org.eclipse.core.resources.prefs
2571	2571	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
1	1	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
5	5	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MatchingRegionsTest.java
3	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_in.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_out.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_in.java
2	2	org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_out.java
2	0	org.eclipse.jdt.core.tests.performance/.settings/org.eclipse.core.resources.prefs
2	2	org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java
3	0	org.eclipse.jdt.core/.settings/org.eclipse.core.resources.prefs
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
349	349	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
114	114	org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
59	59	org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IConstantPoolEntry2.java
5	5	org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
diff --git a/org.eclipse.jdt.annotation/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.annotation/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.annotation/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
index fb5e5f1..065d1e8 100644
--- a/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
+++ b/org.eclipse.jdt.annotation/.settings/org.eclipse.jdt.core.prefs
@@ -1,364 +1,364 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.builder.cleanOutputFolder=clean
-org.eclipse.jdt.core.builder.duplicateResourceTask=warning
-org.eclipse.jdt.core.builder.invalidClasspath=abort
-org.eclipse.jdt.core.builder.recreateModifiedClassFileInOutputFolder=ignore
-org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch,.svn/
-org.eclipse.jdt.core.circularClasspath=error
-org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
-org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.7
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.doc.comment.support=enabled
-org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
-org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.autoboxing=warning
-org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
-org.eclipse.jdt.core.compiler.problem.deadCode=warning
-org.eclipse.jdt.core.compiler.problem.deprecation=warning
-org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
-org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
-org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
-org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=warning
-org.eclipse.jdt.core.compiler.problem.fallthroughCase=warning
-org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
-org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
-org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
-org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
-org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
-org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
-org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
-org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
-org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
-org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=warning
-org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
-org.eclipse.jdt.core.compiler.problem.localVariableHiding=warning
-org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
-org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
-org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=warning
-org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
-org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
-org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
-org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
-org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
-org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=warning
-org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
-org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
-org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
-org.eclipse.jdt.core.compiler.problem.nullReference=warning
-org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
-org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
-org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
-org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
-org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=warning
-org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
-org.eclipse.jdt.core.compiler.problem.redundantNullCheck=warning
-org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=warning
-org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=warning
-org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
-org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
-org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
-org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
-org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
-org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
-org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
-org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
-org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=disabled
-org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
-org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
-org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=warning
-org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
-org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
-org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
-org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=warning
-org.eclipse.jdt.core.compiler.problem.unsafeTypeOperation=warning
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
-org.eclipse.jdt.core.compiler.problem.unusedImport=error
-org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
-org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
-org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=warning
-org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
-org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
-org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
-org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
-org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
-org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
-org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.source=1.7
-org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_assignment=0
-org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
-org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
-org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
-org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
-org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
-org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
-org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
-org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
-org.eclipse.jdt.core.formatter.blank_lines_after_package=1
-org.eclipse.jdt.core.formatter.blank_lines_before_field=0
-org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
-org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
-org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
-org.eclipse.jdt.core.formatter.blank_lines_before_method=1
-org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
-org.eclipse.jdt.core.formatter.blank_lines_before_package=0
-org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
-org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
-org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
-org.eclipse.jdt.core.formatter.comment.format_block_comments=true
-org.eclipse.jdt.core.formatter.comment.format_header=false
-org.eclipse.jdt.core.formatter.comment.format_html=true
-org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
-org.eclipse.jdt.core.formatter.comment.format_line_comments=true
-org.eclipse.jdt.core.formatter.comment.format_source_code=true
-org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
-org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
-org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
-org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
-org.eclipse.jdt.core.formatter.comment.line_length=120
-org.eclipse.jdt.core.formatter.compact_else_if=true
-org.eclipse.jdt.core.formatter.continuation_indentation=2
-org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
-org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
-org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
-org.eclipse.jdt.core.formatter.indent_empty_lines=false
-org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
-org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
-org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
-org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=true
-org.eclipse.jdt.core.formatter.indentation.size=4
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
-org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
-org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
-org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
-org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
-org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
-org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
-org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
-org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
-org.eclipse.jdt.core.formatter.lineSplit=120
-org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
-org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
-org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
-org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
-org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
-org.eclipse.jdt.core.formatter.tabulation.char=tab
-org.eclipse.jdt.core.formatter.tabulation.size=4
-org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
-org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
-org.eclipse.jdt.core.incompatibleJDKLevel=ignore
-org.eclipse.jdt.core.incompleteClasspath=error
+eclipse.preferences.version=1
+org.eclipse.jdt.core.builder.cleanOutputFolder=clean
+org.eclipse.jdt.core.builder.duplicateResourceTask=warning
+org.eclipse.jdt.core.builder.invalidClasspath=abort
+org.eclipse.jdt.core.builder.recreateModifiedClassFileInOutputFolder=ignore
+org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch,.svn/
+org.eclipse.jdt.core.circularClasspath=error
+org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
+org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=warning
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=warning
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=warning
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=warning
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=warning
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=warning
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=warning
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=warning
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=warning
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=disabled
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=warning
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=warning
+org.eclipse.jdt.core.compiler.problem.unsafeTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=error
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.source=1.7
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=0
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
+org.eclipse.jdt.core.formatter.comment.line_length=120
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=2
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=true
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=120
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=tab
+org.eclipse.jdt.core.formatter.tabulation.size=4
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.incompatibleJDKLevel=ignore
+org.eclipse.jdt.core.incompleteClasspath=error
diff --git a/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.jdt.core.prefs
index ccd5771..1708bb9 100644
--- a/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.jdt.core.prefs
+++ b/org.eclipse.jdt.annotation_v1/.settings/org.eclipse.jdt.core.prefs
@@ -1,364 +1,364 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.builder.cleanOutputFolder=clean
-org.eclipse.jdt.core.builder.duplicateResourceTask=warning
-org.eclipse.jdt.core.builder.invalidClasspath=abort
-org.eclipse.jdt.core.builder.recreateModifiedClassFileInOutputFolder=ignore
-org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch,.svn/
-org.eclipse.jdt.core.circularClasspath=error
-org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
-org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.5
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.doc.comment.support=enabled
-org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
-org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.autoboxing=warning
-org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
-org.eclipse.jdt.core.compiler.problem.deadCode=warning
-org.eclipse.jdt.core.compiler.problem.deprecation=warning
-org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
-org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
-org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
-org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=warning
-org.eclipse.jdt.core.compiler.problem.fallthroughCase=warning
-org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
-org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
-org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
-org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
-org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
-org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
-org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
-org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
-org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
-org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=warning
-org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
-org.eclipse.jdt.core.compiler.problem.localVariableHiding=warning
-org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
-org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
-org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=warning
-org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
-org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
-org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
-org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
-org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
-org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=warning
-org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
-org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
-org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
-org.eclipse.jdt.core.compiler.problem.nullReference=warning
-org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
-org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
-org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
-org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
-org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=warning
-org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
-org.eclipse.jdt.core.compiler.problem.redundantNullCheck=warning
-org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=warning
-org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=warning
-org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
-org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
-org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
-org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
-org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
-org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
-org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
-org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
-org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=disabled
-org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
-org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
-org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=warning
-org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
-org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
-org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
-org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=warning
-org.eclipse.jdt.core.compiler.problem.unsafeTypeOperation=warning
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
-org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
-org.eclipse.jdt.core.compiler.problem.unusedImport=error
-org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
-org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
-org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=warning
-org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
-org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
-org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
-org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
-org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
-org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
-org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.source=1.5
-org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
-org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_assignment=0
-org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
-org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
-org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
-org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
-org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
-org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
-org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
-org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
-org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
-org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
-org.eclipse.jdt.core.formatter.blank_lines_after_package=1
-org.eclipse.jdt.core.formatter.blank_lines_before_field=0
-org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
-org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
-org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
-org.eclipse.jdt.core.formatter.blank_lines_before_method=1
-org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
-org.eclipse.jdt.core.formatter.blank_lines_before_package=0
-org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
-org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
-org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
-org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
-org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
-org.eclipse.jdt.core.formatter.comment.format_block_comments=true
-org.eclipse.jdt.core.formatter.comment.format_header=false
-org.eclipse.jdt.core.formatter.comment.format_html=true
-org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
-org.eclipse.jdt.core.formatter.comment.format_line_comments=true
-org.eclipse.jdt.core.formatter.comment.format_source_code=true
-org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
-org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
-org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
-org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
-org.eclipse.jdt.core.formatter.comment.line_length=120
-org.eclipse.jdt.core.formatter.compact_else_if=true
-org.eclipse.jdt.core.formatter.continuation_indentation=2
-org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
-org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
-org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
-org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
-org.eclipse.jdt.core.formatter.indent_empty_lines=false
-org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
-org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
-org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
-org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=true
-org.eclipse.jdt.core.formatter.indentation.size=4
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
-org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
-org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
-org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
-org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
-org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
-org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
-org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
-org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
-org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
-org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
-org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
-org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
-org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
-org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
-org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
-org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
-org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
-org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
-org.eclipse.jdt.core.formatter.lineSplit=120
-org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
-org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
-org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
-org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
-org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
-org.eclipse.jdt.core.formatter.tabulation.char=tab
-org.eclipse.jdt.core.formatter.tabulation.size=4
-org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
-org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
-org.eclipse.jdt.core.incompatibleJDKLevel=ignore
-org.eclipse.jdt.core.incompleteClasspath=error
+eclipse.preferences.version=1
+org.eclipse.jdt.core.builder.cleanOutputFolder=clean
+org.eclipse.jdt.core.builder.duplicateResourceTask=warning
+org.eclipse.jdt.core.builder.invalidClasspath=abort
+org.eclipse.jdt.core.builder.recreateModifiedClassFileInOutputFolder=ignore
+org.eclipse.jdt.core.builder.resourceCopyExclusionFilter=*.launch,.svn/
+org.eclipse.jdt.core.circularClasspath=error
+org.eclipse.jdt.core.classpath.exclusionPatterns=enabled
+org.eclipse.jdt.core.classpath.multipleOutputLocations=enabled
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.maxProblemPerUnit=100
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=warning
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=warning
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=warning
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=warning
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=warning
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=warning
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=warning
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=warning
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=warning
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=warning
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=disabled
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=warning
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=warning
+org.eclipse.jdt.core.compiler.problem.unsafeTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=error
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.source=1.5
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=0
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=insert
+org.eclipse.jdt.core.formatter.comment.line_length=120
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=2
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=2
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=true
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_member=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=120
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=tab
+org.eclipse.jdt.core.formatter.tabulation.size=4
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.incompatibleJDKLevel=ignore
+org.eclipse.jdt.core.incompleteClasspath=error
diff --git a/org.eclipse.jdt.apt.core/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.apt.core/.settings/org.eclipse.core.resources.prefs
index bf068cf..3a00875 100644
--- a/org.eclipse.jdt.apt.core/.settings/org.eclipse.core.resources.prefs
+++ b/org.eclipse.jdt.apt.core/.settings/org.eclipse.core.resources.prefs
@@ -1,5 +1,5 @@
-#Mon Mar 20 17:21:22 PST 2006
-eclipse.preferences.version=1
-encoding//src/org/eclipse/jdt/apt/core/internal/build/messages.properties=8859_1
-encoding//src/org/eclipse/jdt/apt/core/internal/messages.properties=8859_1
-encoding//src/org/eclipse/jdt/apt/core/internal/util/messages.properties=8859_1
+eclipse.preferences.version=1
+encoding//src/org/eclipse/jdt/apt/core/internal/build/messages.properties=8859_1
+encoding//src/org/eclipse/jdt/apt/core/internal/messages.properties=8859_1
+encoding//src/org/eclipse/jdt/apt/core/internal/util/messages.properties=8859_1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.apt.pluggable.core/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.apt.pluggable.core/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.apt.pluggable.core/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.apt.pluggable.tests/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.apt.pluggable.tests/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.apt.pluggable.tests/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.apt.tests/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.apt.tests/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.apt.tests/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.apt.ui/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.apt.ui/.settings/org.eclipse.core.resources.prefs
index c122636..8c3ea6e 100644
--- a/org.eclipse.jdt.apt.ui/.settings/org.eclipse.core.resources.prefs
+++ b/org.eclipse.jdt.apt.ui/.settings/org.eclipse.core.resources.prefs
@@ -1,5 +1,5 @@
-#Mon Mar 20 23:59:29 PST 2006
 eclipse.preferences.version=1
 encoding//src/org/eclipse/jdt/apt/ui/internal/messages.properties=8859_1
 encoding//src/org/eclipse/jdt/apt/ui/internal/preferences/messages.properties=8859_1
 encoding//src/org/eclipse/jdt/apt/ui/internal/util/messages.properties=8859_1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.runtime.prefs b/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.runtime.prefs
index c522e1f..5a0ad22 100644
--- a/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.runtime.prefs
+++ b/org.eclipse.jdt.compiler.apt.tests/.settings/org.eclipse.core.runtime.prefs
@@ -1,2 +1,2 @@
-eclipse.preferences.version=1
-line.separator=\n
+eclipse.preferences.version=1
+line.separator=\n
diff --git a/org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc b/org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc
index ad05fa8..3956369 100644
--- a/org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc
+++ b/org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc
@@ -1,30 +1,30 @@
-<?xml version="1.0" encoding="WINDOWS-1252" standalone="no"?>
-<jardesc>
-    <jar path="org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors8.jar"/>
-    <options buildIfNeeded="true" compress="true" descriptionLocation="/org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc" exportErrors="false" exportWarnings="true" includeDirectoryEntries="false" overwrite="true" saveDescription="true" storeRefactorings="false" useSourceFolders="false"/>
-    <storedRefactorings deprecationInfo="true" structuralOnly="false"/>
-    <selectedProjects/>
-    <manifest generateManifest="true" manifestLocation="" manifestVersion="1.0" reuseManifest="false" saveManifest="false" usesManifest="true">
-        <sealing sealJar="false">
-            <packagesToSeal/>
-            <packagesToUnSeal/>
-        </sealing>
-    </manifest>
-    <selectedElements exportClassFiles="true" exportJavaFiles="true" exportOutputFolder="false">
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.filer"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors8"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.annotations"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.elementutils"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.visitors"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.elements"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.messager"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.checkargs"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.genclass"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.negative"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.typeutils"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.typemirror"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.base"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.generics"/>
-        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.inherited"/>
-    </selectedElements>
-</jardesc>
+<?xml version="1.0" encoding="WINDOWS-1252" standalone="no"?>
+<jardesc>
+    <jar path="org.eclipse.jdt.compiler.apt.tests/lib/apttestprocessors8.jar"/>
+    <options buildIfNeeded="true" compress="true" descriptionLocation="/org.eclipse.jdt.compiler.apt.tests/apttestprocessors8.jardesc" exportErrors="false" exportWarnings="true" includeDirectoryEntries="false" overwrite="true" saveDescription="true" storeRefactorings="false" useSourceFolders="false"/>
+    <storedRefactorings deprecationInfo="true" structuralOnly="false"/>
+    <selectedProjects/>
+    <manifest generateManifest="true" manifestLocation="" manifestVersion="1.0" reuseManifest="false" saveManifest="false" usesManifest="true">
+        <sealing sealJar="false">
+            <packagesToSeal/>
+            <packagesToUnSeal/>
+        </sealing>
+    </manifest>
+    <selectedElements exportClassFiles="true" exportJavaFiles="true" exportOutputFolder="false">
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.filer"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors8"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.annotations"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.elementutils"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.visitors"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.elements"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.messager"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.checkargs"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.genclass"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.negative"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.typeutils"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.typemirror"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.base"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.generics"/>
+        <javaElement handleIdentifier="=org.eclipse.jdt.compiler.apt.tests/processors&lt;org.eclipse.jdt.compiler.apt.tests.processors.inherited"/>
+    </selectedElements>
+</jardesc>
diff --git a/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.compiler.apt/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.compiler.tool.tests/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.compiler.tool.tests/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.compiler.tool.tests/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.compiler.tool/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.compiler.tool/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.compiler.tool/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.compiler.tool/forceQualifierUpdate.txt b/org.eclipse.jdt.compiler.tool/forceQualifierUpdate.txt
index 8e15390..75db5aa 100644
--- a/org.eclipse.jdt.compiler.tool/forceQualifierUpdate.txt
+++ b/org.eclipse.jdt.compiler.tool/forceQualifierUpdate.txt
@@ -1,5 +1,5 @@
-# To force a version qualifier update add the bug here
-Bug 403352 - Update all parent versions to match our build stream
-Bug 407853 - ECJ download misses legal file (about.html)
-Bug 386901 - Eclipse does not pass all annotated classes to annotation processor
+# To force a version qualifier update add the bug here
+Bug 403352 - Update all parent versions to match our build stream
+Bug 407853 - ECJ download misses legal file (about.html)
+Bug 386901 - Eclipse does not pass all annotated classes to annotation processor
 Bug 407852 - ECJ source download is not correct
\ No newline at end of file
diff --git a/org.eclipse.jdt.core.tests.builder/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.core.tests.builder/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.builder/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.core.tests.compiler/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.core.tests.compiler/.settings/org.eclipse.core.resources.prefs
index 0f2c123..99f26c0 100644
--- a/org.eclipse.jdt.core.tests.compiler/.settings/org.eclipse.core.resources.prefs
+++ b/org.eclipse.jdt.core.tests.compiler/.settings/org.eclipse.core.resources.prefs
@@ -1,3 +1,2 @@
-#Thu Sep 08 10:09:40 EDT 2011
 eclipse.preferences.version=1
-encoding//src/org/eclipse/jdt/core/tests/compiler/regression/ScannerTest.java=UTF-8
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
index 766416c..2984a4f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/parser/TypeAnnotationSyntaxTest.java
@@ -1,3792 +1,3792 @@
-/*******************************************************************************
- * Copyright (c) 2009, 2013 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
- *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
- *******************************************************************************/
-package org.eclipse.jdt.core.tests.compiler.parser;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.util.HashMap;
-import java.util.Map;
-import junit.framework.Test;
-import org.eclipse.jdt.core.tests.util.CompilerTestSetup;
-import org.eclipse.jdt.internal.compiler.ASTVisitor;
-import org.eclipse.jdt.internal.compiler.ast.Annotation;
-import org.eclipse.jdt.internal.compiler.ast.Argument;
-import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
-import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
-import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
-import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
-import org.eclipse.jdt.internal.compiler.ast.TypeReference;
-import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
-import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
-import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
-
-public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
-
-	private static String  jsr308TestScratchArea = "c:\\Jsr308TestScratchArea";
-	private static String referenceCompiler = "C:\\jdk-7-ea-bin-b75-windows-i586-30_oct_2009\\jdk7\\bin\\javac.exe";
-	
-	static {
-//		TESTS_NAMES = new String [] { "test0137" };
-	}
-	public static Class testClass() {
-		return TypeAnnotationSyntaxTest.class;
-	}
-	public void initialize(CompilerTestSetup setUp) {
-		super.initialize(setUp);
-	}
-	public static Test suite() {
-		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
-	}
-	
-	static final class LocationPrinterVisitor extends ASTVisitor {
-		TypeReference enclosingReference;
-		Map locations;
-
-		public LocationPrinterVisitor() {
-			this.locations = new HashMap();
-		}
-
-		public Map getLocations() {
-			return this.locations;
-		}
-		public boolean visit(FieldDeclaration fieldDeclaration, MethodScope scope) {
-			this.enclosingReference = fieldDeclaration.type;
-			return true;
-		}
-		public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
-			TypeReference returnType = methodDeclaration.returnType;
-			if (returnType != null) {
-				this.enclosingReference = returnType;
-				returnType.traverse(this, scope);
-			}
-			if (methodDeclaration.thrownExceptions != null) {
-				int thrownExceptionsLength = methodDeclaration.thrownExceptions.length;
-				for (int i = 0; i < thrownExceptionsLength; i++) {
-					TypeReference typeReference = methodDeclaration.thrownExceptions[i];
-					this.enclosingReference = typeReference;
-					typeReference.traverse(this, scope);
-				}
-			}
-			return false;
-		}
-		public boolean visit(Argument argument, ClassScope scope) {
-			this.enclosingReference = argument.type;
-			return true;
-		}
-		public boolean visit(Argument argument, BlockScope scope) {
-			this.enclosingReference = argument.type;
-			return true;
-		}
-		public boolean visit(MarkerAnnotation annotation, BlockScope scope) {
-			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
-			}
-			return false;
-		}
-		public boolean visit(SingleMemberAnnotation annotation, BlockScope scope) {
-			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
-			}
-			return false;
-		}
-		public boolean visit(NormalAnnotation annotation, BlockScope scope) {
-			if (this.enclosingReference != null) {
-				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
-			}
-			return false;
-		}
-		public void storeLocations(Annotation annotation, int[] tab) {
-			String key = String.valueOf(annotation);
-			if (this.locations.get(key) != null) {
-				return;
-			}
-			if (tab == null) {
-				this.locations.put(key, null);
-				return;
-			}
-			
-			StringBuffer buffer = new StringBuffer("[");
-			for (int i = 0, max = tab.length; i < max; i += 2) {
-				if (i > 0) {
-					buffer.append(", ");
-				}
-				switch (tab[i]) {
-				case 0:
-					buffer.append("ARRAY");
-					break;
-				case 1:
-					buffer.append("INNER_TYPE");
-					break;
-				case 2:
-					buffer.append("WILDCARD");
-					break;
-				case 3:
-					buffer.append("TYPE_ARGUMENT(").append(tab[i+1]).append(')');
-					break;
-				}
-			}
-			buffer.append(']');
-			this.locations.put(key, String.valueOf(buffer));
-		}
-
-		public boolean visit(ArrayTypeReference arrayReference, BlockScope scope) {
-			if (this.enclosingReference == null) return false;
-			return true;
-		}
-		public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
-			if (this.enclosingReference == null) return false;
-			return true;
-		}
-		public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
-			if (this.enclosingReference == null) return false;
-			return true;
-		}
-	}
-public TypeAnnotationSyntaxTest(String testName){
-	super(testName, referenceCompiler, jsr308TestScratchArea);
-	if (referenceCompiler != null) {
-		File f = new File(jsr308TestScratchArea);
-		if (!f.exists()) {
-			f.mkdir();
-		}
-		if (f.exists()) {
-			try {
-				OutputStreamWriter w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Marker.java")));
-				w.write("@interface Marker {}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Normal.java")));
-				w.write("@interface Normal {\n\tint value() default 10;\n}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "SingleMember.java")));
-				w.write("@interface SingleMember {\n\tint value() default 10;\n}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Positive.java")));
-				w.write("@interface Positive {}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Negative.java")));
-				w.write("@interface Negative{}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Readonly.java")));
-				w.write("@interface Readonly {}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "NonNull.java")));
-				w.write("@interface NonNull {}\n".toCharArray());
-				w.close();
-				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "HashMap.java")));
-				w.write("class HashMap<X,Y> {\n class Iterator {}; \n}\n".toCharArray());
-				w.close();
-				CHECK_ALL |= CHECK_JAVAC_PARSER;
-			} catch (IOException e) {
-				// ignore
-			}
-		}
-	}
-}
-
-static {
-//	TESTS_NAMES = new String[] { "test0038", "test0039", "test0040a" };
-//	TESTS_NUMBERS = new int[] { 133, 134, 135 };
-	if (!(new File(referenceCompiler).exists())) {
-		referenceCompiler = null;
-		jsr308TestScratchArea = null;
-	}
-}
-void traverse (File f) throws IOException {
-	if (f.isDirectory()) {
-		File [] files = f.listFiles();
-		for (int i = 0; i < files.length; i++) {
-			traverse(files[i]);
-		}
-	} else {
-		if (f.getName().endsWith(".java")) {
-			System.out.println(f.getCanonicalPath());
-			char [] contents = new char[(int) f.length()];
-			FileInputStream fs = new FileInputStream(f);
-			InputStreamReader isr = new InputStreamReader(fs);
-			isr.read(contents);
-			checkParse(contents, null, f.getCanonicalPath(), null);
-		}
-	}
-}
-public void _test000() throws IOException {
-	traverse(new File("C:\\jsr308tests"));
-}
-
-public void test0001() throws IOException {
-	String source = "@Marker class A extends String {}\n;" +
-					"@Marker class B extends @Marker String {}\n" +
-					"@Marker class C extends @Marker @SingleMember(0) String {}\n" +
-					"@Marker class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {}\n" +
-					"@Marker class E extends String {}\n;";
-
-	String expectedUnitToString = 
-		"@Marker class A extends String {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"@Marker class B extends @Marker String {\n" + 
-		"  B() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"@Marker class C extends @Marker @SingleMember(0) String {\n" + 
-		"  C() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"@Marker class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {\n" + 
-		"  D() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"@Marker class E extends String {\n" + 
-		"  E() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER , source.toCharArray(), null, "test0001", expectedUnitToString);
-}
-public void test0002() throws IOException {
-	String source = "class A extends String {}\n;" +
-					"class B extends @Marker String {}\n" +
-					"class C extends @Marker @SingleMember(0) String {}\n" +
-					"class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {}\n" +
-					"class E extends String {}\n;";
-    
-	String expectedUnitToString = 
-		"class A extends String {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"class B extends @Marker String {\n" + 
-		"  B() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"class C extends @Marker @SingleMember(0) String {\n" + 
-		"  C() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {\n" + 
-		"  D() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n" + 
-		"class E extends String {\n" + 
-		"  E() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0002", expectedUnitToString);
-}
-public void test0003() throws IOException {
-	String source = "@Marker class A implements Comparable, " +
-					"                   @Marker Serializable," +
-					"                   Cloneable {\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"@Marker class A implements Comparable, @Marker Serializable, Cloneable {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0003", expectedUnitToString);
-}
-public void test0004() throws IOException {
-	String source = "@Marker class A implements Comparable, " +
-					"                   @Marker @SingleMember(0) Serializable," +
-					"                   Cloneable {\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"@Marker class A implements Comparable, @Marker @SingleMember(0) Serializable, Cloneable {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0004", expectedUnitToString);
-}
-public void test0005() throws IOException {
-	String source = "@Marker class A implements Comparable, " +
-					"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
-					"                   Cloneable {\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"@Marker class A implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0005", expectedUnitToString);
-}
-public void test0006() throws IOException {
-	String source = "@Marker class A implements @Marker Comparable, " +
-					"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
-					"                   @Marker Cloneable {\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"@Marker class A implements @Marker Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, @Marker Cloneable {\n" +
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0006", expectedUnitToString);
-}
-public void test007() throws IOException {
-	String source = "@Marker class A extends Object implements Comparable, " +
-					"                   @Marker @SingleMember(10) @Normal(Value=0) Serializable," +
-					"                   Cloneable {\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"@Marker class A extends Object implements Comparable, @Marker @SingleMember(10) @Normal(Value = 0) Serializable, Cloneable {\n" +
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0007", expectedUnitToString);
-}
-public void test0008() throws IOException {
-	String source = "@Marker class A extends @Marker Object implements Comparable, " +
-					"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
-					"                   Cloneable {\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"@Marker class A extends @Marker Object implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0008", expectedUnitToString);
-}
-public void test0009() throws IOException {
-	String source = "@Marker class A extends @Marker @SingleMember(0) Object implements Comparable, " +
-	"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
-	"                   Cloneable {\n" +
-	"}\n";
-	String expectedUnitToString = 
-		"@Marker class A extends @Marker @SingleMember(0) Object implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0009", expectedUnitToString);
-}
-public void test0010() throws IOException {
-	String source = "@Marker class A extends @Marker @SingleMember(0) @Normal(Value=0) Object implements Comparable, " +
-	"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
-	"                   Cloneable {\n" +
-	"}\n";
-	String expectedUnitToString = 
-		"@Marker class A extends @Marker @SingleMember(0) @Normal(Value = 0) Object implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0010", expectedUnitToString);
-}
-public void test0011() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker String[] @Marker[][] s[] @SingleMember(0)[][] @Normal(Value = 0)[][];\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker String[] @Marker [][][] @SingleMember(0) [][] @Normal(Value = 0) [][] s;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0011", expectedUnitToString);
-}
-public void test0012() throws IOException {
-	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
-					"    int[] f[];\n" +
-					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
-					"    float[] p[];\n" +
-					"public static void main(String args[]) {\n" +
-					"    @Readonly String @Nullable[] @NonNull[] s;\n" +
-					"    s = new @Readonly String @NonNull[5] @Nullable[];\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
-		"  int[][] f;\n" + 
-		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    @Readonly String @Nullable [] @NonNull [] s;\n" + 
-		"    s = new @Readonly String @NonNull [5] @Nullable [];\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0012", expectedUnitToString);
-}
-public void test0013() throws IOException {
-	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
-					"    int[] f[];\n" +
-					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
-					"    float[] p[];\n" +
-					"public static void main(String args[]) {\n" +
-					"    @Readonly String s;\n" +
-					"	 s = new @Readonly String @NonNull[] @Nullable[] { {\"Hello\"}, {\"World\"}} [0][0];\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
-		"  int[][] f;\n" + 
-		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    @Readonly String s;\n" + 
-		"    s = new @Readonly String @NonNull [] @Nullable []{{\"Hello\"}, {\"World\"}}[0][0];\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0013", expectedUnitToString);
-}
-public void test0014() throws IOException {
-	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
-					"    int[] f[];\n" +
-					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
-					"    float[] p[];\n" +
-					"public static int main(String args[])[] @Marker[][] @Marker @SingleMember(0) @Normal(Value=0)[][] {\n" +
-					"    @Readonly String @Nullable[] @NonNull[] s;\n" +
-					"    s = new @Readonly String @NonNull[5] @Nullable[];\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
-		"  int[][] f;\n" + 
-		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static int[] @Marker [][] @Marker @SingleMember(0) @Normal(Value = 0) [][] main(String[] args) {\n" +
-		"    @Readonly String @Nullable [] @NonNull [] s;\n" + 
-		"    s = new @Readonly String @NonNull [5] @Nullable [];\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0014", expectedUnitToString);
-
-}
-public void test0015() throws IOException {
-	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
-					"    int[] f[];\n" +
-					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
-					"    float[] p[];\n" +
-					"public static int main(String args[])[] @Marker[][] @Marker @SingleMember(0) @Normal(Value=0)[][] {\n" +
-					"    @Readonly String @Nullable[] @NonNull[] s;\n" +
-					"    s = new @Readonly String @NonNull[5] @Nullable[];\n" +
-					"}\n" +
-					"@Marker public A () {}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
-		"  int[][] f;\n" + 
-		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
-		"  float[][] p;\n" + 
-		"  public static int[] @Marker [][] @Marker @SingleMember(0) @Normal(Value = 0) [][] main(String[] args) {\n" + 
-		"    @Readonly String @Nullable [] @NonNull [] s;\n" + 
-		"    s = new @Readonly String @NonNull [5] @Nullable [];\n" + 
-		"  }\n" + 
-		"  public @Marker A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0015", expectedUnitToString);
-}
-// parameters
-public void test0016() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(int[] @SingleMember(10)[][] args[] @Normal(Value = 10)[][])[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(int[] @SingleMember(10) [][][] @Normal(Value = 10) [][] args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0016", expectedUnitToString);
-}
-public void test0017() throws IOException  {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(String[] @SingleMember(10)[][] args[] @Normal(Value = 10)[][])[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(String[] @SingleMember(10) [][][] @Normal(Value = 10) [][] args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0017", expectedUnitToString);
-}
-public void test0018() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(HashMap<String, Object>[] @SingleMember(10)[][] args[] @Normal(Value = 10)[][])[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<String, Object>[] @Normal(Value = 10) [][][] @SingleMember(10) [][] args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0018", expectedUnitToString);
-}
-public void test0019() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker [][] main(HashMap<String, Object>.Iterator[] @SingleMember(10) [][] args[] @Normal(Value = 10) [][])[] @Marker [][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<String, Object>.Iterator[] @Normal(Value = 10) [][][] @SingleMember(10) [][] args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0019", expectedUnitToString);
-}
-// varargs annotation
-public void test0020() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(int[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(int[] @SingleMember(10) [][] @Marker ... args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0020", expectedUnitToString);
-}
-public void test0021() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(String[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(String[] @SingleMember(10) [][] @Marker ... args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0021", expectedUnitToString);
-}
-public void test0022() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(HashMap<Integer,String>[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<Integer, String>[] @SingleMember(10) [][] @Marker ... args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0022", expectedUnitToString);
-}
-public void test0023() throws IOException {
-	String source = "public class A {\n" +
-					"@Marker public int[] @Marker[][] main(HashMap<Integer,String>.Iterator[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<Integer, String>.Iterator[] @SingleMember(10) [][] @Marker ... args) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0023", expectedUnitToString);
-}
-// local variables
-public void test0024() throws IOException {
-	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
-					"public static void main(String args[]) {\n" +
-					"    int[] f[];\n" +
-					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
-					"    float[] p[];\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    int[][] f;\n" + 
-		"    @English String[] @NonNull [][] @Nullable [][] s;\n" + 
-		"    float[][] p;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0024", expectedUnitToString);
-}
-// type parameter
-public void test0025() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> void foo() {\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"class A {\n" + 
-		"  A() {\n" + 
-		"    super();\n" + 
-		"  }\n" +
-		"  public <Integer, @Positive Integer, @Negative Integer, Integer>void foo() {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0025", expectedUnitToString);
-}
-// Type
-public void test0026() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker int foo() {\n" +
-					"    return 0;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> int bar() {\n" +
-					"    return 0;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0026", null);
-}
-// Type
-public void test0027() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker String foo() {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> String bar () {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0027", null);
-}
-//Type
-public void test0028() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object> foo() {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object> bar () {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0028", null);
-}
-// Type
-public void test0029() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator foo() {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object>.Iterator bar () {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0029", null);
-}
-//Type
-public void test0030() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator[] @NonEmpty[][] foo() {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object>.Iterator[] @NonEmpty[][] bar () {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0030", null);
-}
-//Type
-public void test0031() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker int[] @NonEmpty[][] foo() {\n" +
-					"    return 0;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> int[] @NonEmpty[][] bar() {\n" +
-					"    return 0;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0031", null);
-}
-// Type
-public void test0032() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker String[]@NonEmpty[][] foo() {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> String[]@NonEmpty[][] bar () {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0032", null);
-}
-//Type
-public void test0033() throws IOException {
-	String source = "class A {\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>[] @NonEmpty[][] foo() {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object>[]@NonEmpty[][] bar () {\n" +
-					"    return null;\n" +
-					"}\n" +
-					"}\n";
-	String expectedError = "";
-	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0033", null);
-}
-// Type0 field declaration.
-public void test0034() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker int k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker int k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0034", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0035() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker String k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker String k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0035", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0036() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker HashMap<@Positive Integer, @Negative Integer> k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker HashMap<@Positive Integer, @Negative Integer> k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0036", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0037() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0037", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0038() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker int[] @NonEmpty[][] k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker int[] @NonEmpty [][] k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0038", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0039() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker String[] @NonEmpty[][]k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker String[] @NonEmpty [][] k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0039", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0040() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker HashMap<@Positive Integer, @Negative Integer>[] @NonEmpty[][] k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker HashMap<@Positive Integer, @Negative Integer>[] @NonEmpty [][] k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0040", expectedUnitToString);
-}
-//Type0 field declaration.
-public void test0041() throws IOException {
-	String source = "public class A {\n" +
-					"    int[] f[];\n" +
-					"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty[][] k;\n" +
-					"    float[] p[];\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  int[][] f;\n" + 
-		"  @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty [][] k;\n" + 
-		"  float[][] p;\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0041", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0042() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker int foo() { return 0; }\n" +
-					"    public int bar() { return 0; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int foo() {\n" + 
-		"    return 0;\n" + 
-		"  }\n" + 
-		"  public int bar() {\n" + 
-		"    return 0;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0042", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0043() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker String foo() { return null; }\n" +
-					"    public String bar() { return null; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker String foo() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public String bar() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0043", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0044() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker HashMap<@Positive Integer, @Negative Integer> foo() { return null; }\n" +
-					"    public HashMap<@Positive Integer, @Negative Integer>  bar() { return null; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker HashMap<@Positive Integer, @Negative Integer> foo() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public HashMap<@Positive Integer, @Negative Integer> bar() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0044", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0045() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator foo() { return null; }\n" +
-					"    public HashMap<@Positive Integer, @Negative Integer>.Iterator  bar() { return null; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator foo() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public HashMap<@Positive Integer, @Negative Integer>.Iterator bar() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0045", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0046() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker int[] foo() @NonEmpty[][] { return 0; }\n" +
-					"    public int[] @NonEmpty[][] bar() { return 0; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker int[] @NonEmpty [][] foo() {\n" + 
-		"    return 0;\n" + 
-		"  }\n" + 
-		"  public int[] @NonEmpty [][] bar() {\n" + 
-		"    return 0;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0046", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0047() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker String[]  foo() @NonEmpty[][] { return null; }\n" +
-					"    public String[] @NonEmpty[][] bar() { return null; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker String[] @NonEmpty [][] foo() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public String[] @NonEmpty [][] bar() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0047", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0048() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker HashMap<@Positive Integer, @Negative Integer>[] foo() @NonEmpty[][] { return null; }\n" +
-					"    public HashMap<@Positive Integer, @Negative Integer> [] @NonEmpty[][] bar() { return null; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker HashMap<@Positive Integer, @Negative Integer> @NonEmpty [][][] foo() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public HashMap<@Positive Integer, @Negative Integer>[] @NonEmpty [][] bar() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0048", expectedUnitToString);
-}
-//Type0 MethodHeaderName.
-public void test0049() throws IOException {
-	String source = "public class A {\n" +
-					"    public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[]  foo() @NonEmpty[][] { return null; }\n" +
-					"    public HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty[][] bar() { return null; }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator @NonEmpty [][][] foo() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty [][] bar() {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0049", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0050() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker int p;\n" +
-					"        int q;\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker int p;\n" + 
-		"    int q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0050", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0051() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker String p;\n" +
-					"        String q;\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker String p;\n" + 
-		"    String q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0051", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0052() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker HashMap<@Positive Integer, @Negative Integer> p;\n" +
-					"        HashMap<@Positive Integer, @Negative Integer> q;\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker HashMap<@Positive Integer, @Negative Integer> p;\n" + 
-		"    HashMap<@Positive Integer, @Negative Integer> q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0052", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0053() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator p;\n" +
-					"        HashMap<@Positive Integer, @Negative Integer>.Iterator q;\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator p;\n" + 
-		"    HashMap<@Positive Integer, @Negative Integer>.Iterator q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0053", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0054() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker int[] @NonNull[] p @NonEmpty[][];\n" +
-					"        int[] @NonNull[] q @NonEmpty[][];\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker int[] @NonNull [] @NonEmpty [][] p;\n" + 
-		"    int[] @NonNull [] @NonEmpty [][] q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0054", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0055() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker String[] @NonNull[] p @NonEmpty[][];\n" +
-					"        String[] @NonNull[] q @NonEmpty[][];\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker String[] @NonNull [] @NonEmpty [][] p;\n" + 
-		"    String[] @NonNull [] @NonEmpty [][] q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0055", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0056() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker HashMap<@Positive Integer, @Negative Integer>[] @NonNull[] p @NonEmpty[][];\n" +
-					"        HashMap<@Positive Integer, @Negative Integer>[] @NonNull[] q @NonEmpty[][];\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker HashMap<@Positive Integer, @Negative Integer> @NonEmpty [][][] @NonNull [] p;\n" + 
-		"    HashMap<@Positive Integer, @Negative Integer> @NonEmpty [][][] @NonNull [] q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0056", expectedUnitToString);
-}
-//Type0 local variable declaration
-public void test0057() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonNull[] p @NonEmpty[][];\n" +
-					"        HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonNull[] @NonEmpty[][] q;\n" + 
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator @NonEmpty [][][] @NonNull [] p;\n" + 
-		"    HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonNull [] @NonEmpty [][] q;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0057", expectedUnitToString);
-}
-//Type0 foreach
-public void test0058() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        String @NonNull[] @Marker[] s @Readonly[];\n" +
-					"    	 for (@Readonly String @NonNull[] si @Marker[] : s) {}\n" +
-					"    	 for (String @NonNull[] sii @Marker[] : s) {}\n" +
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    String @NonNull [] @Marker [] @Readonly [] s;\n" + 
-		"    for (@Readonly String @NonNull [] @Marker [] si : s) \n" + 
-		"      {\n" + 
-		"      }\n" + 
-		"    for (String @NonNull [] @Marker [] sii : s) \n" + 
-		"      {\n" + 
-		"      }\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0058", expectedUnitToString);
-}
-//Type0 foreach
-public void test0059() throws IOException {
-	String source = "public class A {\n" +
-					"    public void foo() {\n" +
-					"        int @NonNull[] @Marker[] s @Readonly[];\n" +
-					"    	 for (@Readonly int @NonNull[] si @Marker[] : s) {}\n" +
-					"    	 for (int @NonNull[] sii @Marker[] : s) {}\n" +
-					"    }\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class A {\n" + 
-		"  public A() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo() {\n" + 
-		"    int @NonNull [] @Marker [] @Readonly [] s;\n" + 
-		"    for (@Readonly int @NonNull [] @Marker [] si : s) \n" + 
-		"      {\n" + 
-		"      }\n" + 
-		"    for (int @NonNull [] @Marker [] sii : s) \n" + 
-		"      {\n" + 
-		"      }\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0059", expectedUnitToString);
-}
-// cast expression
-public void test0060() throws IOException {
-	String source = "public class Clazz {\n" +
-					"public static void main(String[] args) {\n" +
-					"int x;\n" +
-					"x = (Integer)\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Normal(Value=0)[][] )\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @SingleMember(0)[][] )\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Marker[][] )\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Normal(Value=0)[][] )\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>[] @SingleMember(0)[][] )\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Marker[][] )\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly String[] @Normal(Value=0)[][] )\n" +
-					"(@Readonly String[] @SingleMember(0)[][] )\n" +
-					"(@Readonly String[] @Marker[][] )\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly int[] @Normal(Value=0)[][] )\n" +
-					"(@Readonly int[] @SingleMember(0)[][] )\n" +
-					"(@Readonly int[] @Marker[][] )\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator)\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly HashMap<@Positive Integer, @Negative Integer>)\n" +
-					"(@Readonly Object)\n" +
-					"(@ReadOnly String)\n" +
-					"(@Readonly Object)\n" +
-					"(@Readonly int) 10;\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class Clazz {\n" + 
-		"  public Clazz() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    int x;\n" + 
-		"    x = (Integer) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Normal(Value = 0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @SingleMember(0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Marker [][]) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Normal(Value = 0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>[] @SingleMember(0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Marker [][]) (@Readonly Object) (@Readonly String[] @Normal(Value = 0) [][]) (@Readonly String[] @SingleMember(0) [][]) (@Readonly String[] @Marker [][]) (@Readonly Object) (@Readonly int[] @Normal(Value = 0) [][]) (@Readonly int[] @SingleMember(0) [][]) (@Readonly int[] @Marker [][]) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>) (@Readonly Object) (@ReadOnly String) (@Readonly Object) (@Readonly int) 10;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0060", expectedUnitToString);
-}
-//cast expression
-public void test0061() throws IOException {
-	String source = "public class Clazz {\n" +
-					"public static void main(String[] args) {\n" +
-					"int x;\n" +
-					"x = (Integer)\n" +
-					"(Object)\n" +
-					"(@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Normal(Value=0)[][] )\n" +
-					"(HashMap<@Positive Integer, Integer>.Iterator[] @SingleMember(0)[][] )\n" +
-					"(@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Marker[][] )\n" +
-					"(Object)\n" +
-					"(@Readonly HashMap<@Positive Integer, Integer>[] @Normal(Value=0)[][] )\n" +
-					"(HashMap<Integer, @Negative Integer>[] @SingleMember(0)[][] )\n" +
-					"(@Readonly HashMap<@Positive Integer, Integer>[] @Marker[][] )\n" +
-					"(Object)\n" +
-					"(@Readonly String[] @Normal(Value=0)[][] )\n" +
-					"(String[] @SingleMember(0)[][] )\n" +
-					"(@Readonly String[] @Marker[][] )\n" +
-					"(Object)\n" +
-					"(@Readonly int[] @Normal(Value=0)[][] )\n" +
-					"(int[] @SingleMember(0)[][] )\n" +
-					"(@Readonly int[] @Marker[][] )\n" +
-					"(Object)\n" +
-					"(@Readonly HashMap<Integer, @Negative Integer>.Iterator)\n" +
-					"(Object)\n" +
-					"(@Readonly HashMap<@Positive Integer, Integer>)\n" +
-					"(Object)\n" +
-					"(@ReadOnly String)\n" +
-					"(Object)\n" +
-					"(@Readonly int) 10;\n" +
-					"}\n" +
-					"}\n";
-	String expectedUnitToString = 
-		"public class Clazz {\n" + 
-		"  public Clazz() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    int x;\n" + 
-		"    x = (Integer) (Object) (@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Normal(Value = 0) [][]) (HashMap<@Positive Integer, Integer>.Iterator[] @SingleMember(0) [][]) (@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Marker [][]) (Object) (@Readonly HashMap<@Positive Integer, Integer>[] @Normal(Value = 0) [][]) (HashMap<Integer, @Negative Integer>[] @SingleMember(0) [][]) (@Readonly HashMap<@Positive Integer, Integer>[] @Marker [][]) (Object) (@Readonly String[] @Normal(Value = 0) [][]) (String[] @SingleMember(0) [][]) (@Readonly String[] @Marker [][]) (Object) (@Readonly int[] @Normal(Value = 0) [][]) (int[] @SingleMember(0) [][]) (@Readonly int[] @Marker [][]) (Object) (@Readonly HashMap<Integer, @Negative Integer>.Iterator) (Object) (@Readonly HashMap<@Positive Integer, Integer>) (Object) (@ReadOnly String) (Object) (@Readonly int) 10;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0061", expectedUnitToString);
-}
-// instanceof checks 
-public void test0062() throws IOException {
-	String source = "public class Clazz {\n" +
-					"public static void main(Object o) {\n" +
-					"if (o instanceof @Readonly String) {\n" +
-					"} else if (o instanceof @Readonly int[] @NonEmpty[][] ) {\n" +
-					"} else if (o instanceof @Readonly String[] @NonEmpty[][] ) {\n" +
-					"} else if (o instanceof @Readonly HashMap<?,?>[] @NonEmpty[][] ) {\n" +
-					"} else if (o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty[][] ) {\n" +	
-					"} else if (o instanceof @Readonly HashMap<?,?>) {\n" +
-					"} else if (o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator) {\n" +
-					"}\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class Clazz {\n" + 
-		"  public Clazz() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(Object o) {\n" + 
-		"    if ((o instanceof @Readonly String))\n" + 
-		"        {\n" + 
-		"        }\n" + 
-		"    else\n" + 
-		"        if ((o instanceof @Readonly int[] @NonEmpty [][]))\n" + 
-		"            {\n" + 
-		"            }\n" + 
-		"        else\n" + 
-		"            if ((o instanceof @Readonly String[] @NonEmpty [][]))\n" + 
-		"                {\n" + 
-		"                }\n" + 
-		"            else\n" + 
-		"                if ((o instanceof @Readonly HashMap<?, ?>[] @NonEmpty [][]))\n" + 
-		"                    {\n" + 
-		"                    }\n" + 
-		"                else\n" + 
-		"                    if ((o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty [][]))\n" + 
-		"                        {\n" + 
-		"                        }\n" + 
-		"                    else\n" + 
-		"                        if ((o instanceof @Readonly HashMap<?, ?>))\n" + 
-		"                            {\n" + 
-		"                            }\n" + 
-		"                        else\n" + 
-		"                            if ((o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator))\n" + 
-		"                                {\n" + 
-		"                                }\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0062", expectedUnitToString);
-}
-// assorted unclassified 
-public void test0063() throws IOException {
-	String source = "import java.util.HashMap;\n" +
-					"import java.util.Map; \n" +  
-					"\n" +
-					"public class Clazz <@A M extends @B String, @C N extends @D Comparable> extends\n" +
-					"								@E Object implements @F Comparable <@G Object> {\n" +
-					"	\n" +
-					"  Clazz(char[] ...args) { \n" +   
-					"   }\n" +
-					"   \n" +
-					"  int @I[] f @J[], g, h[], i@K[];\n" +
-					"  int @L[][]@M[] f2; \n" +
-					"   \n" +
-					"  Clazz (int @N[] @O... a) {}\n" +
-					" int @R[]@S[] aa() {}\n" +
-					" \n" +
-					" int @T[]@U[]@V[] a () @W[]@X[]@Y[] { return null; }\n" +
-					"   \n" +
-					"  public void main(String @A[] @B ... args) throws @D Exception {\n" +
-					"  	\n" +
-					"       HashMap<@E String, @F String> b1;\n" +
-					"      \n" +
-					"     int b; b = (@G int) 10;\n" +
-					"      \n" +
-					"     char @H[]@I[] ch; ch = (@K char @L[]@M[])(@N char @O[]@P[]) null;\n" +
-					"      \n" +
-					"      int[] i; i = new @Q int @R[10];\n" +
-					"       \n" +
-					"      \n" +
-					"   Integer w; w = new X<@S String, @T Integer>().get(new @U Integer(12));\n" +
-					"    throw new @V Exception(\"test\");\n" +
-					"    boolean c; c  = null instanceof @W String;\n" +
-					"	} \n" +
-					" public <@X X, @Y Y> void foo(X x, Y @Z... y) {  \n" +
-					"	\n" +
-					"}\n" +
-					" \n" +
-					" void foo(Map<? super @A Object, ? extends @B String> m){}\n" +
-					" public int compareTo(Object arg0) {\n" +
-					"     return 0;\n" +
-					" }\n" +
-					"\n" +
-					"}\n" +
-					"class X<@C K, @D T extends @E Object & @F Comparable<? super @G T>> {\n" +
-					"	\n" +
-					"  public Integer get(Integer integer) {\n" +
-					"       return null;\n" +
-					"   }\n" +
-					"}\n";
-					
-					
-	String expectedUnitToString = "import java.util.HashMap;\n" + 
-								  "import java.util.Map;\n" + 
-								  "public class Clazz<@A M extends @B String, @C N extends @D Comparable> extends @E Object implements @F Comparable<@G Object> {\n" + 
-								  "  int @I [] @J [] f;\n" + 
-								  "  int @I [] g;\n" + 
-								  "  int @I [][] h;\n" + 
-								  "  int @I [] @K [] i;\n" + 
-								  "  int @L [][] @M [] f2;\n" + 
-								  "  Clazz(char[]... args) {\n" + 
-								  "    super();\n" + 
-								  "  }\n" + 
-								  "  Clazz(int @N [] @O ... a) {\n" + 
-								  "    super();\n" + 
-								  "  }\n" + 
-								  "  int @R [] @S [] aa() {\n" + 
-								  "  }\n" + 
-								  "  int @T [] @U [] @V [] @W [] @X [] @Y [] a() {\n" + 
-								  "    return null;\n" + 
-								  "  }\n" + 
-								  "  public void main(String @A [] @B ... args) throws @D Exception {\n" + 
-								  "    HashMap<@E String, @F String> b1;\n" + 
-								  "    int b;\n" +
-								  "    b = (@G int) 10;\n" + 
-								  "    char @H [] @I [] ch;\n" +
-								  "    ch = (@K char @L [] @M []) (@N char @O [] @P []) null;\n" + 
-								  "    int[] i;\n" +
-								  "    i = new @Q int @R [10];\n" + 
-								  "    Integer w;\n" +
-								  "    w = new X<@S String, @T Integer>().get(new @U Integer(12));\n" + 
-								  "    throw new @V Exception(\"test\");\n" + 
-								  "    boolean c;\n" +
-								  "    c = (null instanceof @W String);\n" + 
-								  "  }\n" + 
-								  "  public <@X X, @Y Y>void foo(X x, Y @Z ... y) {\n" + 
-								  "  }\n" + 
-								  "  void foo(Map<? super @A Object, ? extends @B String> m) {\n" + 
-								  "  }\n" + 
-								  "  public int compareTo(Object arg0) {\n" + 
-								  "    return 0;\n" + 
-								  "  }\n" + 
-								  "}\n" + 
-								  "class X<@C K, @D T extends @E Object & @F Comparable<? super @G T>> {\n" + 
-								  "  X() {\n" + 
-								  "    super();\n" + 
-								  "  }\n" + 
-								  "  public Integer get(Integer integer) {\n" + 
-								  "    return null;\n" + 
-								  "  }\n" + 
-								  "}\n";
-	// indexing parser avoids creating lots of nodes, so parse tree comes out incorrectly.
-	// this is not bug, but intended behavior - see IndexingParser.newSingleNameReference(char[], long)
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0063", expectedUnitToString);
-}
-//assorted unclassified 
-public void test0064() throws IOException {
-	String source = "class X<T extends @E Object & @F Comparable<? super T>> {}\n";
-	String expectedUnitToString = "class X<T extends @E Object & @F Comparable<? super T>> {\n" + 
-								  "  X() {\n" + 
-								  "    super();\n" + 
-								  "  }\n" + 
-								  "}\n";
-	// indexing parser avoids creating lots of nodes, so parse tree comes out incorrectly.
-	// this is not bug, but intended behavior - see IndexingParser.newSingleNameReference(char[], long)
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test064", expectedUnitToString);
-}
-//type class literal expression
-public void test0066() throws IOException {
-	String source = "public class X {\n" + 
-			"	<T extends Y<@A String @C[][]@B[]> & Cloneable> void foo(T t) {}\n" + 
-			"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  <T extends Y<@A String @C [][] @B []> & Cloneable>void foo(T t) {\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0066", expectedUnitToString);
-}
-//check locations
-public void test0067() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @H String @E [] @F [] @G [] field;\n" + 
-		"  @A Map<@B String, @C List<@D Object>> field2;\n" + 
-		"  @A Map<@B String, @H String @E [] @F [] @G []> field3;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0067", expectedUnitToString);
-}
-//check locations
-public void test0068() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @H String @E [] @F [] @G [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0068", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 4, locations.size());
-	assertEquals("Wrong location", null, locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-}
-//check locations
-public void test0069() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B String, @H String> field3;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B String, @H String> field3;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0069", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 3, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@H"));
-}
-//check locations
-public void test0070() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B String, @H String @E [] @F [] @G []> field3;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0070", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 6, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@E"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-}
-//check locations
-public void test0071() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B String, @C List<@H String @E[][] @G[]>> field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B String, @C List<@H String @E [][] @G []>> field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0071", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 6, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@C"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
-}
-//check locations
-public void test0072() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B String, @C List<@H String @E[][] @G[]>>[] @I[] @J[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B String, @C List<@H String @E [][] @G []>>[] @I [] @J [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0072", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 8, locations.size());
-	assertEquals("Wrong location", "[ARRAY]", locations.get("@I"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@C"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
-}
-//check locations
-public void test0073() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B String, @C List<@H String @E[][] @G[]>> @I[][] @J[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B String, @C List<@H String @E [][] @G []>> @I [][] @J [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0073", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 8, locations.size());
-	assertEquals("Wrong location", null, locations.get("@I"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@C"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
-}
-//check locations
-public void test0074() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@C List<@H String @E[][] @G[]>, String @B[] @D[]> @I[] @F[] @J[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@C List<@H String @E [][] @G []>, String @B [] @D []> @I [] @F [] @J [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0074", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 10, locations.size());
-	assertEquals("Wrong location", null, locations.get("@I"));
-	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@C"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), ARRAY]", locations.get("@D"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@B"));
-}
-//check locations
-public void test0075() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@C List<@H String @E[][] @G[]>, @B List<String [] @D[]>> [] @I[] @F[] @J[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@C List<@H String @E [][] @G []>, @B List<String[] @D []>>[] @I [] @F [] @J [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0075", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 10, locations.size());
-	assertEquals("Wrong location", "[ARRAY]", locations.get("@I"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@J"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY]", locations.get("@A"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@C"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@B"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY]", locations.get("@D"));
-}
-//check locations
-public void test0076() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B String, @C List<@D Object>> field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B String, @C List<@D Object>> field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0076", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 4, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@C"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@D"));
-}
-//check locations
-public void test0077() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @H String @E [] @F [] @G [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0077", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 4, locations.size());
-	assertEquals("Wrong location", null, locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-}
-//check locations
-public void test0078() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B Comparable<@C Object @D[] @E[] @F[]>, @G List<@H Document>> field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B Comparable<@C Object @D [] @E [] @F []>, @G List<@H Document>> field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0078", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 8, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@C"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@D"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY]", locations.get("@E"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@G"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@H"));
-}
-//check locations
-public void test0079() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A java.util.Map<@B Comparable<@C Object @D[] @E[] @F[]>, @G List<@H Document>> field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A java.util.Map<@B Comparable<@C Object @D [] @E [] @F []>, @G List<@H Document>> field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0079", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 8, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@C"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@D"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY]", locations.get("@E"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@G"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@H"));
-}
-//check locations
-public void test0080() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@B Map<? extends Z, ? extends @A Z> field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @B Map<? extends Z, ? extends @A Z> field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0080", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 2, locations.size());
-	assertEquals("Wrong location", null, locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), WILDCARD]", locations.get("@A"));
-}
-//check locations
-public void test0081() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @H java.lang.String @E [] @F [] @G [] field;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0081", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 4, locations.size());
-	assertEquals("Wrong location", null, locations.get("@E"));
-	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-}
-//check locations
-public void test0082() throws IOException {
-	String source = 
-		"public class X {\n" + 
-		"	@A Map<@B java.lang.String, @H java.lang.String @E[] @F[] @G[]> field3;\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  @A Map<@B java.lang.String, @H java.lang.String @E [] @F [] @G []> field3;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0082", expectedUnitToString, visitor);
-	Map locations = visitor.getLocations();
-	assertEquals("Wrong size", 6, locations.size());
-	assertEquals("Wrong location", null, locations.get("@A"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@E"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY]", locations.get("@F"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY]", locations.get("@G"));
-	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
-}
-public void test0083() throws IOException {
-	String source =
-		"@Marker class A {}\n;" +
-		"@Marker class B extends @Marker A {}\n" +
-		"@Marker class C extends @Marker @SingleMember(0) A {}\n" +
-		"@Marker class D extends @Marker @SingleMember(0) @Normal(value = 0) A {}\n" +
-		"@Marker class E extends B {}\n;";
-
-	String expectedUnitToString =
-		"@Marker class A {\n" +
-		"  A() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class B extends @Marker A {\n" +
-		"  B() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class C extends @Marker @SingleMember(0) A {\n" +
-		"  C() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class D extends @Marker @SingleMember(0) @Normal(value = 0) A {\n" +
-		"  D() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class E extends B {\n" +
-		"  E() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0083", expectedUnitToString);
-}
-
-// To test Parser.consumeAdditionalBound() with Type annotations
-public void test0084() throws IOException {
-	String source =
-		"@Marker interface I<@Negative T> {}\n" +
-		"@SingleMember(0) interface J<@Positive T> {}\n" +
-		"@Marker class A implements I<@SingleMember(0) A>, J<@Marker A> {}\n" +
-		"@Normal(value = 1) class X<E extends @Positive A & @Marker I<A> & @Marker @SingleMember(1) J<@Readonly A>>  {\n" +
-		"}";
-	String expectedUnitToString =
-		"@Marker interface I<@Negative T> {\n" +
-		"}\n" +
-		"@SingleMember(0) interface J<@Positive T> {\n" +
-		"}\n" +
-		"@Marker class A implements I<@SingleMember(0) A>, J<@Marker A> {\n" +
-		"  A() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Normal(value = 1) class X<E extends @Positive A & @Marker I<A> & @Marker @SingleMember(1) J<@Readonly A>> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0084", expectedUnitToString );
-}
-
-// To test Parser.consumeAdditionalBound() with Type annotations
-public void test0085() throws IOException {
-	String source =
-		"import java.io.Serializable;\n" +
-		"\n" +
-		"@SingleMember(10) class X<T extends @Marker Serializable & @Normal(value = 10) Runnable, V extends @Marker T> {\n" +
-		"	@Negative T t;\n" +
-		"	@Marker X(@Readonly T t) {\n" +
-		"		this.t = t;\n" +
-		"	}\n" +
-		"	void foo(@Marker X this) {\n" +
-		"		(this == null ? t : t).run();\n" +
-		"		((@Marker V) t).run();\n" +
-		"	}\n" +
-		"	public static void main(@Readonly String @Marker [] args) {\n" +
-		"		new @Marker  X<@Marker A, @Negative A>(new @Marker A()).foo();\n" +
-		"	}\n" +
-		"}\n" +
-		"@Marker class A implements @Marker Serializable, @SingleMember(1) Runnable {\n" +
-		"	public void run() {\n" +
-		"		System.out.print(\"AA\");\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"import java.io.Serializable;\n" +
-		"@SingleMember(10) class X<T extends @Marker Serializable & @Normal(value = 10) Runnable, V extends @Marker T> {\n" +
-		"  @Negative T t;\n" +
-		"  @Marker X(@Readonly T t) {\n" +
-		"    super();\n" +
-		"    this.t = t;\n" +
-		"  }\n" +
-		"  void foo(@Marker X this) {\n" +
-		"    ((this == null) ? t : t).run();\n" +
-		"    ((@Marker V) t).run();\n" +
-		"  }\n" +
-		"  public static void main(@Readonly String @Marker [] args) {\n" +
-		"    new @Marker X<@Marker A, @Negative A>(new @Marker A()).foo();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class A implements @Marker Serializable, @SingleMember(1) Runnable {\n" +
-		"  A() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void run() {\n" +
-		"    System.out.print(\"AA\");\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0085", expectedUnitToString );
-}
-
-// To test Parser.classInstanceCreation() with type annotations
-public void test0086() throws IOException {
-	String source =
-		"class X {\n" +
-		"	@Marker X() {\n" +
-		"		System.out.print(\"new X created\");\n" +
-		"	}\n" +
-		"  	void f() throws @Marker InstantiationException {\n" +
-		"       X testX;\n" +
-		"		testX = new @Readonly @Negative X();\n" +
-		"		Double d;\n" +
-		"		d = new @Marker @Positive Double(1.1);\n" +
-		"     	throw new @Positive @Normal(value = 10) InstantiationException(\"test\");\n" +
-		"   }\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  @Marker X() {\n" +
-		"    super();\n" +
-		"    System.out.print(\"new X created\");\n" +
-		"  }\n" +
-		"  void f() throws @Marker InstantiationException {\n" +
-		"    X testX;\n" +
-		"    testX = new @Readonly @Negative X();\n" +
-		"    Double d;\n" +
-		"    d = new @Marker @Positive Double(1.1);\n" +
-		"    throw new @Positive @Normal(value = 10) InstantiationException(\"test\");\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0086", expectedUnitToString );
-}
-
-// To test Parser.classInstanceCreation() with type annotations
-public void test0087() throws IOException {
-	String source =
-		"class X {\n" +
-		"	@Marker X() {\n" +
-		"		System.out.print(\"new X created\");\n" +
-		"	}\n" +
-		"	@Marker class Inner {\n" +
-		"		@Normal(value = 10) Inner(){\n" +
-		"			System.out.print(\"X.Inner created\");\n" +
-		"		}\n" +
-		"	}\n" +
-		"	public String getString(){\n" +
-		"		return \"hello\";\n" +
-		"	}\n" +
-		"  	void f(@Marker X this) {\n" +
-		"       String testString;\n" +
-		"		testString = new @Readonly @Negative X().getString();\n" +
-		"		X.Inner testInner;\n" +
-		"		testInner = new @Readonly X.Inner();\n" +
-		"		int i;\n" +
-		"		for(i = 0; i < 10; i++)\n" +
-		"			System.out.print(\"test\");\n" +
-		"   }\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  @Marker class Inner {\n" +
-		"    @Normal(value = 10) Inner() {\n" +
-		"      super();\n" +
-		"      System.out.print(\"X.Inner created\");\n" +
-		"    }\n" +
-		"  }\n" +
-		"  @Marker X() {\n" +
-		"    super();\n" +
-		"    System.out.print(\"new X created\");\n" +
-		"  }\n" +
-		"  public String getString() {\n" +
-		"    return \"hello\";\n" +
-		"  }\n" +
-		"  void f(@Marker X this) {\n" +
-		"    String testString;\n" +
-		"    testString = new @Readonly @Negative X().getString();\n" +
-		"    X.Inner testInner;\n" +
-		"    testInner = new @Readonly X.Inner();\n" +
-		"    int i;\n" +
-		"    for (i = 0; (i < 10); i ++) \n" +
-		"      System.out.print(\"test\");\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0087", expectedUnitToString );
-}
-
-// To test Parser.classInstanceCreation() with type annotations
-public void test0088() throws IOException {
-	String source =
-		"import java.io.Serializable;\n" +
-		"class X {\n" +
-		"	public static void main(String[] args) {\n" +
-		"		new @Marker Serializable() {\n" +
-		"		};\n" +
-		"		new @Positive @Marker Serializable() {\n" +
-		"			public long serialVersion;\n" +
-		"		};\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.io.Serializable;\n" +
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    new @Marker Serializable() {\n" +
-		"    };\n" +
-		"    new @Positive @Marker Serializable() {\n" +
-		"      public long serialVersion;\n" +
-		"    };\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0088", expectedUnitToString );
-}
-
-// To test Parser.classInstanceCreation() with type annotations
-public void test0089() throws IOException {
-	String source =
-		"import java.io.Serializable;\n" +
-		"class X<T>{\n" +
-		"	public void f() {\n" +
-		"		X testX;\n" +
-		"		testX = new @Marker @SingleMember(10) X<@Negative Integer>();\n" +
-		"		System.out.print(\"object created\");\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.io.Serializable;\n" +
-		"class X<T> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void f() {\n" +
-		"    X testX;\n" +
-		"    testX = new @Marker @SingleMember(10) X<@Negative Integer>();\n" +
-		"    System.out.print(\"object created\");\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0089", expectedUnitToString );
-}
-
-// To test Parser.classInstanceCreation() with type annotations
-public void test0090() throws IOException {
-	String source =
-		"class X <@Marker T extends @Readonly String> {\n" +
-		"    T foo(T t) {\n" +
-		"        return t;\n" +
-		"    }\n" +
-		"    public static void main(String[] args) {\n" +
-		"        new @Readonly X<String>().baz(\"SUCCESS\");\n" +	// Parser.classInstanceCreation called
-		"    }\n" +
-		"    void baz(final T t) {\n" +
-		"        new @Readonly @Marker Object() {\n" +	// Parser.classInstanceCreation called
-		"            void print() {\n" +
-		"            }\n" +
-		"        }.print();\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<@Marker T extends @Readonly String> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  T foo(T t) {\n" +
-		"    return t;\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    new @Readonly X<String>().baz(\"SUCCESS\");\n" +
-		"  }\n" +
-		"  void baz(final T t) {\n" +
-		"    new @Readonly @Marker Object() {\n" +
-		"  void print() {\n" +
-		"  }\n" +
-		"}.print();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0090", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
-public void test0091() throws IOException {
-	String source =
-		"class X <@Marker T extends @Readonly String> {\n" +
-		"    public static void main(String[] args) {\n" +
-		"		int [] x1;\n" +
-		"		x1 = new int @Marker @SingleMember(2) [] {-1, -2};\n" +
-		"       Integer [][] x2;\n" +
-		"		x2 = new @Positive Integer @Marker @SingleMember(3) [] @SingleMember(3) [] {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<@Marker T extends @Readonly String> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    int[] x1;\n" +
-		"    x1 = new int @Marker @SingleMember(2) []{(- 1), (- 2)};\n" +
-		"    Integer[][] x2;\n" +
-		"    x2 = new @Positive Integer @Marker @SingleMember(3) [] @SingleMember(3) []{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0091", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
-public void test0092() throws IOException {
-	String source =
-		"class X {\n" +
-		"	static class T {\n" +
-		"		public @Readonly Object @Normal(value = 10) [] f() {\n" +
-		"			return new @Readonly Object @Normal(value = 10) [] {this, T.this};\n" +
-		"		}\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  static class T {\n" +
-		"    T() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"    public @Readonly Object @Normal(value = 10) [] f() {\n" +
-		"      return new @Readonly Object @Normal(value = 10) []{this, T.this};\n" +
-		"    }\n" +
-		"  }\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0092", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
-public void test0093() throws IOException {
-	String source =
-		"class X {\n" +
-		"    public static void main(String[] args) {\n" +
-		"        java.util.Arrays.asList(new @Readonly Object @SingleMember(1) [] {\"1\"});\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    java.util.Arrays.asList(new @Readonly Object @SingleMember(1) []{\"1\"});\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0093", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
-public void test0094() throws IOException {
-	String source =
-		"class X {\n" +
-		"	public boolean test() {\n" +
-		"		String[] s;\n" +
-		"		s = foo(new @Marker String @SingleMember(1) []{\"hello\"});\n" +
-		"		return s != null;\n" +
-		"	}\n" +
-		"	public <@Marker F> F @SingleMember(1) [] foo(F[] f) {\n" +
-		"		return f;\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public boolean test() {\n" +
-		"    String[] s;\n" +
-		"    s = foo(new @Marker String @SingleMember(1) []{\"hello\"});\n" +
-		"    return (s != null);\n" +
-		"  }\n" +
-		"  public <@Marker F>F @SingleMember(1) [] foo(F[] f) {\n" +
-		"    return f;\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0094", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
-public void test0095() throws IOException {
-	String source =
-		"import java.util.Arrays;\n" +
-		"import java.util.List;\n" +
-		"@Marker class Deejay {\n" +
-		"	@Marker class Counter<@Marker T> {}\n" +
-		"	public void f(String[] args) {\n" +
-		"		Counter<@Positive Integer> songCounter;\n" +
-		"		songCounter = new Counter<@Positive Integer>();\n" +
-		"		Counter<@Readonly String> genre;\n" +
-		"		genre = new Counter<@Readonly String>();\n" +
-		"		List<@Marker Counter<?>> list1;\n" +
-		"		list1 = Arrays.asList(new @Marker Counter<?> @Normal(value = 2) @Marker [] {songCounter, genre});\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"import java.util.Arrays;\n" +
-		"import java.util.List;\n" +
-		"@Marker class Deejay {\n" +
-		"  @Marker class Counter<@Marker T> {\n" +
-		"    Counter() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"  }\n" +
-		"  Deejay() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void f(String[] args) {\n" +
-		"    Counter<@Positive Integer> songCounter;\n" +
-		"    songCounter = new Counter<@Positive Integer>();\n" +
-		"    Counter<@Readonly String> genre;\n" +
-		"    genre = new Counter<@Readonly String>();\n" +
-		"    List<@Marker Counter<?>> list1;\n" +
-		"    list1 = Arrays.asList(new @Marker Counter<?> @Normal(value = 2) @Marker []{songCounter, genre});\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0095", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
-public void test0096() throws IOException {
-	String source =
-		"class X <@Marker T extends @Readonly String> {\n" +
-		"    public static void main(String[] args) {\n" +
-		"		int [] x1;\n" +
-		"		x1 = new int @Marker @SingleMember(10) [10];\n" +
-		"       Integer [][] x2;\n" +
-		"		x2 = new @Positive Integer @Marker [10] @Normal(value = 10) [10];\n" +
-		"		char[][] tokens;\n" +
-		"		tokens = new char @SingleMember(0) [0] @Normal(value = 10) @Marker [];\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<@Marker T extends @Readonly String> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    int[] x1;\n" +
-		"    x1 = new int @Marker @SingleMember(10) [10];\n" +
-		"    Integer[][] x2;\n" +
-		"    x2 = new @Positive Integer @Marker [10] @Normal(value = 10) [10];\n" +
-		"    char[][] tokens;\n" +
-		"    tokens = new char @SingleMember(0) [0] @Normal(value = 10) @Marker [];\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0096", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
-public void test0097() throws IOException {
-	String source =
-		"class X {\n" +
-		"	public @Readonly Object @Normal(value = 10) [] f(@Marker X this) {\n" +
-		"		return new @Readonly Object @Normal(value = 10) [10];\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public @Readonly Object @Normal(value = 10) [] f(@Marker X this) {\n" +
-		"    return new @Readonly Object @Normal(value = 10) [10];\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0097", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
-public void test0098() throws IOException {
-	String source =
-		"class X {\n" +
-		"	public boolean test() {\n" +
-		"		String[] s;\n" +
-		"		s = foo(new @Marker String @SingleMember(1) [10]);\n" +
-		"		return s != null;\n" +
-		"	}\n" +
-		"	public <@Marker F> F @SingleMember(1) [] foo(F[] f) {\n" +
-		"		return f;\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public boolean test() {\n" +
-		"    String[] s;\n" +
-		"    s = foo(new @Marker String @SingleMember(1) [10]);\n" +
-		"    return (s != null);\n" +
-		"  }\n" +
-		"  public <@Marker F>F @SingleMember(1) [] foo(F[] f) {\n" +
-		"    return f;\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0098", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
-public void test0099() throws IOException {
-	String source =
-		"import java.util.Arrays;\n" +
-		"import java.util.List;\n" +
-		"class X<@Marker T> {\n" +
-		"	public void test() {\n" +
-		"		List<@Marker X<?>> a;\n" +
-		"		a = Arrays.asList(new @Marker X<?> @SingleMember(0) [0]);\n" +
-		"		String @Marker [] @SingleMember(1) [] x;\n" +
-		"		x = new @Readonly String @Normal(value = 5) [5] @SingleMember(1) [1];\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.util.Arrays;\n" +
-		"import java.util.List;\n" +
-		"class X<@Marker T> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void test() {\n" +
-		"    List<@Marker X<?>> a;\n" +
-		"    a = Arrays.asList(new @Marker X<?> @SingleMember(0) [0]);\n" +
-		"    String @Marker [] @SingleMember(1) [] x;\n" +
-		"    x = new @Readonly String @Normal(value = 5) [5] @SingleMember(1) [1];\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0099", expectedUnitToString );
-}
-
-// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
-public void test0100() throws IOException {
-	String source =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"    public Integer[] getTypes() {\n" +
-		"        List<@Positive Integer> list;\n" +
-		"		 list = new ArrayList<@Positive Integer>();\n" +
-		"        return list == null \n" +
-		"            ? new @Positive Integer @SingleMember(0) [0] \n" +
-		"            : list.toArray(new @Positive Integer @Marker [list.size()]);\n" +
-		"    }\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public Integer[] getTypes() {\n" +
-		"    List<@Positive Integer> list;\n" +
-		"    list = new ArrayList<@Positive Integer>();\n" +
-		"    return ((list == null) ? new @Positive Integer @SingleMember(0) [0] : list.toArray(new @Positive Integer @Marker [list.size()]));\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0100", expectedUnitToString );
-}
-
-// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
-public void test0101() throws IOException {
-	String source =
-		"import java.util.*;\n" +
-		"\n" +
-		"@Marker class X {\n" +
-		"    Vector<Object> data;\n" +
-		"    public void t() {\n" +
-		"        Vector<@Readonly Object> v;\n" +
-		" 		 v = (@Marker @SingleMember(0) Vector<@Readonly Object>) data.elementAt(0);\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"import java.util.*;\n" +
-		"@Marker class X {\n" +
-		"  Vector<Object> data;\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void t() {\n" +
-		"    Vector<@Readonly Object> v;\n" +
-		"    v = (@Marker @SingleMember(0) Vector<@Readonly Object>) data.elementAt(0);\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0101", expectedUnitToString );
-}
-
-// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
-// To test Parser.consumeClassHeaderExtends() with Type Annotations
-public void test0102() throws IOException {
-	String source =
-		"class X<E> {\n" +
-		"    X<@Readonly String> bar() {\n" +
-		"    	return (@Marker AX<@Readonly String>) new X<@Readonly String>();\n" +
-		"    }\n" +
-		"    X<@Readonly String> bar(Object o) {\n" +
-		"    	return (@Marker AX<@Readonly String>) o;\n" +
-		"    }\n" +
-		"    X<@Negative E> foo(Object o) {\n" +
-		"    	return (@Marker @Normal(value = 10) AX<@Negative E>) o;\n" +
-		"    }    \n" +
-		"    X<E> baz(Object o) {\n" +
-		"    	return (@Marker AX<E>) null;\n" +
-		"    }\n" +
-		"    X<String> baz2(BX bx) {\n" +
-		"    	return (@Marker @SingleMember(10) X<String>) bx;\n" +
-		"    }\n" +
-		"}\n" +
-		"@Normal(value = 1) class AX<@Marker F> extends @Marker X<@SingleMember(10)F> {}\n" +
-		"@Normal(value = 2) class BX extends @Marker @SingleMember(1) AX<@Readonly String> {}\n";
-	String expectedUnitToString =
-		"class X<E> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  X<@Readonly String> bar() {\n" +
-		"    return (@Marker AX<@Readonly String>) new X<@Readonly String>();\n" +
-		"  }\n" +
-		"  X<@Readonly String> bar(Object o) {\n" +
-		"    return (@Marker AX<@Readonly String>) o;\n" +
-		"  }\n" +
-		"  X<@Negative E> foo(Object o) {\n" +
-		"    return (@Marker @Normal(value = 10) AX<@Negative E>) o;\n" +
-		"  }\n" +
-		"  X<E> baz(Object o) {\n" +
-		"    return (@Marker AX<E>) null;\n" +
-		"  }\n" +
-		"  X<String> baz2(BX bx) {\n" +
-		"    return (@Marker @SingleMember(10) X<String>) bx;\n" +
-		"  }\n" +
-		"}\n" +
-		"@Normal(value = 1) class AX<@Marker F> extends @Marker X<@SingleMember(10) F> {\n" +
-		"  AX() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Normal(value = 2) class BX extends @Marker @SingleMember(1) AX<@Readonly String> {\n" +
-		"  BX() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0102", expectedUnitToString );
-}
-
-// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
-public void test0103() throws IOException {
-	String source =
-		"import java.lang.reflect.Array;\n" +
-		"@Marker class X<@Readonly T> {\n" +
-		"	T @SingleMember(0) [] theArray;\n" +
-		"	public X(Class<T> clazz) {\n" +
-		"		theArray = (@Marker @SingleMember(0) T @Normal(value = 10) []) Array.newInstance(clazz, 10); // Compiler warning\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.lang.reflect.Array;\n" +
-		"@Marker class X<@Readonly T> {\n" +
-		"  T @SingleMember(0) [] theArray;\n" +
-		"  public X(Class<T> clazz) {\n" +
-		"    super();\n" +
-		"    theArray = (@Marker @SingleMember(0) T @Normal(value = 10) []) Array.newInstance(clazz, 10);\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0103", expectedUnitToString );
-}
-
-// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
-public void test0104() throws IOException {
-	String source =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"    void method(Object o) {\n" +
-		"		 if (o instanceof String[]){\n" +
-		"			 String[] s;\n" +
-		"			 s = (@Marker @Readonly String @Marker []) o;\n" +
-		"		 }\n" +
-		"        if (o instanceof @Readonly List<?>[]) {\n" +
-		"            List<?>[] es;\n" +
-		"			 es = (@Marker List<?> @SingleMember(0) []) o;\n" +
-		"        }\n" +
-		"    }\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  void method(Object o) {\n" +
-		"    if ((o instanceof String[]))\n" +
-		"        {\n" +
-		"          String[] s;\n" +
-		"          s = (@Marker @Readonly String @Marker []) o;\n" +
-		"        }\n" +
-		"    if ((o instanceof @Readonly List<?>[]))\n" +
-		"        {\n" +
-		"          List<?>[] es;\n" +
-		"          es = (@Marker List<?> @SingleMember(0) []) o;\n" +
-		"        }\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0104", expectedUnitToString );
-}
-
-
-// To test Parser.consumeCastExpressionWithPrimitiveType() with Type Annotations
-public void test0105() throws IOException {
-	String source =
-		"import java.util.HashMap;\n" +
-		"class X {\n" +
-		"	public static void main(String[] args) {\n" +
-		"		HashMap<Byte, Byte> subst;\n" +
-		"		subst = new HashMap<Byte, Byte>();\n" +
-		"		subst.put((@Marker byte)1, (@Positive byte)1);\n" +
-		"		if (1 + subst.get((@Positive @Normal(value = 10) byte)1) > 0.f) {\n" +
-		"			System.out.println(\"SUCCESS\");\n" +
-		"		}		\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"import java.util.HashMap;\n" +
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    HashMap<Byte, Byte> subst;\n" +
-		"    subst = new HashMap<Byte, Byte>();\n" +
-		"    subst.put((@Marker byte) 1, (@Positive byte) 1);\n" +
-		"    if (((1 + subst.get((@Positive @Normal(value = 10) byte) 1)) > 0.f))\n" +
-		"        {\n" +
-		"          System.out.println(\"SUCCESS\");\n" +
-		"        }\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0105", expectedUnitToString );
-}
-
-// To test Parser.consumeCastExpressionWithPrimitiveType() with Type Annotations
-public void test0106() throws IOException {
-	String source =
-		"class X{\n" +
-		"	private float x, y, z;\n" +
-		"	float magnitude () {\n" +
-		"		return (@Marker @Positive float) Math.sqrt((x*x) + (y*y) + (z*z));\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  private float x;\n" +
-		"  private float y;\n" +
-		"  private float z;\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  float magnitude() {\n" +
-		"    return (@Marker @Positive float) Math.sqrt((((x * x) + (y * y)) + (z * z)));\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0106", expectedUnitToString );
-}
-
-// To test Parser.consumeCastExpressionWithQualifiedGenericsArray() with Type Annotations
-// Javac version b76 crashes on type annotations on type arguments to parameterized classes
-// in a qualified generic reference
-public void test0107() throws IOException {
-	String source =
-		"class C1<T> {\n" +
-		"	class C11 {	}\n" +
-		"	@Marker class C12 {\n" +
-		"		T t;\n" +
-		"		C1<@Readonly T>.C11 m() {\n" +
-		"			C1<@Readonly T>.C11[] ts;\n" +
-		"			ts = (@Marker C1<@Readonly T>.C11[]) new @Marker C1<?>.C11 @Normal(value = 5) [5];\n" +
-		"			return ts;\n" +
-		"		}\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class C1<T> {\n" +
-		"  class C11 {\n" +
-		"    C11() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"  }\n" +
-		"  @Marker class C12 {\n" +
-		"    T t;\n" +
-		"    C12() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"    C1<@Readonly T>.C11 m() {\n" +
-		"      C1<@Readonly T>.C11[] ts;\n" +
-		"      ts = (@Marker C1<@Readonly T>.C11[]) new @Marker C1<?>.C11 @Normal(value = 5) [5];\n" +
-		"      return ts;\n" +
-		"    }\n" +
-		"  }\n" +
-		"  C1() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0107", expectedUnitToString );
-}
-
-// To test Parser.consumeFormalParameter() with Type Annotations
-public void test0108() throws IOException {
-	String source =
-		"class X {\n" +
-		"	int field;" +
-		"	public void test(@Marker X x,@Positive int i){\n" +
-		"		x.field = i;\n" +
-		"	}\n" +
-		"	public static void main(@Readonly String args @Normal(10) []){" +
-		"		System.exit(0);\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  int field;\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void test(@Marker X x, @Positive int i) {\n" +
-		"    x.field = i;\n" +
-		"  }\n" +
-		"  public static void main(@Readonly String @Normal(10) [] args) {\n" +
-		"    System.exit(0);\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0108", expectedUnitToString );
-}
-
-// To test Parser.consumeFormalParameter() with Type Annotations
-public void test0109() throws IOException {
-	String source =
-		"class X<@Marker T> {\n" +
-		"	T field;" +
-		"	public void test(@Marker @SingleMember(1) X<? extends @Marker Object> x,@Positive T i){\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<@Marker T> {\n" +
-		"  T field;\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void test(@Marker @SingleMember(1) X<? extends @Marker Object> x, @Positive T i) {\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0109", expectedUnitToString );
-}
-
-// To test Parser.consumeClassInstanceCreationExpressionQualifiedWithTypeArguments()
-// with Type Annotations
-// Javac b76 crashes with type annotations in qualified class instance creation expression
-public void test0110() throws IOException {
-	String source =
-		"class X {\n" +
-		"	class MX {\n" +
-		"		@Marker <T> MX(T t){\n" +
-		"			System.out.println(t);\n" +
-		"		}\n" +
-		"	}\n" +
-		"	public static void main(String[] args) {\n" +
-		"		new @Marker @SingleMember(10) X().new <@Readonly String> @Marker MX(\"SUCCESS\");\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-			"class X {\n" +
-			"  class MX {\n" +
-			"    @Marker <T>MX(T t) {\n" +
-			"      super();\n" +
-			"      System.out.println(t);\n" +
-			"    }\n" +
-			"  }\n" +
-			"  X() {\n" +
-			"    super();\n" +
-			"  }\n" +
-			"  public static void main(String[] args) {\n" +
-			"    new @Marker @SingleMember(10) X().new <@Readonly String>@Marker MX(\"SUCCESS\");\n" +
-			"  }\n" +
-			"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0110", expectedUnitToString);
-}
-
-// To test Parser.consumeClassInstanceCreationExpressionWithTypeArguments()
-// with Type Annotations
-public void test0111() throws IOException {
-	String source =
-		"class X {\n" +
-		"	public <T> X(T t){\n" +
-		"		System.out.println(t);\n" +
-		"	}\n" +
-		"	public static void main(String[] args) {\n" +
-		"		new <@Readonly String> @Marker @SingleMember(0) X(\"SUCCESS\");\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString =
-			"class X {\n" +
-			"  public <T>X(T t) {\n" +
-			"    super();\n" +
-			"    System.out.println(t);\n" +
-			"  }\n" +
-			"  public static void main(String[] args) {\n" +
-			"    new <@Readonly String>@Marker @SingleMember(0) X(\"SUCCESS\");\n" +
-			"  }\n" +
-			"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0111", expectedUnitToString);
-}
-
-// To test Parser.consumeEnhancedForStatementHeaderInit() with Type Annotations
-public void test0112() throws IOException {
-	String source =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"   List list() { return null; }\n" +
-		"   void m2() { for (@SingleMember(10) Iterator<@Marker X> i = list().iterator(); i.hasNext();); }\n" +
-		"	void m3() {\n" +
-		"		Integer [] array;\n" +
-		"		array = new Integer [] {1, 2, 3};\n" +
-		"		List<List<X>> xList;\n" +
-		"		xList = null;\n" +
-		"		for(@Positive @SingleMember(10) Integer i: array) {}\n" +
-		"		for(@Marker @Normal(value = 5) List<@Readonly X> x: xList) {}\n" +
-		"	}" +
-		"}\n";
-	String expectedUnitToString =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  List list() {\n" +
-		"    return null;\n" +
-		"  }\n" +
-		"  void m2() {\n" +
-		"    for (@SingleMember(10) Iterator<@Marker X> i = list().iterator();; i.hasNext(); ) \n" +
-		"      ;\n" +
-		"  }\n" +
-		"  void m3() {\n" +
-		"    Integer[] array;\n" +
-		"    array = new Integer[]{1, 2, 3};\n" +
-		"    List<List<X>> xList;\n" +
-		"    xList = null;\n" +
-		"    for (@Positive @SingleMember(10) Integer i : array) \n" +
-		"      {\n" +
-		"      }\n" +
-		"    for (@Marker @Normal(value = 5) List<@Readonly X> x : xList) \n" +
-		"      {\n" +
-		"      }\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_COMPLETION_PARSER & ~CHECK_SELECTION_PARSER & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0112", expectedUnitToString );
-	expectedUnitToString =
-		"import java.util.*;\n" +
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  List list() {\n" +
-		"    return null;\n" +
-		"  }\n" +
-		"  void m2() {\n" +
-		"    for (@SingleMember(10) Iterator<@Marker X> i;; i.hasNext(); ) \n" +
-		"      ;\n" +
-		"  }\n" +
-		"  void m3() {\n" +
-		"    Integer[] array;\n" +
-		"    array = new Integer[]{1, 2, 3};\n" +
-		"    List<List<X>> xList;\n" +
-		"    xList = null;\n" +
-		"    for (@Positive @SingleMember(10) Integer i : array) \n" +
-		"      {\n" +
-		"      }\n" +
-		"    for (@Marker @Normal(value = 5) List<@Readonly X> x : xList) \n" +
-		"      {\n" +
-		"      }\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_COMPLETION_PARSER & CHECK_SELECTION_PARSER, source.toCharArray(), null, "test0112", expectedUnitToString );
-}
-
-// To test Parser.consumeEnterAnonymousClassBody() with Type Annotations
-public void test0113() throws IOException {
-	String source =
-		"@Marker class X {\n" +
-		"  void f(@Normal(value = 5) X this) {\n" +
-		"    new @Marker @SingleMember(10) Object() {\n" +
-		"      void foo(){\n" +
-		"        System.out.println(\"test\");\n" +
-		"      }\n" +
-		"    }.foo();\n" +
-		"  }\n" +
-		"}";
-	String expectedUnitToString =
-		"@Marker class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  void f(@Normal(value = 5) X this) {\n" +
-		"    new @Marker @SingleMember(10) Object() {\n" +
-		"  void foo() {\n" +
-		"    System.out.println(\"test\");\n" +
-		"  }\n" +
-		"}.foo();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0113", expectedUnitToString );
-}
-
-// To test Parser.consumeEnterAnonymousClassBody() with Type Annotations
-public void test0114() throws IOException {
-	String source =
-		"class Toplevel2{\n" +
-		"    public boolean foo(){\n" +
-		"    Toplevel2 o;\n" +
-		"	 o = new @Marker @Normal(value = 5) Toplevel2() { \n" +
-		"              public boolean foo() {  return false; }  // no copy in fact\n" +
-		"              };\n" +
-		"    return o.foo();\n" +
-		"  }\n" +
-		"}";
-	String expectedUnitToString =
-		"class Toplevel2 {\n" +
-		"  Toplevel2() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public boolean foo() {\n" +
-		"    Toplevel2 o;\n" +
-		"    o = new @Marker @Normal(value = 5) Toplevel2() {\n" +
-		"  public boolean foo() {\n" +
-		"    return false;\n" +
-		"  }\n" +
-		"};\n" +
-		"    return o.foo();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0114", expectedUnitToString );
-}
-
-// To test Parser.consumeEnterAnonymousClassBody() with Type Annotations
-public void test0115() throws IOException {
-	String source =
-		"class X <T> {\n" +
-		"    T foo(T t) {\n" +
-		"        System.out.println(t);\n" +
-		"        return t;\n" +
-		"    }\n" +
-		"    public static void main(String @Normal(value =  5) [] args) {\n" +
-		"        new @Marker X<@SingleMember(10) @Normal(value = 5) XY>() {\n" +
-		"            void run() {\n" +
-		"                foo(new @Marker XY());\n" +
-		"            }\n" +
-		"        }.run();\n" +
-		"    }\n" +
-		"}\n" +
-		"@Marker class XY {\n" +
-		"    public String toString() {\n" +
-		"        return \"SUCCESS\";\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<T> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  T foo(T t) {\n" +
-		"    System.out.println(t);\n" +
-		"    return t;\n" +
-		"  }\n" +
-		"  public static void main(String @Normal(value = 5) [] args) {\n" +
-		"    new @Marker X<@SingleMember(10) @Normal(value = 5) XY>() {\n" +
-		"  void run() {\n" +
-		"    foo(new @Marker XY());\n" +
-		"  }\n" +
-		"}.run();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class XY {\n" +
-		"  XY() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public String toString() {\n" +
-		"    return \"SUCCESS\";\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0115", expectedUnitToString );
-}
-
-// To test Parser.consumeInsideCastExpressionLL1() with Type Annotations
-public void test0116() throws IOException {
-	String source =
-		"class X{\n" +
-		"  public void test1(){\n" +
-		"    throw (@Marker Error) null; \n" +
-		"  }  \n" +
-		"  public void test2(){\n" +
-		"    String s;\n" +
-		"	 s = (@Marker @SingleMember(10) String) null;\n" +
-		"	 byte b;\n" +
-		"	 b = 0;\n" +
-		"	 Byte i;\n" +
-		"	 i = (@Positive Byte) b;\n" +
-		"  }  \n" +
-		"  public void test3(java.io.Serializable name) {\n" +
-		"     Object temp;\n" +
-		"	  temp = (Object)name;\n" +
-		"     System.out.println( (String)temp );\n" +
-		"  }\n" +
-		"}";
-	String expectedUnitToString =
-		"class X {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void test1() {\n" +
-		"    throw (@Marker Error) null;\n" +
-		"  }\n" +
-		"  public void test2() {\n" +
-		"    String s;\n" +
-		"    s = (@Marker @SingleMember(10) String) null;\n" +
-		"    byte b;\n" +
-		"    b = 0;\n" +
-		"    Byte i;\n" +
-		"    i = (@Positive Byte) b;\n" +
-		"  }\n" +
-		"  public void test3(java.io.Serializable name) {\n" +
-		"    Object temp;\n" +
-		"    temp = (Object) name;\n" +
-		"    System.out.println((String) temp);\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0116", expectedUnitToString );
-}
-
-// To test Parser.consumeInstanceOfExpression() with Type Annotations
-public void test0117() throws IOException {
-	String source =
-		"import java.util.*;\n" +
-		"class X <@NonNull T>{\n" +
-		" 	public void test1(Object obj) {\n" +
-		"   	if(obj instanceof @Marker @NonNull X) {\n" +
-		"		 	X newX;\n" +
-		"		 	newX = (@NonNull X) obj;\n" +
-		"	 }\n" +
-		"   }\n" +
-		"	@NonNull T foo(@NonNull T t) {\n" +
-		"       if (t instanceof @NonNull @Marker List<?> @Normal(value = 10) []) {\n" +
-		"           List<?> @SingleMember (10) [] es;\n" +
-		"			es = (@Marker List<?> @SingleMember(10) []) t;\n" +
-		"       }\n" +
-		"		if (t instanceof @Marker @Normal(value = 5) X<?>) {\n" +
-		"			return t;\n" +
-		"		}\n" +
-		"		return t;\n" +
-		"	}\n" +
-		"}";
-	String expectedUnitToString =
-		"import java.util.*;\n" +
-		"class X<@NonNull T> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public void test1(Object obj) {\n" +
-		"    if ((obj instanceof @Marker @NonNull X))\n" +
-		"        {\n" +
-		"          X newX;\n" +
-		"          newX = (@NonNull X) obj;\n" +
-		"        }\n" +
-		"  }\n" +
-		"  @NonNull T foo(@NonNull T t) {\n" +
-		"    if ((t instanceof @NonNull @Marker List<?> @Normal(value = 10) []))\n" +
-		"        {\n" +
-		"          List<?> @SingleMember(10) [] es;\n" +
-		"          es = (@Marker List<?> @SingleMember(10) []) t;\n" +
-		"        }\n" +
-		"    if ((t instanceof @Marker @Normal(value = 5) X<?>))\n" +
-		"        {\n" +
-		"          return t;\n" +
-		"        }\n" +
-		"    return t;\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER , source.toCharArray(), null, "test0117", expectedUnitToString );
-}
-
-// To test Parser.consumeInstanceOfExpressionWithName() with Type Annotations
-public void test0118() throws IOException {
-	String source =
-		"class Outer<E> {\n" +
-		"  Inner inner;\n" +
-		"  class Inner {\n" +
-		"    E e;\n" +
-		"    @NonNull E getOtherElement(Object other) {\n" +
-		"      if (!(other instanceof @Marker @SingleMember(10) Outer<?>.Inner))\n" +
-		"       throw new @Marker IllegalArgumentException(String.valueOf(other));\n" +
-		"      Inner that;\n" +
-		"	   that = (@Marker Inner) other;\n" +
-		"      return that.e;\n" +
-		"    }\n" +
-		"  }\n" +
-		"}";
-	String expectedUnitToString =
-		"class Outer<E> {\n" +
-		"  class Inner {\n" +
-		"    E e;\n" +
-		"    Inner() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"    @NonNull E getOtherElement(Object other) {\n" +
-		"      if ((! (other instanceof @Marker @SingleMember(10) Outer<?>.Inner)))\n" +
-		"          throw new @Marker IllegalArgumentException(String.valueOf(other));\n" +
-		"      Inner that;\n" +
-		"      that = (@Marker Inner) other;\n" +
-		"      return that.e;\n" +
-		"    }\n" +
-		"  }\n" +
-		"  Inner inner;\n" +
-		"  Outer() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER , source.toCharArray(), null, "test0118", expectedUnitToString );
-}
-
-// To test Parser.consumeTypeArgument() with Type Annotations
-public void test0119() throws IOException {
-	String source =
-		"class X<@SingleMember(1) Xp1 extends @Readonly String, @NonNull Xp2 extends @NonNull Comparable>  extends @Marker XS<@SingleMember(10) Xp2> {\n" +
-		"\n" +
-		"    public static void main(String @Marker [] args) {\n" +
-		"        Integer w;\n" +
-		"        w = new @Marker X<@Readonly @SingleMember(10) String,@Positive Integer>().get(new @Positive Integer(12));\n" +
-		"        System.out.println(\"SUCCESS\");\n" +
-		"	 }\n" +
-		"    Xp2 get(@Marker X this, Xp2 t) {\n" +
-		"        System.out.print(\"{X::get}\");\n" +
-		"        return super.get(t);\n" +
-		"    }\n" +
-		"}\n" +
-		"@Marker class XS <@NonNull XSp1> {\n" +
-		"    XSp1 get(XSp1 t) {\n" +
-		"		 @NonNull @SingleMember(10) Y.M mObject;\n" +
-		"		 mObject = new @SingleMember(10) @NonNull Y.M();\n" +
-		"        System.out.print(\"{XS::get}\");\n" +
-		"        return t;\n" +
-		"    }\n" +
-		"}\n" +
-		"class X2<T,E>{}\n" +
-		"@Marker class Y extends @Marker X2<@NonNull Y.M, @NonNull @SingleMember(1) Y.N> {\n" +
-		"	static class M{}\n" +
-		"	static class N extends M{}\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<@SingleMember(1) Xp1 extends @Readonly String, @NonNull Xp2 extends @NonNull Comparable> extends @Marker XS<@SingleMember(10) Xp2> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String @Marker [] args) {\n" +
-		"    Integer w;\n" +
-		"    w = new @Marker X<@Readonly @SingleMember(10) String, @Positive Integer>().get(new @Positive Integer(12));\n" +
-		"    System.out.println(\"SUCCESS\");\n" +
-		"  }\n" +
-		"  Xp2 get(@Marker X this, Xp2 t) {\n" +
-		"    System.out.print(\"{X::get}\");\n" +
-		"    return super.get(t);\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class XS<@NonNull XSp1> {\n" +
-		"  XS() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  XSp1 get(XSp1 t) {\n" +
-		"    @NonNull @SingleMember(10) Y.M mObject;\n" +
-		"    mObject = new @SingleMember(10) @NonNull Y.M();\n" +
-		"    System.out.print(\"{XS::get}\");\n" +
-		"    return t;\n" +
-		"  }\n" +
-		"}\n" +
-		"class X2<T, E> {\n" +
-		"  X2() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class Y extends @Marker X2<@NonNull Y.M, @NonNull @SingleMember(1) Y.N> {\n" +
-		"  static class M {\n" +
-		"    M() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"  }\n" +
-		"  static class N extends M {\n" +
-		"    N() {\n" +
-		"      super();\n" +
-		"    }\n" +
-		"  }\n" +
-		"  Y() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0119", expectedUnitToString );
-}
-
-// To test Parser.consumeTypeArgument() with Type Annotations
-public void test0120() throws IOException {
-	String source =
-		"class X<A1, A2, A3, A4, A5, A6, A7, A8> {\n" +
-		"}\n" +
-		"class Y {\n" +
-		"	@Marker X<int @Marker [], short @SingleMember(1) [] @Marker [], long[] @NonNull [][], float[] @Marker [] @Normal(value = 5) [][], double[][]@Marker [] @SingleMember(10) [][], boolean[][][][][][], char[] @Marker [][][][][][], Object[][]@Marker [] @SingleMember(10) [] @Normal(value = 5) [][][][][]> x;\n" +
-		"}\n";
-	String expectedUnitToString =
-		"class X<A1, A2, A3, A4, A5, A6, A7, A8> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"class Y {\n" +
-		"  @Marker X<int @Marker [], short @SingleMember(1) [] @Marker [], long[] @NonNull [][], float[] @Marker [] @Normal(value = 5) [][], double[][] @Marker [] @SingleMember(10) [][], boolean[][][][][][], char[] @Marker [][][][][][], Object[][] @Marker [] @SingleMember(10) [] @Normal(value = 5) [][][][][]> x;\n" +
-		"  Y() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0120", expectedUnitToString );
-}
-
-// To test Parser.consumeTypeArgumentReferenceType1() with Type Annotations
-public void test0121() throws IOException {
-	String source =
-		"@Marker class X <@NonNull T> {\n" +
-		"    protected T t;\n" +
-		"    @Marker X(@NonNull T t) {\n" +
-		"        this.t = t;\n" +
-		"    }\n" +
-		"    public static void main(String[] args) {\n" +
-		"	  X<@Marker X<@Readonly @NonNull String>> xs;\n" +
-		"	  xs = new @Marker X<@Marker X<@Readonly @NonNull String>>(new @Marker X<@Readonly @NonNull @SingleMember(10) String>(\"SUCCESS\"));\n" +
-		"	  System.out.println(xs.t.t);\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"@Marker class X<@NonNull T> {\n" +
-		"  protected T t;\n" +
-		"  @Marker X(@NonNull T t) {\n" +
-		"    super();\n" +
-		"    this.t = t;\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    X<@Marker X<@Readonly @NonNull String>> xs;\n" +
-		"    xs = new @Marker X<@Marker X<@Readonly @NonNull String>>(new @Marker X<@Readonly @NonNull @SingleMember(10) String>(\"SUCCESS\"));\n" +
-		"    System.out.println(xs.t.t);\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0121", expectedUnitToString );
-}
-
-// To test Parser.consumeTypeParameter1WithExtendsAndBounds() and Parser.consumeWildcardBoundsSuper() with
-// Type Annotations
-public void test0122() throws IOException {
-	String source =
-		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable<@Marker Foo1> {\n" +
-		"	public int compareTo(Foo1 arg0) {\n" +
-		"		return 0;\n" +
-		"	}\n" +
-		"}\n" +
-		"class Foo1 {}\n" +
-		"@Marker class X<@NonNull T extends @NonNull @Normal (value = 5) Object & @Marker Comparable<? super @NonNull T>> {\n" +
-		"    public static void main(String[] args) {\n" +
-		"        new @Marker @SingleMember(10) X<@Marker Foo>();\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable<@Marker Foo1> {\n" +
-		"  Foo() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public int compareTo(Foo1 arg0) {\n" +
-		"    return 0;\n" +
-		"  }\n" +
-		"}\n" +
-		"class Foo1 {\n" +
-		"  Foo1() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class X<@NonNull T extends @NonNull @Normal(value = 5) Object & @Marker Comparable<? super @NonNull T>> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    new @Marker @SingleMember(10) X<@Marker Foo>();\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0122", expectedUnitToString );
-}
-
-// To test Parser.consumeTypeParameter1WithExtendsAndBounds() with Type Annotations
-public void test0123() throws IOException {
-	String source =
-		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable {\n" +
-		"	public int compareTo(Object arg0) {\n" +
-		"		return 0;\n" +
-		"	}\n" +
-		"}\n" +
-		"class Foo1 {}\n" +
-		"@Marker class X<@NonNull T extends @NonNull @Normal (value = 5) Object & @Marker Comparable, @NonNull V extends @Readonly Object> {\n" +
-		"    public static void main(String[] args) {\n" +
-		"        new @Marker @SingleMember(10) X<@Marker Foo, @SingleMember(0) Foo1>();\n" +
-		"		 Class <@NonNull Foo> c;\n" +
-		"    }\n" +
-		"}\n";
-	String expectedUnitToString =
-		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable {\n" +
-		"  Foo() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public int compareTo(Object arg0) {\n" +
-		"    return 0;\n" +
-		"  }\n" +
-		"}\n" +
-		"class Foo1 {\n" +
-		"  Foo1() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"}\n" +
-		"@Marker class X<@NonNull T extends @NonNull @Normal(value = 5) Object & @Marker Comparable, @NonNull V extends @Readonly Object> {\n" +
-		"  X() {\n" +
-		"    super();\n" +
-		"  }\n" +
-		"  public static void main(String[] args) {\n" +
-		"    new @Marker @SingleMember(10) X<@Marker Foo, @SingleMember(0) Foo1>();\n" +
-		"    Class<@NonNull Foo> c;\n" +
-		"  }\n" +
-		"}\n";
-	checkParse(source.toCharArray(), null, "test0123", expectedUnitToString );
-}
-//To test type annotations on static class member access in a declaration
-public void test0125() throws IOException {
-	String source =
-		"public class X extends @A(\"Hello, World!\") Y<@B @C('(') String[] @D[]> {}";
-	String expectedUnitToString =
-		"public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String[] @D []> {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0125", expectedUnitToString );
-}
-//To test type annotations on static class member access in a declaration
-public void test0126() throws IOException {
-	String source =
-		"public class X {\n" +
-		"	@A(\"Hello, World!\") @B @C('(') String@E[] @D[] f;\n" +
-		"}";
-	String expectedUnitToString =
-		"public class X {\n" + 
-		"  @A(\"Hello, World!\") @B @C(\'(\') String @E [] @D [] f;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0126", expectedUnitToString );
-}
-//To test type annotations on static class member access in a declaration
-public void test0127() throws IOException {
-	String source =
-		"public class X {\n" +
-		"	@A(\"Hello, World!\") Y<@B @C('(') String[] @D[]> f;\n" +
-		"}";
-	String expectedUnitToString =
-		"public class X {\n" + 
-		"  @A(\"Hello, World!\") Y<@B @C(\'(\') String[] @D []> f;\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0127", expectedUnitToString );
-}
-//type class literal expression
-public void test0128() throws IOException {
-	String source = 
-	"public class X {\n" + 
-	"	public boolean foo(String s) {\n" + 
-	"		return (s instanceof @C('_') Object[]);\n" + 
-	"	}\n" + 
-	"	public Object foo1(String s) {\n" + 
-	"		return new @B(3) @A(\"new Object\") Object[] {};\n" + 
-	"	}\n" + 
-	"	public Class foo2(String s) {\n" + 
-	"		return null;\n" + 
-	"	}\n" + 
-	"	public Class foo3(String s) {\n" + 
-	"		return null;\n" + 
-	"	}\n" + 
-	"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public boolean foo(String s) {\n" + 
-		"    return (s instanceof @C(\'_\') Object[]);\n" + 
-		"  }\n" + 
-		"  public Object foo1(String s) {\n" + 
-		"    return new @B(3) @A(\"new Object\") Object[]{};\n" + 
-		"  }\n" + 
-		"  public Class foo2(String s) {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"  public Class foo3(String s) {\n" + 
-		"    return null;\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0128", expectedUnitToString );
-}
-//instanceof checks 
-public void test0129() throws IOException {
-	String source = "public class Clazz {\n" +
-					"public static void main(Object o) {\n" +
-					"if (o instanceof @Readonly String) {\n" +
-					"}\n" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class Clazz {\n" + 
-		"  public Clazz() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(Object o) {\n" + 
-		"    if ((o instanceof @Readonly String))\n" + 
-		"        {\n" + 
-		"        }\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0129", expectedUnitToString);
-}
-//instanceof checks 
-public void test0130() throws IOException {
-	String source = "public class Clazz {\n" +
-					"public static void foo() {\n" +
-					"	if (o instanceof @Readonly String[]) {}" +
-					"}\n" +
-					"}";
-	String expectedUnitToString = 
-		"public class Clazz {\n" + 
-		"  public Clazz() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void foo() {\n" + 
-		"    if ((o instanceof @Readonly String[]))\n" + 
-		"        {\n" + 
-		"        }\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-//cast
-public void test0131() throws IOException {
-	String source =
-		"public class X {\n" + 
-		"	public void foo(Object o) {\n" + 
-		"		if (o instanceof String[][]) {\n" +
-		"			String[][] tab = (@C('_') @B(3) String[] @A[]) o;\n" +
-		"			System.out.println(tab.length);\n" +
-		"		}\n" + 
-		"		System.out.println(o);\n" +
-		"	}\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo(Object o) {\n" + 
-		"    if ((o instanceof String[][]))\n" + 
-		"        {\n" + 
-		"          String[][] tab = (@C(\'_\') @B(3) String[] @A []) o;\n" + 
-		"          System.out.println(tab.length);\n" + 
-		"        }\n" + 
-		"    System.out.println(o);\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-//cast
-public void test0132() throws IOException {
-	String source =
-		"public class X {\n" + 
-		"	public void foo(Object o) {\n" + 
-		"		if (o instanceof String[][]) {\n" +
-		"			String[][] tab = (@C('_') @B(3) String@D[] @A[]) o;\n" +
-		"			System.out.println(tab.length);\n" +
-		"		}\n" + 
-		"		System.out.println(o);\n" +
-		"	}\n" + 
-		"}";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public void foo(Object o) {\n" + 
-		"    if ((o instanceof String[][]))\n" + 
-		"        {\n" + 
-		"          String[][] tab = (@C(\'_\') @B(3) String @D [] @A []) o;\n" + 
-		"          System.out.println(tab.length);\n" + 
-		"        }\n" + 
-		"    System.out.println(o);\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-//generic type arguments in a generic method invocation
-public void test0133() throws IOException {
-	String source =
-		"public class X {\n" +
-		"	static <T, U> T foo(T t, U u) {\n" +
-		"		return t;\n" +
-		"	}\n" +
-		"	public static void main(String[] args) {\n" +
-		"		System.out.println(X.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  static <T, U>T foo(T t, U u) {\n" + 
-		"    return t;\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    System.out.println(X.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-//generic type arguments in a generic method invocation
-public void test0134() throws IOException {
-	String source =
-		"public class X {\n" +
-		"\n" +
-		"	<T, U> T foo(T t, U u) {\n" +
-		"		return t;\n" +
-		"	}\n" +
-		"	public static void main(String[] args) {\n" +
-		"		X x = new X();\n" +
-		"		System.out.println(x.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  public X() {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  <T, U>T foo(T t, U u) {\n" + 
-		"    return t;\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" +
-		"    X x = new X();\n" +
-		"    System.out.println(x.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-//generic type arguments in a generic constructor invocation
-public void test0135() throws IOException {
-	String source =
-		"public class X {\n" +
-		"	<T, U> X(T t, U u) {\n" +
-		"	}\n" +
-		"	public static void main(String[] args) {\n" +
-		"		X x = new <@D() @A(value = \"hello\") String, @B X> X();\n" +
-		"		System.out.println(x);\n" +
-		"	}\n" +
-		"}\n";
-	String expectedUnitToString = 
-		"public class X {\n" + 
-		"  <T, U>X(T t, U u) {\n" + 
-		"    super();\n" + 
-		"  }\n" + 
-		"  public static void main(String[] args) {\n" + 
-		"    X x = new <@D() @A(value = \"hello\") String, @B X>X();\n" + 
-		"    System.out.println(x);\n" + 
-		"  }\n" + 
-		"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383600 -- Receiver annotation - new syntax.
-public void test0136() throws IOException {
-	String source =
-			"public class X<T> {\n" +
-			"  public class Y<K> {\n" +
-			"    void foo(@Marker X<T> this) {\n" +
-			"    }\n" +
-			"    public class Z {\n" +
-			"      Z(@D() @A(value = \"hello\") X<T>.Y<K> X.Y.this) {\n" +
-			"      }\n" +
-			"    }\n" +
-			"  }\n" +
-			"  public static void main(String[] args) {\n" +
-			"    new X<String>().new Y<Integer>().new Z();\n" +
-			"  }\n" +
-			"}\n";
-	String expectedUnitToString = 
-			"public class X<T> {\n" + 
-			"  public class Y<K> {\n" + 
-			"    public class Z {\n" + 
-			"      Z(@D() @A(value = \"hello\") X<T>.Y<K> X.Y.this) {\n" + 
-			"        super();\n" + 
-			"      }\n" + 
-			"    }\n" + 
-			"    public Y() {\n" + 
-			"      super();\n" + 
-			"    }\n" + 
-			"    void foo(@Marker X<T> this) {\n" + 
-			"    }\n" + 
-			"  }\n" + 
-			"  public X() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"  public static void main(String[] args) {\n" + 
-			"    new X<String>().new Y<Integer>().new Z();\n" + 
-			"  }\n" + 
-			"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
-}
-// Support type annotations for wildcard
-// https://bugs.eclipse.org/bugs/show_bug.cgi?id=388085
-public void test0137() throws IOException {
-	String source = 
-			"class X {\n" +
-			"	public void main(Four<@Marker ? super String, @Marker ? extends Object> param) {\n" +
-			"		One<@Marker ? extends Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String,@Marker ? extends Object>>>> one = null;\n" +
-			"		Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String,@Marker ? extends Object>>> two = null;\n" +
-			"		Three<@Marker ? extends Four<@Marker ? super String,@Marker ? extends Object>> three = null;\n" +
-			"		Four<@Marker ? super String,@Marker ? extends Object> four = param;\n" +
-			"	}\n" +
-			"}\n" +
-			"class One<R> {}\n" +
-			"class Two<S> {}\n" +
-			"class Three<T> {}\n" +
-			"class Four<U, V> {}\n" +
-			"@interface Marker {}";
-	String expectedUnitToString = 
-			"class X {\n" + 
-			"  X() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"  public void main(Four<@Marker ? super String, @Marker ? extends Object> param) {\n" + 
-			"    One<@Marker ? extends Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;\n" + 
-			"    Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String, @Marker ? extends Object>>> two = null;\n" + 
-			"    Three<@Marker ? extends Four<@Marker ? super String, @Marker ? extends Object>> three = null;\n" + 
-			"    Four<@Marker ? super String, @Marker ? extends Object> four = param;\n" + 
-			"  }\n" + 
-			"}\n" + 
-			"class One<R> {\n" + 
-			"  One() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"}\n" + 
-			"class Two<S> {\n" + 
-			"  Two() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"}\n" + 
-			"class Three<T> {\n" + 
-			"  Three() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"}\n" + 
-			"class Four<U, V> {\n" + 
-			"  Four() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"}\n" + 
-			"@interface Marker {\n" + 
-			"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0137", expectedUnitToString);
-}
-public void test0138() throws IOException {
-	String source = 
-			"import java.lang.annotation.Target;\n" +
-			"import static java.lang.annotation.ElementType.*;\n" +
-			"public class X {\n" +
-			"	public void foo() {\n" +
-			"		int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [bar()] @Marker @Marker2 [];\n" +
-			"		int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [X.bar2(2)] @Marker @Marker2 [];\n" +
-			"	}\n" +
-			"	public int bar() {\n" +
-			"		return 2;\n" +
-			"	}\n" +
-			"	public static int bar2(int k) {\n" +
-			"		return k;\n" + 
-			"	}\n" +
-			"}\n" +
-			"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-			"@interface Marker {}\n" +
-			"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-			"@interface Marker2 {}\n";
-	String expectedUnitToString = 
-			"import java.lang.annotation.Target;\n" + 
-			"import static java.lang.annotation.ElementType.*;\n" + 
-			"public class X {\n" + 
-			"  public X() {\n" + 
-			"    super();\n" + 
-			"  }\n" + 
-			"  public void foo() {\n" + 
-			"    int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [bar()] @Marker @Marker2 [];\n" + 
-			"    int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [X.bar2(2)] @Marker @Marker2 [];\n" + 
-			"  }\n" + 
-			"  public int bar() {\n" + 
-			"    return 2;\n" + 
-			"  }\n" + 
-			"  public static int bar2(int k) {\n" + 
-			"    return k;\n" + 
-			"  }\n" + 
-			"}\n" + 
-			"@Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker {\n" + 
-			"}\n" + 
-			"@Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker2 {\n" + 
-			"}\n";
-	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0137", expectedUnitToString);
-}
-}
+/*******************************************************************************
+ * Copyright (c) 2009, 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *        Andy Clement (GoPivotal, Inc) aclement@gopivotal.com - Contributions for
+ *                          Bug 383624 - [1.8][compiler] Revive code generation support for type annotations (from Olivier's work)
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.parser;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.util.HashMap;
+import java.util.Map;
+import junit.framework.Test;
+import org.eclipse.jdt.core.tests.util.CompilerTestSetup;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.ast.Annotation;
+import org.eclipse.jdt.internal.compiler.ast.Argument;
+import org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;
+import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;
+import org.eclipse.jdt.internal.compiler.ast.TypeReference;
+import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
+import org.eclipse.jdt.internal.compiler.lookup.ClassScope;
+import org.eclipse.jdt.internal.compiler.lookup.MethodScope;
+
+public class TypeAnnotationSyntaxTest extends AbstractSyntaxTreeTest {
+
+	private static String  jsr308TestScratchArea = "c:\\Jsr308TestScratchArea";
+	private static String referenceCompiler = "C:\\jdk-7-ea-bin-b75-windows-i586-30_oct_2009\\jdk7\\bin\\javac.exe";
+	
+	static {
+//		TESTS_NAMES = new String [] { "test0137" };
+	}
+	public static Class testClass() {
+		return TypeAnnotationSyntaxTest.class;
+	}
+	public void initialize(CompilerTestSetup setUp) {
+		super.initialize(setUp);
+	}
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+	}
+	
+	static final class LocationPrinterVisitor extends ASTVisitor {
+		TypeReference enclosingReference;
+		Map locations;
+
+		public LocationPrinterVisitor() {
+			this.locations = new HashMap();
+		}
+
+		public Map getLocations() {
+			return this.locations;
+		}
+		public boolean visit(FieldDeclaration fieldDeclaration, MethodScope scope) {
+			this.enclosingReference = fieldDeclaration.type;
+			return true;
+		}
+		public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
+			TypeReference returnType = methodDeclaration.returnType;
+			if (returnType != null) {
+				this.enclosingReference = returnType;
+				returnType.traverse(this, scope);
+			}
+			if (methodDeclaration.thrownExceptions != null) {
+				int thrownExceptionsLength = methodDeclaration.thrownExceptions.length;
+				for (int i = 0; i < thrownExceptionsLength; i++) {
+					TypeReference typeReference = methodDeclaration.thrownExceptions[i];
+					this.enclosingReference = typeReference;
+					typeReference.traverse(this, scope);
+				}
+			}
+			return false;
+		}
+		public boolean visit(Argument argument, ClassScope scope) {
+			this.enclosingReference = argument.type;
+			return true;
+		}
+		public boolean visit(Argument argument, BlockScope scope) {
+			this.enclosingReference = argument.type;
+			return true;
+		}
+		public boolean visit(MarkerAnnotation annotation, BlockScope scope) {
+			if (this.enclosingReference != null) {
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
+			}
+			return false;
+		}
+		public boolean visit(SingleMemberAnnotation annotation, BlockScope scope) {
+			if (this.enclosingReference != null) {
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
+			}
+			return false;
+		}
+		public boolean visit(NormalAnnotation annotation, BlockScope scope) {
+			if (this.enclosingReference != null) {
+				storeLocations(annotation, Annotation.getLocations(this.enclosingReference, annotation));
+			}
+			return false;
+		}
+		public void storeLocations(Annotation annotation, int[] tab) {
+			String key = String.valueOf(annotation);
+			if (this.locations.get(key) != null) {
+				return;
+			}
+			if (tab == null) {
+				this.locations.put(key, null);
+				return;
+			}
+			
+			StringBuffer buffer = new StringBuffer("[");
+			for (int i = 0, max = tab.length; i < max; i += 2) {
+				if (i > 0) {
+					buffer.append(", ");
+				}
+				switch (tab[i]) {
+				case 0:
+					buffer.append("ARRAY");
+					break;
+				case 1:
+					buffer.append("INNER_TYPE");
+					break;
+				case 2:
+					buffer.append("WILDCARD");
+					break;
+				case 3:
+					buffer.append("TYPE_ARGUMENT(").append(tab[i+1]).append(')');
+					break;
+				}
+			}
+			buffer.append(']');
+			this.locations.put(key, String.valueOf(buffer));
+		}
+
+		public boolean visit(ArrayTypeReference arrayReference, BlockScope scope) {
+			if (this.enclosingReference == null) return false;
+			return true;
+		}
+		public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
+			if (this.enclosingReference == null) return false;
+			return true;
+		}
+		public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
+			if (this.enclosingReference == null) return false;
+			return true;
+		}
+	}
+public TypeAnnotationSyntaxTest(String testName){
+	super(testName, referenceCompiler, jsr308TestScratchArea);
+	if (referenceCompiler != null) {
+		File f = new File(jsr308TestScratchArea);
+		if (!f.exists()) {
+			f.mkdir();
+		}
+		if (f.exists()) {
+			try {
+				OutputStreamWriter w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Marker.java")));
+				w.write("@interface Marker {}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Normal.java")));
+				w.write("@interface Normal {\n\tint value() default 10;\n}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "SingleMember.java")));
+				w.write("@interface SingleMember {\n\tint value() default 10;\n}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Positive.java")));
+				w.write("@interface Positive {}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Negative.java")));
+				w.write("@interface Negative{}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "Readonly.java")));
+				w.write("@interface Readonly {}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "NonNull.java")));
+				w.write("@interface NonNull {}\n".toCharArray());
+				w.close();
+				w = new OutputStreamWriter(new FileOutputStream(new File(jsr308TestScratchArea + File.separator + "HashMap.java")));
+				w.write("class HashMap<X,Y> {\n class Iterator {}; \n}\n".toCharArray());
+				w.close();
+				CHECK_ALL |= CHECK_JAVAC_PARSER;
+			} catch (IOException e) {
+				// ignore
+			}
+		}
+	}
+}
+
+static {
+//	TESTS_NAMES = new String[] { "test0038", "test0039", "test0040a" };
+//	TESTS_NUMBERS = new int[] { 133, 134, 135 };
+	if (!(new File(referenceCompiler).exists())) {
+		referenceCompiler = null;
+		jsr308TestScratchArea = null;
+	}
+}
+void traverse (File f) throws IOException {
+	if (f.isDirectory()) {
+		File [] files = f.listFiles();
+		for (int i = 0; i < files.length; i++) {
+			traverse(files[i]);
+		}
+	} else {
+		if (f.getName().endsWith(".java")) {
+			System.out.println(f.getCanonicalPath());
+			char [] contents = new char[(int) f.length()];
+			FileInputStream fs = new FileInputStream(f);
+			InputStreamReader isr = new InputStreamReader(fs);
+			isr.read(contents);
+			checkParse(contents, null, f.getCanonicalPath(), null);
+		}
+	}
+}
+public void _test000() throws IOException {
+	traverse(new File("C:\\jsr308tests"));
+}
+
+public void test0001() throws IOException {
+	String source = "@Marker class A extends String {}\n;" +
+					"@Marker class B extends @Marker String {}\n" +
+					"@Marker class C extends @Marker @SingleMember(0) String {}\n" +
+					"@Marker class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {}\n" +
+					"@Marker class E extends String {}\n;";
+
+	String expectedUnitToString = 
+		"@Marker class A extends String {\n" + 
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"@Marker class B extends @Marker String {\n" + 
+		"  B() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"@Marker class C extends @Marker @SingleMember(0) String {\n" + 
+		"  C() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"@Marker class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {\n" + 
+		"  D() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"@Marker class E extends String {\n" + 
+		"  E() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER , source.toCharArray(), null, "test0001", expectedUnitToString);
+}
+public void test0002() throws IOException {
+	String source = "class A extends String {}\n;" +
+					"class B extends @Marker String {}\n" +
+					"class C extends @Marker @SingleMember(0) String {}\n" +
+					"class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {}\n" +
+					"class E extends String {}\n;";
+    
+	String expectedUnitToString = 
+		"class A extends String {\n" + 
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"class B extends @Marker String {\n" + 
+		"  B() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"class C extends @Marker @SingleMember(0) String {\n" + 
+		"  C() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"class D extends @Marker @SingleMember(0) @Normal(Value = 0) String {\n" + 
+		"  D() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n" + 
+		"class E extends String {\n" + 
+		"  E() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0002", expectedUnitToString);
+}
+public void test0003() throws IOException {
+	String source = "@Marker class A implements Comparable, " +
+					"                   @Marker Serializable," +
+					"                   Cloneable {\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"@Marker class A implements Comparable, @Marker Serializable, Cloneable {\n" + 
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0003", expectedUnitToString);
+}
+public void test0004() throws IOException {
+	String source = "@Marker class A implements Comparable, " +
+					"                   @Marker @SingleMember(0) Serializable," +
+					"                   Cloneable {\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"@Marker class A implements Comparable, @Marker @SingleMember(0) Serializable, Cloneable {\n" + 
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0004", expectedUnitToString);
+}
+public void test0005() throws IOException {
+	String source = "@Marker class A implements Comparable, " +
+					"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
+					"                   Cloneable {\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"@Marker class A implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0005", expectedUnitToString);
+}
+public void test0006() throws IOException {
+	String source = "@Marker class A implements @Marker Comparable, " +
+					"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
+					"                   @Marker Cloneable {\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"@Marker class A implements @Marker Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, @Marker Cloneable {\n" +
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0006", expectedUnitToString);
+}
+public void test007() throws IOException {
+	String source = "@Marker class A extends Object implements Comparable, " +
+					"                   @Marker @SingleMember(10) @Normal(Value=0) Serializable," +
+					"                   Cloneable {\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"@Marker class A extends Object implements Comparable, @Marker @SingleMember(10) @Normal(Value = 0) Serializable, Cloneable {\n" +
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0007", expectedUnitToString);
+}
+public void test0008() throws IOException {
+	String source = "@Marker class A extends @Marker Object implements Comparable, " +
+					"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
+					"                   Cloneable {\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"@Marker class A extends @Marker Object implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0008", expectedUnitToString);
+}
+public void test0009() throws IOException {
+	String source = "@Marker class A extends @Marker @SingleMember(0) Object implements Comparable, " +
+	"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
+	"                   Cloneable {\n" +
+	"}\n";
+	String expectedUnitToString = 
+		"@Marker class A extends @Marker @SingleMember(0) Object implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0009", expectedUnitToString);
+}
+public void test0010() throws IOException {
+	String source = "@Marker class A extends @Marker @SingleMember(0) @Normal(Value=0) Object implements Comparable, " +
+	"                   @Marker @SingleMember(0) @Normal(Value=0) Serializable," +
+	"                   Cloneable {\n" +
+	"}\n";
+	String expectedUnitToString = 
+		"@Marker class A extends @Marker @SingleMember(0) @Normal(Value = 0) Object implements Comparable, @Marker @SingleMember(0) @Normal(Value = 0) Serializable, Cloneable {\n" +
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0010", expectedUnitToString);
+}
+public void test0011() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker String[] @Marker[][] s[] @SingleMember(0)[][] @Normal(Value = 0)[][];\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker String[] @Marker [][][] @SingleMember(0) [][] @Normal(Value = 0) [][] s;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0011", expectedUnitToString);
+}
+public void test0012() throws IOException {
+	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
+					"    int[] f[];\n" +
+					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
+					"    float[] p[];\n" +
+					"public static void main(String args[]) {\n" +
+					"    @Readonly String @Nullable[] @NonNull[] s;\n" +
+					"    s = new @Readonly String @NonNull[5] @Nullable[];\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
+		"  int[][] f;\n" + 
+		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    @Readonly String @Nullable [] @NonNull [] s;\n" + 
+		"    s = new @Readonly String @NonNull [5] @Nullable [];\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0012", expectedUnitToString);
+}
+public void test0013() throws IOException {
+	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
+					"    int[] f[];\n" +
+					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
+					"    float[] p[];\n" +
+					"public static void main(String args[]) {\n" +
+					"    @Readonly String s;\n" +
+					"	 s = new @Readonly String @NonNull[] @Nullable[] { {\"Hello\"}, {\"World\"}} [0][0];\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
+		"  int[][] f;\n" + 
+		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    @Readonly String s;\n" + 
+		"    s = new @Readonly String @NonNull [] @Nullable []{{\"Hello\"}, {\"World\"}}[0][0];\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0013", expectedUnitToString);
+}
+public void test0014() throws IOException {
+	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
+					"    int[] f[];\n" +
+					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
+					"    float[] p[];\n" +
+					"public static int main(String args[])[] @Marker[][] @Marker @SingleMember(0) @Normal(Value=0)[][] {\n" +
+					"    @Readonly String @Nullable[] @NonNull[] s;\n" +
+					"    s = new @Readonly String @NonNull[5] @Nullable[];\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
+		"  int[][] f;\n" + 
+		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static int[] @Marker [][] @Marker @SingleMember(0) @Normal(Value = 0) [][] main(String[] args) {\n" +
+		"    @Readonly String @Nullable [] @NonNull [] s;\n" + 
+		"    s = new @Readonly String @NonNull [5] @Nullable [];\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0014", expectedUnitToString);
+
+}
+public void test0015() throws IOException {
+	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
+					"    int[] f[];\n" +
+					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
+					"    float[] p[];\n" +
+					"public static int main(String args[])[] @Marker[][] @Marker @SingleMember(0) @Normal(Value=0)[][] {\n" +
+					"    @Readonly String @Nullable[] @NonNull[] s;\n" +
+					"    s = new @Readonly String @NonNull[5] @Nullable[];\n" +
+					"}\n" +
+					"@Marker public A () {}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
+		"  int[][] f;\n" + 
+		"  @English String[] @NonNull [][] @Nullable [][] s;\n" + 
+		"  float[][] p;\n" + 
+		"  public static int[] @Marker [][] @Marker @SingleMember(0) @Normal(Value = 0) [][] main(String[] args) {\n" + 
+		"    @Readonly String @Nullable [] @NonNull [] s;\n" + 
+		"    s = new @Readonly String @NonNull [5] @Nullable [];\n" + 
+		"  }\n" + 
+		"  public @Marker A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0015", expectedUnitToString);
+}
+// parameters
+public void test0016() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(int[] @SingleMember(10)[][] args[] @Normal(Value = 10)[][])[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(int[] @SingleMember(10) [][][] @Normal(Value = 10) [][] args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0016", expectedUnitToString);
+}
+public void test0017() throws IOException  {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(String[] @SingleMember(10)[][] args[] @Normal(Value = 10)[][])[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(String[] @SingleMember(10) [][][] @Normal(Value = 10) [][] args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0017", expectedUnitToString);
+}
+public void test0018() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(HashMap<String, Object>[] @SingleMember(10)[][] args[] @Normal(Value = 10)[][])[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<String, Object>[] @Normal(Value = 10) [][][] @SingleMember(10) [][] args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0018", expectedUnitToString);
+}
+public void test0019() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker [][] main(HashMap<String, Object>.Iterator[] @SingleMember(10) [][] args[] @Normal(Value = 10) [][])[] @Marker [][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<String, Object>.Iterator[] @Normal(Value = 10) [][][] @SingleMember(10) [][] args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0019", expectedUnitToString);
+}
+// varargs annotation
+public void test0020() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(int[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(int[] @SingleMember(10) [][] @Marker ... args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0020", expectedUnitToString);
+}
+public void test0021() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(String[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(String[] @SingleMember(10) [][] @Marker ... args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0021", expectedUnitToString);
+}
+public void test0022() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(HashMap<Integer,String>[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<Integer, String>[] @SingleMember(10) [][] @Marker ... args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0022", expectedUnitToString);
+}
+public void test0023() throws IOException {
+	String source = "public class A {\n" +
+					"@Marker public int[] @Marker[][] main(HashMap<Integer,String>.Iterator[] @SingleMember(10)[][] @Marker ... args )[] @Marker[][] {\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @Marker [][][] @Marker [][] main(HashMap<Integer, String>.Iterator[] @SingleMember(10) [][] @Marker ... args) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0023", expectedUnitToString);
+}
+// local variables
+public void test0024() throws IOException {
+	String source = "public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" +
+					"public static void main(String args[]) {\n" +
+					"    int[] f[];\n" +
+					"    @English String[] @NonNull[] s[] @Nullable[][];\n" +
+					"    float[] p[];\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A implements @Readonly Comparable, @NonNull Serializable, Cloneable {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    int[][] f;\n" + 
+		"    @English String[] @NonNull [][] @Nullable [][] s;\n" + 
+		"    float[][] p;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0024", expectedUnitToString);
+}
+// type parameter
+public void test0025() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> void foo() {\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"class A {\n" + 
+		"  A() {\n" + 
+		"    super();\n" + 
+		"  }\n" +
+		"  public <Integer, @Positive Integer, @Negative Integer, Integer>void foo() {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0025", expectedUnitToString);
+}
+// Type
+public void test0026() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker int foo() {\n" +
+					"    return 0;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> int bar() {\n" +
+					"    return 0;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0026", null);
+}
+// Type
+public void test0027() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker String foo() {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> String bar () {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0027", null);
+}
+//Type
+public void test0028() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object> foo() {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object> bar () {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0028", null);
+}
+// Type
+public void test0029() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator foo() {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object>.Iterator bar () {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0029", null);
+}
+//Type
+public void test0030() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>.Iterator[] @NonEmpty[][] foo() {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object>.Iterator[] @NonEmpty[][] bar () {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0030", null);
+}
+//Type
+public void test0031() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker int[] @NonEmpty[][] foo() {\n" +
+					"    return 0;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> int[] @NonEmpty[][] bar() {\n" +
+					"    return 0;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0031", null);
+}
+// Type
+public void test0032() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker String[]@NonEmpty[][] foo() {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> String[]@NonEmpty[][] bar () {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0032", null);
+}
+//Type
+public void test0033() throws IOException {
+	String source = "class A {\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> @Marker HashMap<@Readonly String, Object>[] @NonEmpty[][] foo() {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"public <Integer, @Positive Integer, @Negative Integer, Integer> HashMap<String, @NonNull Object>[]@NonEmpty[][] bar () {\n" +
+					"    return null;\n" +
+					"}\n" +
+					"}\n";
+	String expectedError = "";
+	checkParse(CHECK_PARSER, source.toCharArray(), expectedError, "test0033", null);
+}
+// Type0 field declaration.
+public void test0034() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker int k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker int k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0034", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0035() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker String k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker String k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0035", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0036() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker HashMap<@Positive Integer, @Negative Integer> k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker HashMap<@Positive Integer, @Negative Integer> k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0036", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0037() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0037", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0038() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker int[] @NonEmpty[][] k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker int[] @NonEmpty [][] k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0038", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0039() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker String[] @NonEmpty[][]k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker String[] @NonEmpty [][] k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0039", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0040() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker HashMap<@Positive Integer, @Negative Integer>[] @NonEmpty[][] k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker HashMap<@Positive Integer, @Negative Integer>[] @NonEmpty [][] k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0040", expectedUnitToString);
+}
+//Type0 field declaration.
+public void test0041() throws IOException {
+	String source = "public class A {\n" +
+					"    int[] f[];\n" +
+					"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty[][] k;\n" +
+					"    float[] p[];\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  int[][] f;\n" + 
+		"  @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty [][] k;\n" + 
+		"  float[][] p;\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0041", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0042() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker int foo() { return 0; }\n" +
+					"    public int bar() { return 0; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int foo() {\n" + 
+		"    return 0;\n" + 
+		"  }\n" + 
+		"  public int bar() {\n" + 
+		"    return 0;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0042", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0043() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker String foo() { return null; }\n" +
+					"    public String bar() { return null; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker String foo() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public String bar() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0043", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0044() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker HashMap<@Positive Integer, @Negative Integer> foo() { return null; }\n" +
+					"    public HashMap<@Positive Integer, @Negative Integer>  bar() { return null; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker HashMap<@Positive Integer, @Negative Integer> foo() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public HashMap<@Positive Integer, @Negative Integer> bar() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0044", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0045() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator foo() { return null; }\n" +
+					"    public HashMap<@Positive Integer, @Negative Integer>.Iterator  bar() { return null; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator foo() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public HashMap<@Positive Integer, @Negative Integer>.Iterator bar() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0045", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0046() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker int[] foo() @NonEmpty[][] { return 0; }\n" +
+					"    public int[] @NonEmpty[][] bar() { return 0; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker int[] @NonEmpty [][] foo() {\n" + 
+		"    return 0;\n" + 
+		"  }\n" + 
+		"  public int[] @NonEmpty [][] bar() {\n" + 
+		"    return 0;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0046", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0047() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker String[]  foo() @NonEmpty[][] { return null; }\n" +
+					"    public String[] @NonEmpty[][] bar() { return null; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker String[] @NonEmpty [][] foo() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public String[] @NonEmpty [][] bar() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0047", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0048() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker HashMap<@Positive Integer, @Negative Integer>[] foo() @NonEmpty[][] { return null; }\n" +
+					"    public HashMap<@Positive Integer, @Negative Integer> [] @NonEmpty[][] bar() { return null; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker HashMap<@Positive Integer, @Negative Integer> @NonEmpty [][][] foo() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public HashMap<@Positive Integer, @Negative Integer>[] @NonEmpty [][] bar() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0048", expectedUnitToString);
+}
+//Type0 MethodHeaderName.
+public void test0049() throws IOException {
+	String source = "public class A {\n" +
+					"    public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[]  foo() @NonEmpty[][] { return null; }\n" +
+					"    public HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty[][] bar() { return null; }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator @NonEmpty [][][] foo() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty [][] bar() {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0049", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0050() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker int p;\n" +
+					"        int q;\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker int p;\n" + 
+		"    int q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0050", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0051() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker String p;\n" +
+					"        String q;\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker String p;\n" + 
+		"    String q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0051", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0052() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker HashMap<@Positive Integer, @Negative Integer> p;\n" +
+					"        HashMap<@Positive Integer, @Negative Integer> q;\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker HashMap<@Positive Integer, @Negative Integer> p;\n" + 
+		"    HashMap<@Positive Integer, @Negative Integer> q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0052", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0053() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator p;\n" +
+					"        HashMap<@Positive Integer, @Negative Integer>.Iterator q;\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator p;\n" + 
+		"    HashMap<@Positive Integer, @Negative Integer>.Iterator q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0053", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0054() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker int[] @NonNull[] p @NonEmpty[][];\n" +
+					"        int[] @NonNull[] q @NonEmpty[][];\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker int[] @NonNull [] @NonEmpty [][] p;\n" + 
+		"    int[] @NonNull [] @NonEmpty [][] q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0054", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0055() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker String[] @NonNull[] p @NonEmpty[][];\n" +
+					"        String[] @NonNull[] q @NonEmpty[][];\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker String[] @NonNull [] @NonEmpty [][] p;\n" + 
+		"    String[] @NonNull [] @NonEmpty [][] q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0055", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0056() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker HashMap<@Positive Integer, @Negative Integer>[] @NonNull[] p @NonEmpty[][];\n" +
+					"        HashMap<@Positive Integer, @Negative Integer>[] @NonNull[] q @NonEmpty[][];\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker HashMap<@Positive Integer, @Negative Integer> @NonEmpty [][][] @NonNull [] p;\n" + 
+		"    HashMap<@Positive Integer, @Negative Integer> @NonEmpty [][][] @NonNull [] q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0056", expectedUnitToString);
+}
+//Type0 local variable declaration
+public void test0057() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonNull[] p @NonEmpty[][];\n" +
+					"        HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonNull[] @NonEmpty[][] q;\n" + 
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    @Marker HashMap<@Positive Integer, @Negative Integer>.Iterator @NonEmpty [][][] @NonNull [] p;\n" + 
+		"    HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonNull [] @NonEmpty [][] q;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0057", expectedUnitToString);
+}
+//Type0 foreach
+public void test0058() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        String @NonNull[] @Marker[] s @Readonly[];\n" +
+					"    	 for (@Readonly String @NonNull[] si @Marker[] : s) {}\n" +
+					"    	 for (String @NonNull[] sii @Marker[] : s) {}\n" +
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    String @NonNull [] @Marker [] @Readonly [] s;\n" + 
+		"    for (@Readonly String @NonNull [] @Marker [] si : s) \n" + 
+		"      {\n" + 
+		"      }\n" + 
+		"    for (String @NonNull [] @Marker [] sii : s) \n" + 
+		"      {\n" + 
+		"      }\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0058", expectedUnitToString);
+}
+//Type0 foreach
+public void test0059() throws IOException {
+	String source = "public class A {\n" +
+					"    public void foo() {\n" +
+					"        int @NonNull[] @Marker[] s @Readonly[];\n" +
+					"    	 for (@Readonly int @NonNull[] si @Marker[] : s) {}\n" +
+					"    	 for (int @NonNull[] sii @Marker[] : s) {}\n" +
+					"    }\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class A {\n" + 
+		"  public A() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo() {\n" + 
+		"    int @NonNull [] @Marker [] @Readonly [] s;\n" + 
+		"    for (@Readonly int @NonNull [] @Marker [] si : s) \n" + 
+		"      {\n" + 
+		"      }\n" + 
+		"    for (int @NonNull [] @Marker [] sii : s) \n" + 
+		"      {\n" + 
+		"      }\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0059", expectedUnitToString);
+}
+// cast expression
+public void test0060() throws IOException {
+	String source = "public class Clazz {\n" +
+					"public static void main(String[] args) {\n" +
+					"int x;\n" +
+					"x = (Integer)\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Normal(Value=0)[][] )\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @SingleMember(0)[][] )\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Marker[][] )\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Normal(Value=0)[][] )\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>[] @SingleMember(0)[][] )\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Marker[][] )\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly String[] @Normal(Value=0)[][] )\n" +
+					"(@Readonly String[] @SingleMember(0)[][] )\n" +
+					"(@Readonly String[] @Marker[][] )\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly int[] @Normal(Value=0)[][] )\n" +
+					"(@Readonly int[] @SingleMember(0)[][] )\n" +
+					"(@Readonly int[] @Marker[][] )\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator)\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly HashMap<@Positive Integer, @Negative Integer>)\n" +
+					"(@Readonly Object)\n" +
+					"(@ReadOnly String)\n" +
+					"(@Readonly Object)\n" +
+					"(@Readonly int) 10;\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class Clazz {\n" + 
+		"  public Clazz() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    int x;\n" + 
+		"    x = (Integer) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Normal(Value = 0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @SingleMember(0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @Marker [][]) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Normal(Value = 0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>[] @SingleMember(0) [][]) (@Readonly HashMap<@Positive Integer, @Negative Integer>[] @Marker [][]) (@Readonly Object) (@Readonly String[] @Normal(Value = 0) [][]) (@Readonly String[] @SingleMember(0) [][]) (@Readonly String[] @Marker [][]) (@Readonly Object) (@Readonly int[] @Normal(Value = 0) [][]) (@Readonly int[] @SingleMember(0) [][]) (@Readonly int[] @Marker [][]) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator) (@Readonly Object) (@Readonly HashMap<@Positive Integer, @Negative Integer>) (@Readonly Object) (@ReadOnly String) (@Readonly Object) (@Readonly int) 10;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0060", expectedUnitToString);
+}
+//cast expression
+public void test0061() throws IOException {
+	String source = "public class Clazz {\n" +
+					"public static void main(String[] args) {\n" +
+					"int x;\n" +
+					"x = (Integer)\n" +
+					"(Object)\n" +
+					"(@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Normal(Value=0)[][] )\n" +
+					"(HashMap<@Positive Integer, Integer>.Iterator[] @SingleMember(0)[][] )\n" +
+					"(@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Marker[][] )\n" +
+					"(Object)\n" +
+					"(@Readonly HashMap<@Positive Integer, Integer>[] @Normal(Value=0)[][] )\n" +
+					"(HashMap<Integer, @Negative Integer>[] @SingleMember(0)[][] )\n" +
+					"(@Readonly HashMap<@Positive Integer, Integer>[] @Marker[][] )\n" +
+					"(Object)\n" +
+					"(@Readonly String[] @Normal(Value=0)[][] )\n" +
+					"(String[] @SingleMember(0)[][] )\n" +
+					"(@Readonly String[] @Marker[][] )\n" +
+					"(Object)\n" +
+					"(@Readonly int[] @Normal(Value=0)[][] )\n" +
+					"(int[] @SingleMember(0)[][] )\n" +
+					"(@Readonly int[] @Marker[][] )\n" +
+					"(Object)\n" +
+					"(@Readonly HashMap<Integer, @Negative Integer>.Iterator)\n" +
+					"(Object)\n" +
+					"(@Readonly HashMap<@Positive Integer, Integer>)\n" +
+					"(Object)\n" +
+					"(@ReadOnly String)\n" +
+					"(Object)\n" +
+					"(@Readonly int) 10;\n" +
+					"}\n" +
+					"}\n";
+	String expectedUnitToString = 
+		"public class Clazz {\n" + 
+		"  public Clazz() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    int x;\n" + 
+		"    x = (Integer) (Object) (@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Normal(Value = 0) [][]) (HashMap<@Positive Integer, Integer>.Iterator[] @SingleMember(0) [][]) (@Readonly HashMap<Integer, @Negative Integer>.Iterator[] @Marker [][]) (Object) (@Readonly HashMap<@Positive Integer, Integer>[] @Normal(Value = 0) [][]) (HashMap<Integer, @Negative Integer>[] @SingleMember(0) [][]) (@Readonly HashMap<@Positive Integer, Integer>[] @Marker [][]) (Object) (@Readonly String[] @Normal(Value = 0) [][]) (String[] @SingleMember(0) [][]) (@Readonly String[] @Marker [][]) (Object) (@Readonly int[] @Normal(Value = 0) [][]) (int[] @SingleMember(0) [][]) (@Readonly int[] @Marker [][]) (Object) (@Readonly HashMap<Integer, @Negative Integer>.Iterator) (Object) (@Readonly HashMap<@Positive Integer, Integer>) (Object) (@ReadOnly String) (Object) (@Readonly int) 10;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0061", expectedUnitToString);
+}
+// instanceof checks 
+public void test0062() throws IOException {
+	String source = "public class Clazz {\n" +
+					"public static void main(Object o) {\n" +
+					"if (o instanceof @Readonly String) {\n" +
+					"} else if (o instanceof @Readonly int[] @NonEmpty[][] ) {\n" +
+					"} else if (o instanceof @Readonly String[] @NonEmpty[][] ) {\n" +
+					"} else if (o instanceof @Readonly HashMap<?,?>[] @NonEmpty[][] ) {\n" +
+					"} else if (o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty[][] ) {\n" +	
+					"} else if (o instanceof @Readonly HashMap<?,?>) {\n" +
+					"} else if (o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator) {\n" +
+					"}\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class Clazz {\n" + 
+		"  public Clazz() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(Object o) {\n" + 
+		"    if ((o instanceof @Readonly String))\n" + 
+		"        {\n" + 
+		"        }\n" + 
+		"    else\n" + 
+		"        if ((o instanceof @Readonly int[] @NonEmpty [][]))\n" + 
+		"            {\n" + 
+		"            }\n" + 
+		"        else\n" + 
+		"            if ((o instanceof @Readonly String[] @NonEmpty [][]))\n" + 
+		"                {\n" + 
+		"                }\n" + 
+		"            else\n" + 
+		"                if ((o instanceof @Readonly HashMap<?, ?>[] @NonEmpty [][]))\n" + 
+		"                    {\n" + 
+		"                    }\n" + 
+		"                else\n" + 
+		"                    if ((o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator[] @NonEmpty [][]))\n" + 
+		"                        {\n" + 
+		"                        }\n" + 
+		"                    else\n" + 
+		"                        if ((o instanceof @Readonly HashMap<?, ?>))\n" + 
+		"                            {\n" + 
+		"                            }\n" + 
+		"                        else\n" + 
+		"                            if ((o instanceof @Readonly HashMap<@Positive Integer, @Negative Integer>.Iterator))\n" + 
+		"                                {\n" + 
+		"                                }\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0062", expectedUnitToString);
+}
+// assorted unclassified 
+public void test0063() throws IOException {
+	String source = "import java.util.HashMap;\n" +
+					"import java.util.Map; \n" +  
+					"\n" +
+					"public class Clazz <@A M extends @B String, @C N extends @D Comparable> extends\n" +
+					"								@E Object implements @F Comparable <@G Object> {\n" +
+					"	\n" +
+					"  Clazz(char[] ...args) { \n" +   
+					"   }\n" +
+					"   \n" +
+					"  int @I[] f @J[], g, h[], i@K[];\n" +
+					"  int @L[][]@M[] f2; \n" +
+					"   \n" +
+					"  Clazz (int @N[] @O... a) {}\n" +
+					" int @R[]@S[] aa() {}\n" +
+					" \n" +
+					" int @T[]@U[]@V[] a () @W[]@X[]@Y[] { return null; }\n" +
+					"   \n" +
+					"  public void main(String @A[] @B ... args) throws @D Exception {\n" +
+					"  	\n" +
+					"       HashMap<@E String, @F String> b1;\n" +
+					"      \n" +
+					"     int b; b = (@G int) 10;\n" +
+					"      \n" +
+					"     char @H[]@I[] ch; ch = (@K char @L[]@M[])(@N char @O[]@P[]) null;\n" +
+					"      \n" +
+					"      int[] i; i = new @Q int @R[10];\n" +
+					"       \n" +
+					"      \n" +
+					"   Integer w; w = new X<@S String, @T Integer>().get(new @U Integer(12));\n" +
+					"    throw new @V Exception(\"test\");\n" +
+					"    boolean c; c  = null instanceof @W String;\n" +
+					"	} \n" +
+					" public <@X X, @Y Y> void foo(X x, Y @Z... y) {  \n" +
+					"	\n" +
+					"}\n" +
+					" \n" +
+					" void foo(Map<? super @A Object, ? extends @B String> m){}\n" +
+					" public int compareTo(Object arg0) {\n" +
+					"     return 0;\n" +
+					" }\n" +
+					"\n" +
+					"}\n" +
+					"class X<@C K, @D T extends @E Object & @F Comparable<? super @G T>> {\n" +
+					"	\n" +
+					"  public Integer get(Integer integer) {\n" +
+					"       return null;\n" +
+					"   }\n" +
+					"}\n";
+					
+					
+	String expectedUnitToString = "import java.util.HashMap;\n" + 
+								  "import java.util.Map;\n" + 
+								  "public class Clazz<@A M extends @B String, @C N extends @D Comparable> extends @E Object implements @F Comparable<@G Object> {\n" + 
+								  "  int @I [] @J [] f;\n" + 
+								  "  int @I [] g;\n" + 
+								  "  int @I [][] h;\n" + 
+								  "  int @I [] @K [] i;\n" + 
+								  "  int @L [][] @M [] f2;\n" + 
+								  "  Clazz(char[]... args) {\n" + 
+								  "    super();\n" + 
+								  "  }\n" + 
+								  "  Clazz(int @N [] @O ... a) {\n" + 
+								  "    super();\n" + 
+								  "  }\n" + 
+								  "  int @R [] @S [] aa() {\n" + 
+								  "  }\n" + 
+								  "  int @T [] @U [] @V [] @W [] @X [] @Y [] a() {\n" + 
+								  "    return null;\n" + 
+								  "  }\n" + 
+								  "  public void main(String @A [] @B ... args) throws @D Exception {\n" + 
+								  "    HashMap<@E String, @F String> b1;\n" + 
+								  "    int b;\n" +
+								  "    b = (@G int) 10;\n" + 
+								  "    char @H [] @I [] ch;\n" +
+								  "    ch = (@K char @L [] @M []) (@N char @O [] @P []) null;\n" + 
+								  "    int[] i;\n" +
+								  "    i = new @Q int @R [10];\n" + 
+								  "    Integer w;\n" +
+								  "    w = new X<@S String, @T Integer>().get(new @U Integer(12));\n" + 
+								  "    throw new @V Exception(\"test\");\n" + 
+								  "    boolean c;\n" +
+								  "    c = (null instanceof @W String);\n" + 
+								  "  }\n" + 
+								  "  public <@X X, @Y Y>void foo(X x, Y @Z ... y) {\n" + 
+								  "  }\n" + 
+								  "  void foo(Map<? super @A Object, ? extends @B String> m) {\n" + 
+								  "  }\n" + 
+								  "  public int compareTo(Object arg0) {\n" + 
+								  "    return 0;\n" + 
+								  "  }\n" + 
+								  "}\n" + 
+								  "class X<@C K, @D T extends @E Object & @F Comparable<? super @G T>> {\n" + 
+								  "  X() {\n" + 
+								  "    super();\n" + 
+								  "  }\n" + 
+								  "  public Integer get(Integer integer) {\n" + 
+								  "    return null;\n" + 
+								  "  }\n" + 
+								  "}\n";
+	// indexing parser avoids creating lots of nodes, so parse tree comes out incorrectly.
+	// this is not bug, but intended behavior - see IndexingParser.newSingleNameReference(char[], long)
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0063", expectedUnitToString);
+}
+//assorted unclassified 
+public void test0064() throws IOException {
+	String source = "class X<T extends @E Object & @F Comparable<? super T>> {}\n";
+	String expectedUnitToString = "class X<T extends @E Object & @F Comparable<? super T>> {\n" + 
+								  "  X() {\n" + 
+								  "    super();\n" + 
+								  "  }\n" + 
+								  "}\n";
+	// indexing parser avoids creating lots of nodes, so parse tree comes out incorrectly.
+	// this is not bug, but intended behavior - see IndexingParser.newSingleNameReference(char[], long)
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test064", expectedUnitToString);
+}
+//type class literal expression
+public void test0066() throws IOException {
+	String source = "public class X {\n" + 
+			"	<T extends Y<@A String @C[][]@B[]> & Cloneable> void foo(T t) {}\n" + 
+			"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  <T extends Y<@A String @C [][] @B []> & Cloneable>void foo(T t) {\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0066", expectedUnitToString);
+}
+//check locations
+public void test0067() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @H String @E [] @F [] @G [] field;\n" + 
+		"  @A Map<@B String, @C List<@D Object>> field2;\n" + 
+		"  @A Map<@B String, @H String @E [] @F [] @G []> field3;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0067", expectedUnitToString);
+}
+//check locations
+public void test0068() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @H String @E [] @F [] @G [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0068", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 4, locations.size());
+	assertEquals("Wrong location", null, locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+}
+//check locations
+public void test0069() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B String, @H String> field3;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B String, @H String> field3;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0069", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 3, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@H"));
+}
+//check locations
+public void test0070() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B String, @H String @E [] @F [] @G []> field3;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0070", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 6, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+}
+//check locations
+public void test0071() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B String, @C List<@H String @E[][] @G[]>> field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B String, @C List<@H String @E [][] @G []>> field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0071", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 6, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+}
+//check locations
+public void test0072() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B String, @C List<@H String @E[][] @G[]>>[] @I[] @J[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B String, @C List<@H String @E [][] @G []>>[] @I [] @J [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0072", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 8, locations.size());
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@I"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+}
+//check locations
+public void test0073() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B String, @C List<@H String @E[][] @G[]>> @I[][] @J[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B String, @C List<@H String @E [][] @G []>> @I [][] @J [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0073", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 8, locations.size());
+	assertEquals("Wrong location", null, locations.get("@I"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+}
+//check locations
+public void test0074() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@C List<@H String @E[][] @G[]>, String @B[] @D[]> @I[] @F[] @J[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@C List<@H String @E [][] @G []>, String @B [] @D []> @I [] @F [] @J [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0074", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 10, locations.size());
+	assertEquals("Wrong location", null, locations.get("@I"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), ARRAY]", locations.get("@D"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@B"));
+}
+//check locations
+public void test0075() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@C List<@H String @E[][] @G[]>, @B List<String [] @D[]>> [] @I[] @F[] @J[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@C List<@H String @E [][] @G []>, @B List<String[] @D []>>[] @I [] @F [] @J [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0075", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 10, locations.size());
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@I"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@J"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY]", locations.get("@A"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0)]", locations.get("@C"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1)]", locations.get("@B"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY, ARRAY, TYPE_ARGUMENT(1), TYPE_ARGUMENT(0), ARRAY]", locations.get("@D"));
+}
+//check locations
+public void test0076() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B String, @C List<@D Object>> field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B String, @C List<@D Object>> field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0076", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 4, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@D"));
+}
+//check locations
+public void test0077() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @H String @E [] @F [] @G [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0077", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 4, locations.size());
+	assertEquals("Wrong location", null, locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+}
+//check locations
+public void test0078() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B Comparable<@C Object @D[] @E[] @F[]>, @G List<@H Document>> field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B Comparable<@C Object @D [] @E [] @F []>, @G List<@H Document>> field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0078", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 8, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@D"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@H"));
+}
+//check locations
+public void test0079() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A java.util.Map<@B Comparable<@C Object @D[] @E[] @F[]>, @G List<@H Document>> field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A java.util.Map<@B Comparable<@C Object @D [] @E [] @F []>, @G List<@H Document>> field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0079", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 8, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY, ARRAY]", locations.get("@C"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0)]", locations.get("@D"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0), TYPE_ARGUMENT(0), ARRAY, ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), TYPE_ARGUMENT(0)]", locations.get("@H"));
+}
+//check locations
+public void test0080() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@B Map<? extends Z, ? extends @A Z> field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @B Map<? extends Z, ? extends @A Z> field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0080", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 2, locations.size());
+	assertEquals("Wrong location", null, locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), WILDCARD]", locations.get("@A"));
+}
+//check locations
+public void test0081() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @H java.lang.String @E [] @F [] @G [] field;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0081", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 4, locations.size());
+	assertEquals("Wrong location", null, locations.get("@E"));
+	assertEquals("Wrong location", "[ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+}
+//check locations
+public void test0082() throws IOException {
+	String source = 
+		"public class X {\n" + 
+		"	@A Map<@B java.lang.String, @H java.lang.String @E[] @F[] @G[]> field3;\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  @A Map<@B java.lang.String, @H java.lang.String @E [] @F [] @G []> field3;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	LocationPrinterVisitor visitor = new LocationPrinterVisitor();
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0082", expectedUnitToString, visitor);
+	Map locations = visitor.getLocations();
+	assertEquals("Wrong size", 6, locations.size());
+	assertEquals("Wrong location", null, locations.get("@A"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(0)]", locations.get("@B"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1)]", locations.get("@E"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY]", locations.get("@F"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY]", locations.get("@G"));
+	assertEquals("Wrong location", "[TYPE_ARGUMENT(1), ARRAY, ARRAY, ARRAY]", locations.get("@H"));
+}
+public void test0083() throws IOException {
+	String source =
+		"@Marker class A {}\n;" +
+		"@Marker class B extends @Marker A {}\n" +
+		"@Marker class C extends @Marker @SingleMember(0) A {}\n" +
+		"@Marker class D extends @Marker @SingleMember(0) @Normal(value = 0) A {}\n" +
+		"@Marker class E extends B {}\n;";
+
+	String expectedUnitToString =
+		"@Marker class A {\n" +
+		"  A() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class B extends @Marker A {\n" +
+		"  B() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class C extends @Marker @SingleMember(0) A {\n" +
+		"  C() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class D extends @Marker @SingleMember(0) @Normal(value = 0) A {\n" +
+		"  D() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class E extends B {\n" +
+		"  E() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0083", expectedUnitToString);
+}
+
+// To test Parser.consumeAdditionalBound() with Type annotations
+public void test0084() throws IOException {
+	String source =
+		"@Marker interface I<@Negative T> {}\n" +
+		"@SingleMember(0) interface J<@Positive T> {}\n" +
+		"@Marker class A implements I<@SingleMember(0) A>, J<@Marker A> {}\n" +
+		"@Normal(value = 1) class X<E extends @Positive A & @Marker I<A> & @Marker @SingleMember(1) J<@Readonly A>>  {\n" +
+		"}";
+	String expectedUnitToString =
+		"@Marker interface I<@Negative T> {\n" +
+		"}\n" +
+		"@SingleMember(0) interface J<@Positive T> {\n" +
+		"}\n" +
+		"@Marker class A implements I<@SingleMember(0) A>, J<@Marker A> {\n" +
+		"  A() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Normal(value = 1) class X<E extends @Positive A & @Marker I<A> & @Marker @SingleMember(1) J<@Readonly A>> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0084", expectedUnitToString );
+}
+
+// To test Parser.consumeAdditionalBound() with Type annotations
+public void test0085() throws IOException {
+	String source =
+		"import java.io.Serializable;\n" +
+		"\n" +
+		"@SingleMember(10) class X<T extends @Marker Serializable & @Normal(value = 10) Runnable, V extends @Marker T> {\n" +
+		"	@Negative T t;\n" +
+		"	@Marker X(@Readonly T t) {\n" +
+		"		this.t = t;\n" +
+		"	}\n" +
+		"	void foo(@Marker X this) {\n" +
+		"		(this == null ? t : t).run();\n" +
+		"		((@Marker V) t).run();\n" +
+		"	}\n" +
+		"	public static void main(@Readonly String @Marker [] args) {\n" +
+		"		new @Marker  X<@Marker A, @Negative A>(new @Marker A()).foo();\n" +
+		"	}\n" +
+		"}\n" +
+		"@Marker class A implements @Marker Serializable, @SingleMember(1) Runnable {\n" +
+		"	public void run() {\n" +
+		"		System.out.print(\"AA\");\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"import java.io.Serializable;\n" +
+		"@SingleMember(10) class X<T extends @Marker Serializable & @Normal(value = 10) Runnable, V extends @Marker T> {\n" +
+		"  @Negative T t;\n" +
+		"  @Marker X(@Readonly T t) {\n" +
+		"    super();\n" +
+		"    this.t = t;\n" +
+		"  }\n" +
+		"  void foo(@Marker X this) {\n" +
+		"    ((this == null) ? t : t).run();\n" +
+		"    ((@Marker V) t).run();\n" +
+		"  }\n" +
+		"  public static void main(@Readonly String @Marker [] args) {\n" +
+		"    new @Marker X<@Marker A, @Negative A>(new @Marker A()).foo();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class A implements @Marker Serializable, @SingleMember(1) Runnable {\n" +
+		"  A() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void run() {\n" +
+		"    System.out.print(\"AA\");\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0085", expectedUnitToString );
+}
+
+// To test Parser.classInstanceCreation() with type annotations
+public void test0086() throws IOException {
+	String source =
+		"class X {\n" +
+		"	@Marker X() {\n" +
+		"		System.out.print(\"new X created\");\n" +
+		"	}\n" +
+		"  	void f() throws @Marker InstantiationException {\n" +
+		"       X testX;\n" +
+		"		testX = new @Readonly @Negative X();\n" +
+		"		Double d;\n" +
+		"		d = new @Marker @Positive Double(1.1);\n" +
+		"     	throw new @Positive @Normal(value = 10) InstantiationException(\"test\");\n" +
+		"   }\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  @Marker X() {\n" +
+		"    super();\n" +
+		"    System.out.print(\"new X created\");\n" +
+		"  }\n" +
+		"  void f() throws @Marker InstantiationException {\n" +
+		"    X testX;\n" +
+		"    testX = new @Readonly @Negative X();\n" +
+		"    Double d;\n" +
+		"    d = new @Marker @Positive Double(1.1);\n" +
+		"    throw new @Positive @Normal(value = 10) InstantiationException(\"test\");\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0086", expectedUnitToString );
+}
+
+// To test Parser.classInstanceCreation() with type annotations
+public void test0087() throws IOException {
+	String source =
+		"class X {\n" +
+		"	@Marker X() {\n" +
+		"		System.out.print(\"new X created\");\n" +
+		"	}\n" +
+		"	@Marker class Inner {\n" +
+		"		@Normal(value = 10) Inner(){\n" +
+		"			System.out.print(\"X.Inner created\");\n" +
+		"		}\n" +
+		"	}\n" +
+		"	public String getString(){\n" +
+		"		return \"hello\";\n" +
+		"	}\n" +
+		"  	void f(@Marker X this) {\n" +
+		"       String testString;\n" +
+		"		testString = new @Readonly @Negative X().getString();\n" +
+		"		X.Inner testInner;\n" +
+		"		testInner = new @Readonly X.Inner();\n" +
+		"		int i;\n" +
+		"		for(i = 0; i < 10; i++)\n" +
+		"			System.out.print(\"test\");\n" +
+		"   }\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  @Marker class Inner {\n" +
+		"    @Normal(value = 10) Inner() {\n" +
+		"      super();\n" +
+		"      System.out.print(\"X.Inner created\");\n" +
+		"    }\n" +
+		"  }\n" +
+		"  @Marker X() {\n" +
+		"    super();\n" +
+		"    System.out.print(\"new X created\");\n" +
+		"  }\n" +
+		"  public String getString() {\n" +
+		"    return \"hello\";\n" +
+		"  }\n" +
+		"  void f(@Marker X this) {\n" +
+		"    String testString;\n" +
+		"    testString = new @Readonly @Negative X().getString();\n" +
+		"    X.Inner testInner;\n" +
+		"    testInner = new @Readonly X.Inner();\n" +
+		"    int i;\n" +
+		"    for (i = 0; (i < 10); i ++) \n" +
+		"      System.out.print(\"test\");\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0087", expectedUnitToString );
+}
+
+// To test Parser.classInstanceCreation() with type annotations
+public void test0088() throws IOException {
+	String source =
+		"import java.io.Serializable;\n" +
+		"class X {\n" +
+		"	public static void main(String[] args) {\n" +
+		"		new @Marker Serializable() {\n" +
+		"		};\n" +
+		"		new @Positive @Marker Serializable() {\n" +
+		"			public long serialVersion;\n" +
+		"		};\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.io.Serializable;\n" +
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    new @Marker Serializable() {\n" +
+		"    };\n" +
+		"    new @Positive @Marker Serializable() {\n" +
+		"      public long serialVersion;\n" +
+		"    };\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0088", expectedUnitToString );
+}
+
+// To test Parser.classInstanceCreation() with type annotations
+public void test0089() throws IOException {
+	String source =
+		"import java.io.Serializable;\n" +
+		"class X<T>{\n" +
+		"	public void f() {\n" +
+		"		X testX;\n" +
+		"		testX = new @Marker @SingleMember(10) X<@Negative Integer>();\n" +
+		"		System.out.print(\"object created\");\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.io.Serializable;\n" +
+		"class X<T> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void f() {\n" +
+		"    X testX;\n" +
+		"    testX = new @Marker @SingleMember(10) X<@Negative Integer>();\n" +
+		"    System.out.print(\"object created\");\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0089", expectedUnitToString );
+}
+
+// To test Parser.classInstanceCreation() with type annotations
+public void test0090() throws IOException {
+	String source =
+		"class X <@Marker T extends @Readonly String> {\n" +
+		"    T foo(T t) {\n" +
+		"        return t;\n" +
+		"    }\n" +
+		"    public static void main(String[] args) {\n" +
+		"        new @Readonly X<String>().baz(\"SUCCESS\");\n" +	// Parser.classInstanceCreation called
+		"    }\n" +
+		"    void baz(final T t) {\n" +
+		"        new @Readonly @Marker Object() {\n" +	// Parser.classInstanceCreation called
+		"            void print() {\n" +
+		"            }\n" +
+		"        }.print();\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<@Marker T extends @Readonly String> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  T foo(T t) {\n" +
+		"    return t;\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    new @Readonly X<String>().baz(\"SUCCESS\");\n" +
+		"  }\n" +
+		"  void baz(final T t) {\n" +
+		"    new @Readonly @Marker Object() {\n" +
+		"  void print() {\n" +
+		"  }\n" +
+		"}.print();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0090", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
+public void test0091() throws IOException {
+	String source =
+		"class X <@Marker T extends @Readonly String> {\n" +
+		"    public static void main(String[] args) {\n" +
+		"		int [] x1;\n" +
+		"		x1 = new int @Marker @SingleMember(2) [] {-1, -2};\n" +
+		"       Integer [][] x2;\n" +
+		"		x2 = new @Positive Integer @Marker @SingleMember(3) [] @SingleMember(3) [] {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<@Marker T extends @Readonly String> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    int[] x1;\n" +
+		"    x1 = new int @Marker @SingleMember(2) []{(- 1), (- 2)};\n" +
+		"    Integer[][] x2;\n" +
+		"    x2 = new @Positive Integer @Marker @SingleMember(3) [] @SingleMember(3) []{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0091", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
+public void test0092() throws IOException {
+	String source =
+		"class X {\n" +
+		"	static class T {\n" +
+		"		public @Readonly Object @Normal(value = 10) [] f() {\n" +
+		"			return new @Readonly Object @Normal(value = 10) [] {this, T.this};\n" +
+		"		}\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  static class T {\n" +
+		"    T() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"    public @Readonly Object @Normal(value = 10) [] f() {\n" +
+		"      return new @Readonly Object @Normal(value = 10) []{this, T.this};\n" +
+		"    }\n" +
+		"  }\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0092", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
+public void test0093() throws IOException {
+	String source =
+		"class X {\n" +
+		"    public static void main(String[] args) {\n" +
+		"        java.util.Arrays.asList(new @Readonly Object @SingleMember(1) [] {\"1\"});\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    java.util.Arrays.asList(new @Readonly Object @SingleMember(1) []{\"1\"});\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0093", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
+public void test0094() throws IOException {
+	String source =
+		"class X {\n" +
+		"	public boolean test() {\n" +
+		"		String[] s;\n" +
+		"		s = foo(new @Marker String @SingleMember(1) []{\"hello\"});\n" +
+		"		return s != null;\n" +
+		"	}\n" +
+		"	public <@Marker F> F @SingleMember(1) [] foo(F[] f) {\n" +
+		"		return f;\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public boolean test() {\n" +
+		"    String[] s;\n" +
+		"    s = foo(new @Marker String @SingleMember(1) []{\"hello\"});\n" +
+		"    return (s != null);\n" +
+		"  }\n" +
+		"  public <@Marker F>F @SingleMember(1) [] foo(F[] f) {\n" +
+		"    return f;\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0094", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithInitializer() with Type Annotations
+public void test0095() throws IOException {
+	String source =
+		"import java.util.Arrays;\n" +
+		"import java.util.List;\n" +
+		"@Marker class Deejay {\n" +
+		"	@Marker class Counter<@Marker T> {}\n" +
+		"	public void f(String[] args) {\n" +
+		"		Counter<@Positive Integer> songCounter;\n" +
+		"		songCounter = new Counter<@Positive Integer>();\n" +
+		"		Counter<@Readonly String> genre;\n" +
+		"		genre = new Counter<@Readonly String>();\n" +
+		"		List<@Marker Counter<?>> list1;\n" +
+		"		list1 = Arrays.asList(new @Marker Counter<?> @Normal(value = 2) @Marker [] {songCounter, genre});\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"import java.util.Arrays;\n" +
+		"import java.util.List;\n" +
+		"@Marker class Deejay {\n" +
+		"  @Marker class Counter<@Marker T> {\n" +
+		"    Counter() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"  }\n" +
+		"  Deejay() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void f(String[] args) {\n" +
+		"    Counter<@Positive Integer> songCounter;\n" +
+		"    songCounter = new Counter<@Positive Integer>();\n" +
+		"    Counter<@Readonly String> genre;\n" +
+		"    genre = new Counter<@Readonly String>();\n" +
+		"    List<@Marker Counter<?>> list1;\n" +
+		"    list1 = Arrays.asList(new @Marker Counter<?> @Normal(value = 2) @Marker []{songCounter, genre});\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0095", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
+public void test0096() throws IOException {
+	String source =
+		"class X <@Marker T extends @Readonly String> {\n" +
+		"    public static void main(String[] args) {\n" +
+		"		int [] x1;\n" +
+		"		x1 = new int @Marker @SingleMember(10) [10];\n" +
+		"       Integer [][] x2;\n" +
+		"		x2 = new @Positive Integer @Marker [10] @Normal(value = 10) [10];\n" +
+		"		char[][] tokens;\n" +
+		"		tokens = new char @SingleMember(0) [0] @Normal(value = 10) @Marker [];\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<@Marker T extends @Readonly String> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    int[] x1;\n" +
+		"    x1 = new int @Marker @SingleMember(10) [10];\n" +
+		"    Integer[][] x2;\n" +
+		"    x2 = new @Positive Integer @Marker [10] @Normal(value = 10) [10];\n" +
+		"    char[][] tokens;\n" +
+		"    tokens = new char @SingleMember(0) [0] @Normal(value = 10) @Marker [];\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0096", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
+public void test0097() throws IOException {
+	String source =
+		"class X {\n" +
+		"	public @Readonly Object @Normal(value = 10) [] f(@Marker X this) {\n" +
+		"		return new @Readonly Object @Normal(value = 10) [10];\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public @Readonly Object @Normal(value = 10) [] f(@Marker X this) {\n" +
+		"    return new @Readonly Object @Normal(value = 10) [10];\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0097", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
+public void test0098() throws IOException {
+	String source =
+		"class X {\n" +
+		"	public boolean test() {\n" +
+		"		String[] s;\n" +
+		"		s = foo(new @Marker String @SingleMember(1) [10]);\n" +
+		"		return s != null;\n" +
+		"	}\n" +
+		"	public <@Marker F> F @SingleMember(1) [] foo(F[] f) {\n" +
+		"		return f;\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public boolean test() {\n" +
+		"    String[] s;\n" +
+		"    s = foo(new @Marker String @SingleMember(1) [10]);\n" +
+		"    return (s != null);\n" +
+		"  }\n" +
+		"  public <@Marker F>F @SingleMember(1) [] foo(F[] f) {\n" +
+		"    return f;\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0098", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
+public void test0099() throws IOException {
+	String source =
+		"import java.util.Arrays;\n" +
+		"import java.util.List;\n" +
+		"class X<@Marker T> {\n" +
+		"	public void test() {\n" +
+		"		List<@Marker X<?>> a;\n" +
+		"		a = Arrays.asList(new @Marker X<?> @SingleMember(0) [0]);\n" +
+		"		String @Marker [] @SingleMember(1) [] x;\n" +
+		"		x = new @Readonly String @Normal(value = 5) [5] @SingleMember(1) [1];\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.util.Arrays;\n" +
+		"import java.util.List;\n" +
+		"class X<@Marker T> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void test() {\n" +
+		"    List<@Marker X<?>> a;\n" +
+		"    a = Arrays.asList(new @Marker X<?> @SingleMember(0) [0]);\n" +
+		"    String @Marker [] @SingleMember(1) [] x;\n" +
+		"    x = new @Readonly String @Normal(value = 5) [5] @SingleMember(1) [1];\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0099", expectedUnitToString );
+}
+
+// To test Parser.consumeArrayCreationExpressionWithoutInitializer() with Type Annotations
+public void test0100() throws IOException {
+	String source =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"    public Integer[] getTypes() {\n" +
+		"        List<@Positive Integer> list;\n" +
+		"		 list = new ArrayList<@Positive Integer>();\n" +
+		"        return list == null \n" +
+		"            ? new @Positive Integer @SingleMember(0) [0] \n" +
+		"            : list.toArray(new @Positive Integer @Marker [list.size()]);\n" +
+		"    }\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public Integer[] getTypes() {\n" +
+		"    List<@Positive Integer> list;\n" +
+		"    list = new ArrayList<@Positive Integer>();\n" +
+		"    return ((list == null) ? new @Positive Integer @SingleMember(0) [0] : list.toArray(new @Positive Integer @Marker [list.size()]));\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0100", expectedUnitToString );
+}
+
+// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
+public void test0101() throws IOException {
+	String source =
+		"import java.util.*;\n" +
+		"\n" +
+		"@Marker class X {\n" +
+		"    Vector<Object> data;\n" +
+		"    public void t() {\n" +
+		"        Vector<@Readonly Object> v;\n" +
+		" 		 v = (@Marker @SingleMember(0) Vector<@Readonly Object>) data.elementAt(0);\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"import java.util.*;\n" +
+		"@Marker class X {\n" +
+		"  Vector<Object> data;\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void t() {\n" +
+		"    Vector<@Readonly Object> v;\n" +
+		"    v = (@Marker @SingleMember(0) Vector<@Readonly Object>) data.elementAt(0);\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0101", expectedUnitToString );
+}
+
+// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
+// To test Parser.consumeClassHeaderExtends() with Type Annotations
+public void test0102() throws IOException {
+	String source =
+		"class X<E> {\n" +
+		"    X<@Readonly String> bar() {\n" +
+		"    	return (@Marker AX<@Readonly String>) new X<@Readonly String>();\n" +
+		"    }\n" +
+		"    X<@Readonly String> bar(Object o) {\n" +
+		"    	return (@Marker AX<@Readonly String>) o;\n" +
+		"    }\n" +
+		"    X<@Negative E> foo(Object o) {\n" +
+		"    	return (@Marker @Normal(value = 10) AX<@Negative E>) o;\n" +
+		"    }    \n" +
+		"    X<E> baz(Object o) {\n" +
+		"    	return (@Marker AX<E>) null;\n" +
+		"    }\n" +
+		"    X<String> baz2(BX bx) {\n" +
+		"    	return (@Marker @SingleMember(10) X<String>) bx;\n" +
+		"    }\n" +
+		"}\n" +
+		"@Normal(value = 1) class AX<@Marker F> extends @Marker X<@SingleMember(10)F> {}\n" +
+		"@Normal(value = 2) class BX extends @Marker @SingleMember(1) AX<@Readonly String> {}\n";
+	String expectedUnitToString =
+		"class X<E> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  X<@Readonly String> bar() {\n" +
+		"    return (@Marker AX<@Readonly String>) new X<@Readonly String>();\n" +
+		"  }\n" +
+		"  X<@Readonly String> bar(Object o) {\n" +
+		"    return (@Marker AX<@Readonly String>) o;\n" +
+		"  }\n" +
+		"  X<@Negative E> foo(Object o) {\n" +
+		"    return (@Marker @Normal(value = 10) AX<@Negative E>) o;\n" +
+		"  }\n" +
+		"  X<E> baz(Object o) {\n" +
+		"    return (@Marker AX<E>) null;\n" +
+		"  }\n" +
+		"  X<String> baz2(BX bx) {\n" +
+		"    return (@Marker @SingleMember(10) X<String>) bx;\n" +
+		"  }\n" +
+		"}\n" +
+		"@Normal(value = 1) class AX<@Marker F> extends @Marker X<@SingleMember(10) F> {\n" +
+		"  AX() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Normal(value = 2) class BX extends @Marker @SingleMember(1) AX<@Readonly String> {\n" +
+		"  BX() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0102", expectedUnitToString );
+}
+
+// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
+public void test0103() throws IOException {
+	String source =
+		"import java.lang.reflect.Array;\n" +
+		"@Marker class X<@Readonly T> {\n" +
+		"	T @SingleMember(0) [] theArray;\n" +
+		"	public X(Class<T> clazz) {\n" +
+		"		theArray = (@Marker @SingleMember(0) T @Normal(value = 10) []) Array.newInstance(clazz, 10); // Compiler warning\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.lang.reflect.Array;\n" +
+		"@Marker class X<@Readonly T> {\n" +
+		"  T @SingleMember(0) [] theArray;\n" +
+		"  public X(Class<T> clazz) {\n" +
+		"    super();\n" +
+		"    theArray = (@Marker @SingleMember(0) T @Normal(value = 10) []) Array.newInstance(clazz, 10);\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0103", expectedUnitToString );
+}
+
+// To test Parser.consumeCastExpressionWithGenericsArray() with Type Annotations
+public void test0104() throws IOException {
+	String source =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"    void method(Object o) {\n" +
+		"		 if (o instanceof String[]){\n" +
+		"			 String[] s;\n" +
+		"			 s = (@Marker @Readonly String @Marker []) o;\n" +
+		"		 }\n" +
+		"        if (o instanceof @Readonly List<?>[]) {\n" +
+		"            List<?>[] es;\n" +
+		"			 es = (@Marker List<?> @SingleMember(0) []) o;\n" +
+		"        }\n" +
+		"    }\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  void method(Object o) {\n" +
+		"    if ((o instanceof String[]))\n" +
+		"        {\n" +
+		"          String[] s;\n" +
+		"          s = (@Marker @Readonly String @Marker []) o;\n" +
+		"        }\n" +
+		"    if ((o instanceof @Readonly List<?>[]))\n" +
+		"        {\n" +
+		"          List<?>[] es;\n" +
+		"          es = (@Marker List<?> @SingleMember(0) []) o;\n" +
+		"        }\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0104", expectedUnitToString );
+}
+
+
+// To test Parser.consumeCastExpressionWithPrimitiveType() with Type Annotations
+public void test0105() throws IOException {
+	String source =
+		"import java.util.HashMap;\n" +
+		"class X {\n" +
+		"	public static void main(String[] args) {\n" +
+		"		HashMap<Byte, Byte> subst;\n" +
+		"		subst = new HashMap<Byte, Byte>();\n" +
+		"		subst.put((@Marker byte)1, (@Positive byte)1);\n" +
+		"		if (1 + subst.get((@Positive @Normal(value = 10) byte)1) > 0.f) {\n" +
+		"			System.out.println(\"SUCCESS\");\n" +
+		"		}		\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"import java.util.HashMap;\n" +
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    HashMap<Byte, Byte> subst;\n" +
+		"    subst = new HashMap<Byte, Byte>();\n" +
+		"    subst.put((@Marker byte) 1, (@Positive byte) 1);\n" +
+		"    if (((1 + subst.get((@Positive @Normal(value = 10) byte) 1)) > 0.f))\n" +
+		"        {\n" +
+		"          System.out.println(\"SUCCESS\");\n" +
+		"        }\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0105", expectedUnitToString );
+}
+
+// To test Parser.consumeCastExpressionWithPrimitiveType() with Type Annotations
+public void test0106() throws IOException {
+	String source =
+		"class X{\n" +
+		"	private float x, y, z;\n" +
+		"	float magnitude () {\n" +
+		"		return (@Marker @Positive float) Math.sqrt((x*x) + (y*y) + (z*z));\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  private float x;\n" +
+		"  private float y;\n" +
+		"  private float z;\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  float magnitude() {\n" +
+		"    return (@Marker @Positive float) Math.sqrt((((x * x) + (y * y)) + (z * z)));\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0106", expectedUnitToString );
+}
+
+// To test Parser.consumeCastExpressionWithQualifiedGenericsArray() with Type Annotations
+// Javac version b76 crashes on type annotations on type arguments to parameterized classes
+// in a qualified generic reference
+public void test0107() throws IOException {
+	String source =
+		"class C1<T> {\n" +
+		"	class C11 {	}\n" +
+		"	@Marker class C12 {\n" +
+		"		T t;\n" +
+		"		C1<@Readonly T>.C11 m() {\n" +
+		"			C1<@Readonly T>.C11[] ts;\n" +
+		"			ts = (@Marker C1<@Readonly T>.C11[]) new @Marker C1<?>.C11 @Normal(value = 5) [5];\n" +
+		"			return ts;\n" +
+		"		}\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class C1<T> {\n" +
+		"  class C11 {\n" +
+		"    C11() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"  }\n" +
+		"  @Marker class C12 {\n" +
+		"    T t;\n" +
+		"    C12() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"    C1<@Readonly T>.C11 m() {\n" +
+		"      C1<@Readonly T>.C11[] ts;\n" +
+		"      ts = (@Marker C1<@Readonly T>.C11[]) new @Marker C1<?>.C11 @Normal(value = 5) [5];\n" +
+		"      return ts;\n" +
+		"    }\n" +
+		"  }\n" +
+		"  C1() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0107", expectedUnitToString );
+}
+
+// To test Parser.consumeFormalParameter() with Type Annotations
+public void test0108() throws IOException {
+	String source =
+		"class X {\n" +
+		"	int field;" +
+		"	public void test(@Marker X x,@Positive int i){\n" +
+		"		x.field = i;\n" +
+		"	}\n" +
+		"	public static void main(@Readonly String args @Normal(10) []){" +
+		"		System.exit(0);\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  int field;\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void test(@Marker X x, @Positive int i) {\n" +
+		"    x.field = i;\n" +
+		"  }\n" +
+		"  public static void main(@Readonly String @Normal(10) [] args) {\n" +
+		"    System.exit(0);\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0108", expectedUnitToString );
+}
+
+// To test Parser.consumeFormalParameter() with Type Annotations
+public void test0109() throws IOException {
+	String source =
+		"class X<@Marker T> {\n" +
+		"	T field;" +
+		"	public void test(@Marker @SingleMember(1) X<? extends @Marker Object> x,@Positive T i){\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<@Marker T> {\n" +
+		"  T field;\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void test(@Marker @SingleMember(1) X<? extends @Marker Object> x, @Positive T i) {\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0109", expectedUnitToString );
+}
+
+// To test Parser.consumeClassInstanceCreationExpressionQualifiedWithTypeArguments()
+// with Type Annotations
+// Javac b76 crashes with type annotations in qualified class instance creation expression
+public void test0110() throws IOException {
+	String source =
+		"class X {\n" +
+		"	class MX {\n" +
+		"		@Marker <T> MX(T t){\n" +
+		"			System.out.println(t);\n" +
+		"		}\n" +
+		"	}\n" +
+		"	public static void main(String[] args) {\n" +
+		"		new @Marker @SingleMember(10) X().new <@Readonly String> @Marker MX(\"SUCCESS\");\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+			"class X {\n" +
+			"  class MX {\n" +
+			"    @Marker <T>MX(T t) {\n" +
+			"      super();\n" +
+			"      System.out.println(t);\n" +
+			"    }\n" +
+			"  }\n" +
+			"  X() {\n" +
+			"    super();\n" +
+			"  }\n" +
+			"  public static void main(String[] args) {\n" +
+			"    new @Marker @SingleMember(10) X().new <@Readonly String>@Marker MX(\"SUCCESS\");\n" +
+			"  }\n" +
+			"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0110", expectedUnitToString);
+}
+
+// To test Parser.consumeClassInstanceCreationExpressionWithTypeArguments()
+// with Type Annotations
+public void test0111() throws IOException {
+	String source =
+		"class X {\n" +
+		"	public <T> X(T t){\n" +
+		"		System.out.println(t);\n" +
+		"	}\n" +
+		"	public static void main(String[] args) {\n" +
+		"		new <@Readonly String> @Marker @SingleMember(0) X(\"SUCCESS\");\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString =
+			"class X {\n" +
+			"  public <T>X(T t) {\n" +
+			"    super();\n" +
+			"    System.out.println(t);\n" +
+			"  }\n" +
+			"  public static void main(String[] args) {\n" +
+			"    new <@Readonly String>@Marker @SingleMember(0) X(\"SUCCESS\");\n" +
+			"  }\n" +
+			"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0111", expectedUnitToString);
+}
+
+// To test Parser.consumeEnhancedForStatementHeaderInit() with Type Annotations
+public void test0112() throws IOException {
+	String source =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"   List list() { return null; }\n" +
+		"   void m2() { for (@SingleMember(10) Iterator<@Marker X> i = list().iterator(); i.hasNext();); }\n" +
+		"	void m3() {\n" +
+		"		Integer [] array;\n" +
+		"		array = new Integer [] {1, 2, 3};\n" +
+		"		List<List<X>> xList;\n" +
+		"		xList = null;\n" +
+		"		for(@Positive @SingleMember(10) Integer i: array) {}\n" +
+		"		for(@Marker @Normal(value = 5) List<@Readonly X> x: xList) {}\n" +
+		"	}" +
+		"}\n";
+	String expectedUnitToString =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  List list() {\n" +
+		"    return null;\n" +
+		"  }\n" +
+		"  void m2() {\n" +
+		"    for (@SingleMember(10) Iterator<@Marker X> i = list().iterator();; i.hasNext(); ) \n" +
+		"      ;\n" +
+		"  }\n" +
+		"  void m3() {\n" +
+		"    Integer[] array;\n" +
+		"    array = new Integer[]{1, 2, 3};\n" +
+		"    List<List<X>> xList;\n" +
+		"    xList = null;\n" +
+		"    for (@Positive @SingleMember(10) Integer i : array) \n" +
+		"      {\n" +
+		"      }\n" +
+		"    for (@Marker @Normal(value = 5) List<@Readonly X> x : xList) \n" +
+		"      {\n" +
+		"      }\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_COMPLETION_PARSER & ~CHECK_SELECTION_PARSER & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0112", expectedUnitToString );
+	expectedUnitToString =
+		"import java.util.*;\n" +
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  List list() {\n" +
+		"    return null;\n" +
+		"  }\n" +
+		"  void m2() {\n" +
+		"    for (@SingleMember(10) Iterator<@Marker X> i;; i.hasNext(); ) \n" +
+		"      ;\n" +
+		"  }\n" +
+		"  void m3() {\n" +
+		"    Integer[] array;\n" +
+		"    array = new Integer[]{1, 2, 3};\n" +
+		"    List<List<X>> xList;\n" +
+		"    xList = null;\n" +
+		"    for (@Positive @SingleMember(10) Integer i : array) \n" +
+		"      {\n" +
+		"      }\n" +
+		"    for (@Marker @Normal(value = 5) List<@Readonly X> x : xList) \n" +
+		"      {\n" +
+		"      }\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_COMPLETION_PARSER & CHECK_SELECTION_PARSER, source.toCharArray(), null, "test0112", expectedUnitToString );
+}
+
+// To test Parser.consumeEnterAnonymousClassBody() with Type Annotations
+public void test0113() throws IOException {
+	String source =
+		"@Marker class X {\n" +
+		"  void f(@Normal(value = 5) X this) {\n" +
+		"    new @Marker @SingleMember(10) Object() {\n" +
+		"      void foo(){\n" +
+		"        System.out.println(\"test\");\n" +
+		"      }\n" +
+		"    }.foo();\n" +
+		"  }\n" +
+		"}";
+	String expectedUnitToString =
+		"@Marker class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  void f(@Normal(value = 5) X this) {\n" +
+		"    new @Marker @SingleMember(10) Object() {\n" +
+		"  void foo() {\n" +
+		"    System.out.println(\"test\");\n" +
+		"  }\n" +
+		"}.foo();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0113", expectedUnitToString );
+}
+
+// To test Parser.consumeEnterAnonymousClassBody() with Type Annotations
+public void test0114() throws IOException {
+	String source =
+		"class Toplevel2{\n" +
+		"    public boolean foo(){\n" +
+		"    Toplevel2 o;\n" +
+		"	 o = new @Marker @Normal(value = 5) Toplevel2() { \n" +
+		"              public boolean foo() {  return false; }  // no copy in fact\n" +
+		"              };\n" +
+		"    return o.foo();\n" +
+		"  }\n" +
+		"}";
+	String expectedUnitToString =
+		"class Toplevel2 {\n" +
+		"  Toplevel2() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public boolean foo() {\n" +
+		"    Toplevel2 o;\n" +
+		"    o = new @Marker @Normal(value = 5) Toplevel2() {\n" +
+		"  public boolean foo() {\n" +
+		"    return false;\n" +
+		"  }\n" +
+		"};\n" +
+		"    return o.foo();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0114", expectedUnitToString );
+}
+
+// To test Parser.consumeEnterAnonymousClassBody() with Type Annotations
+public void test0115() throws IOException {
+	String source =
+		"class X <T> {\n" +
+		"    T foo(T t) {\n" +
+		"        System.out.println(t);\n" +
+		"        return t;\n" +
+		"    }\n" +
+		"    public static void main(String @Normal(value =  5) [] args) {\n" +
+		"        new @Marker X<@SingleMember(10) @Normal(value = 5) XY>() {\n" +
+		"            void run() {\n" +
+		"                foo(new @Marker XY());\n" +
+		"            }\n" +
+		"        }.run();\n" +
+		"    }\n" +
+		"}\n" +
+		"@Marker class XY {\n" +
+		"    public String toString() {\n" +
+		"        return \"SUCCESS\";\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<T> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  T foo(T t) {\n" +
+		"    System.out.println(t);\n" +
+		"    return t;\n" +
+		"  }\n" +
+		"  public static void main(String @Normal(value = 5) [] args) {\n" +
+		"    new @Marker X<@SingleMember(10) @Normal(value = 5) XY>() {\n" +
+		"  void run() {\n" +
+		"    foo(new @Marker XY());\n" +
+		"  }\n" +
+		"}.run();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class XY {\n" +
+		"  XY() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public String toString() {\n" +
+		"    return \"SUCCESS\";\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_DOCUMENT_ELEMENT_PARSER, source.toCharArray(), null, "test0115", expectedUnitToString );
+}
+
+// To test Parser.consumeInsideCastExpressionLL1() with Type Annotations
+public void test0116() throws IOException {
+	String source =
+		"class X{\n" +
+		"  public void test1(){\n" +
+		"    throw (@Marker Error) null; \n" +
+		"  }  \n" +
+		"  public void test2(){\n" +
+		"    String s;\n" +
+		"	 s = (@Marker @SingleMember(10) String) null;\n" +
+		"	 byte b;\n" +
+		"	 b = 0;\n" +
+		"	 Byte i;\n" +
+		"	 i = (@Positive Byte) b;\n" +
+		"  }  \n" +
+		"  public void test3(java.io.Serializable name) {\n" +
+		"     Object temp;\n" +
+		"	  temp = (Object)name;\n" +
+		"     System.out.println( (String)temp );\n" +
+		"  }\n" +
+		"}";
+	String expectedUnitToString =
+		"class X {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void test1() {\n" +
+		"    throw (@Marker Error) null;\n" +
+		"  }\n" +
+		"  public void test2() {\n" +
+		"    String s;\n" +
+		"    s = (@Marker @SingleMember(10) String) null;\n" +
+		"    byte b;\n" +
+		"    b = 0;\n" +
+		"    Byte i;\n" +
+		"    i = (@Positive Byte) b;\n" +
+		"  }\n" +
+		"  public void test3(java.io.Serializable name) {\n" +
+		"    Object temp;\n" +
+		"    temp = (Object) name;\n" +
+		"    System.out.println((String) temp);\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0116", expectedUnitToString );
+}
+
+// To test Parser.consumeInstanceOfExpression() with Type Annotations
+public void test0117() throws IOException {
+	String source =
+		"import java.util.*;\n" +
+		"class X <@NonNull T>{\n" +
+		" 	public void test1(Object obj) {\n" +
+		"   	if(obj instanceof @Marker @NonNull X) {\n" +
+		"		 	X newX;\n" +
+		"		 	newX = (@NonNull X) obj;\n" +
+		"	 }\n" +
+		"   }\n" +
+		"	@NonNull T foo(@NonNull T t) {\n" +
+		"       if (t instanceof @NonNull @Marker List<?> @Normal(value = 10) []) {\n" +
+		"           List<?> @SingleMember (10) [] es;\n" +
+		"			es = (@Marker List<?> @SingleMember(10) []) t;\n" +
+		"       }\n" +
+		"		if (t instanceof @Marker @Normal(value = 5) X<?>) {\n" +
+		"			return t;\n" +
+		"		}\n" +
+		"		return t;\n" +
+		"	}\n" +
+		"}";
+	String expectedUnitToString =
+		"import java.util.*;\n" +
+		"class X<@NonNull T> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public void test1(Object obj) {\n" +
+		"    if ((obj instanceof @Marker @NonNull X))\n" +
+		"        {\n" +
+		"          X newX;\n" +
+		"          newX = (@NonNull X) obj;\n" +
+		"        }\n" +
+		"  }\n" +
+		"  @NonNull T foo(@NonNull T t) {\n" +
+		"    if ((t instanceof @NonNull @Marker List<?> @Normal(value = 10) []))\n" +
+		"        {\n" +
+		"          List<?> @SingleMember(10) [] es;\n" +
+		"          es = (@Marker List<?> @SingleMember(10) []) t;\n" +
+		"        }\n" +
+		"    if ((t instanceof @Marker @Normal(value = 5) X<?>))\n" +
+		"        {\n" +
+		"          return t;\n" +
+		"        }\n" +
+		"    return t;\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER , source.toCharArray(), null, "test0117", expectedUnitToString );
+}
+
+// To test Parser.consumeInstanceOfExpressionWithName() with Type Annotations
+public void test0118() throws IOException {
+	String source =
+		"class Outer<E> {\n" +
+		"  Inner inner;\n" +
+		"  class Inner {\n" +
+		"    E e;\n" +
+		"    @NonNull E getOtherElement(Object other) {\n" +
+		"      if (!(other instanceof @Marker @SingleMember(10) Outer<?>.Inner))\n" +
+		"       throw new @Marker IllegalArgumentException(String.valueOf(other));\n" +
+		"      Inner that;\n" +
+		"	   that = (@Marker Inner) other;\n" +
+		"      return that.e;\n" +
+		"    }\n" +
+		"  }\n" +
+		"}";
+	String expectedUnitToString =
+		"class Outer<E> {\n" +
+		"  class Inner {\n" +
+		"    E e;\n" +
+		"    Inner() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"    @NonNull E getOtherElement(Object other) {\n" +
+		"      if ((! (other instanceof @Marker @SingleMember(10) Outer<?>.Inner)))\n" +
+		"          throw new @Marker IllegalArgumentException(String.valueOf(other));\n" +
+		"      Inner that;\n" +
+		"      that = (@Marker Inner) other;\n" +
+		"      return that.e;\n" +
+		"    }\n" +
+		"  }\n" +
+		"  Inner inner;\n" +
+		"  Outer() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER , source.toCharArray(), null, "test0118", expectedUnitToString );
+}
+
+// To test Parser.consumeTypeArgument() with Type Annotations
+public void test0119() throws IOException {
+	String source =
+		"class X<@SingleMember(1) Xp1 extends @Readonly String, @NonNull Xp2 extends @NonNull Comparable>  extends @Marker XS<@SingleMember(10) Xp2> {\n" +
+		"\n" +
+		"    public static void main(String @Marker [] args) {\n" +
+		"        Integer w;\n" +
+		"        w = new @Marker X<@Readonly @SingleMember(10) String,@Positive Integer>().get(new @Positive Integer(12));\n" +
+		"        System.out.println(\"SUCCESS\");\n" +
+		"	 }\n" +
+		"    Xp2 get(@Marker X this, Xp2 t) {\n" +
+		"        System.out.print(\"{X::get}\");\n" +
+		"        return super.get(t);\n" +
+		"    }\n" +
+		"}\n" +
+		"@Marker class XS <@NonNull XSp1> {\n" +
+		"    XSp1 get(XSp1 t) {\n" +
+		"		 @NonNull @SingleMember(10) Y.M mObject;\n" +
+		"		 mObject = new @SingleMember(10) @NonNull Y.M();\n" +
+		"        System.out.print(\"{XS::get}\");\n" +
+		"        return t;\n" +
+		"    }\n" +
+		"}\n" +
+		"class X2<T,E>{}\n" +
+		"@Marker class Y extends @Marker X2<@NonNull Y.M, @NonNull @SingleMember(1) Y.N> {\n" +
+		"	static class M{}\n" +
+		"	static class N extends M{}\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<@SingleMember(1) Xp1 extends @Readonly String, @NonNull Xp2 extends @NonNull Comparable> extends @Marker XS<@SingleMember(10) Xp2> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String @Marker [] args) {\n" +
+		"    Integer w;\n" +
+		"    w = new @Marker X<@Readonly @SingleMember(10) String, @Positive Integer>().get(new @Positive Integer(12));\n" +
+		"    System.out.println(\"SUCCESS\");\n" +
+		"  }\n" +
+		"  Xp2 get(@Marker X this, Xp2 t) {\n" +
+		"    System.out.print(\"{X::get}\");\n" +
+		"    return super.get(t);\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class XS<@NonNull XSp1> {\n" +
+		"  XS() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  XSp1 get(XSp1 t) {\n" +
+		"    @NonNull @SingleMember(10) Y.M mObject;\n" +
+		"    mObject = new @SingleMember(10) @NonNull Y.M();\n" +
+		"    System.out.print(\"{XS::get}\");\n" +
+		"    return t;\n" +
+		"  }\n" +
+		"}\n" +
+		"class X2<T, E> {\n" +
+		"  X2() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class Y extends @Marker X2<@NonNull Y.M, @NonNull @SingleMember(1) Y.N> {\n" +
+		"  static class M {\n" +
+		"    M() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"  }\n" +
+		"  static class N extends M {\n" +
+		"    N() {\n" +
+		"      super();\n" +
+		"    }\n" +
+		"  }\n" +
+		"  Y() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0119", expectedUnitToString );
+}
+
+// To test Parser.consumeTypeArgument() with Type Annotations
+public void test0120() throws IOException {
+	String source =
+		"class X<A1, A2, A3, A4, A5, A6, A7, A8> {\n" +
+		"}\n" +
+		"class Y {\n" +
+		"	@Marker X<int @Marker [], short @SingleMember(1) [] @Marker [], long[] @NonNull [][], float[] @Marker [] @Normal(value = 5) [][], double[][]@Marker [] @SingleMember(10) [][], boolean[][][][][][], char[] @Marker [][][][][][], Object[][]@Marker [] @SingleMember(10) [] @Normal(value = 5) [][][][][]> x;\n" +
+		"}\n";
+	String expectedUnitToString =
+		"class X<A1, A2, A3, A4, A5, A6, A7, A8> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"class Y {\n" +
+		"  @Marker X<int @Marker [], short @SingleMember(1) [] @Marker [], long[] @NonNull [][], float[] @Marker [] @Normal(value = 5) [][], double[][] @Marker [] @SingleMember(10) [][], boolean[][][][][][], char[] @Marker [][][][][][], Object[][] @Marker [] @SingleMember(10) [] @Normal(value = 5) [][][][][]> x;\n" +
+		"  Y() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0120", expectedUnitToString );
+}
+
+// To test Parser.consumeTypeArgumentReferenceType1() with Type Annotations
+public void test0121() throws IOException {
+	String source =
+		"@Marker class X <@NonNull T> {\n" +
+		"    protected T t;\n" +
+		"    @Marker X(@NonNull T t) {\n" +
+		"        this.t = t;\n" +
+		"    }\n" +
+		"    public static void main(String[] args) {\n" +
+		"	  X<@Marker X<@Readonly @NonNull String>> xs;\n" +
+		"	  xs = new @Marker X<@Marker X<@Readonly @NonNull String>>(new @Marker X<@Readonly @NonNull @SingleMember(10) String>(\"SUCCESS\"));\n" +
+		"	  System.out.println(xs.t.t);\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"@Marker class X<@NonNull T> {\n" +
+		"  protected T t;\n" +
+		"  @Marker X(@NonNull T t) {\n" +
+		"    super();\n" +
+		"    this.t = t;\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    X<@Marker X<@Readonly @NonNull String>> xs;\n" +
+		"    xs = new @Marker X<@Marker X<@Readonly @NonNull String>>(new @Marker X<@Readonly @NonNull @SingleMember(10) String>(\"SUCCESS\"));\n" +
+		"    System.out.println(xs.t.t);\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_INDEXING_PARSER, source.toCharArray(), null, "test0121", expectedUnitToString );
+}
+
+// To test Parser.consumeTypeParameter1WithExtendsAndBounds() and Parser.consumeWildcardBoundsSuper() with
+// Type Annotations
+public void test0122() throws IOException {
+	String source =
+		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable<@Marker Foo1> {\n" +
+		"	public int compareTo(Foo1 arg0) {\n" +
+		"		return 0;\n" +
+		"	}\n" +
+		"}\n" +
+		"class Foo1 {}\n" +
+		"@Marker class X<@NonNull T extends @NonNull @Normal (value = 5) Object & @Marker Comparable<? super @NonNull T>> {\n" +
+		"    public static void main(String[] args) {\n" +
+		"        new @Marker @SingleMember(10) X<@Marker Foo>();\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable<@Marker Foo1> {\n" +
+		"  Foo() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public int compareTo(Foo1 arg0) {\n" +
+		"    return 0;\n" +
+		"  }\n" +
+		"}\n" +
+		"class Foo1 {\n" +
+		"  Foo1() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class X<@NonNull T extends @NonNull @Normal(value = 5) Object & @Marker Comparable<? super @NonNull T>> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    new @Marker @SingleMember(10) X<@Marker Foo>();\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0122", expectedUnitToString );
+}
+
+// To test Parser.consumeTypeParameter1WithExtendsAndBounds() with Type Annotations
+public void test0123() throws IOException {
+	String source =
+		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable {\n" +
+		"	public int compareTo(Object arg0) {\n" +
+		"		return 0;\n" +
+		"	}\n" +
+		"}\n" +
+		"class Foo1 {}\n" +
+		"@Marker class X<@NonNull T extends @NonNull @Normal (value = 5) Object & @Marker Comparable, @NonNull V extends @Readonly Object> {\n" +
+		"    public static void main(String[] args) {\n" +
+		"        new @Marker @SingleMember(10) X<@Marker Foo, @SingleMember(0) Foo1>();\n" +
+		"		 Class <@NonNull Foo> c;\n" +
+		"    }\n" +
+		"}\n";
+	String expectedUnitToString =
+		"@Marker class Foo extends @Marker Foo1 implements @Marker @SingleMember(10) Comparable {\n" +
+		"  Foo() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public int compareTo(Object arg0) {\n" +
+		"    return 0;\n" +
+		"  }\n" +
+		"}\n" +
+		"class Foo1 {\n" +
+		"  Foo1() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"}\n" +
+		"@Marker class X<@NonNull T extends @NonNull @Normal(value = 5) Object & @Marker Comparable, @NonNull V extends @Readonly Object> {\n" +
+		"  X() {\n" +
+		"    super();\n" +
+		"  }\n" +
+		"  public static void main(String[] args) {\n" +
+		"    new @Marker @SingleMember(10) X<@Marker Foo, @SingleMember(0) Foo1>();\n" +
+		"    Class<@NonNull Foo> c;\n" +
+		"  }\n" +
+		"}\n";
+	checkParse(source.toCharArray(), null, "test0123", expectedUnitToString );
+}
+//To test type annotations on static class member access in a declaration
+public void test0125() throws IOException {
+	String source =
+		"public class X extends @A(\"Hello, World!\") Y<@B @C('(') String[] @D[]> {}";
+	String expectedUnitToString =
+		"public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String[] @D []> {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0125", expectedUnitToString );
+}
+//To test type annotations on static class member access in a declaration
+public void test0126() throws IOException {
+	String source =
+		"public class X {\n" +
+		"	@A(\"Hello, World!\") @B @C('(') String@E[] @D[] f;\n" +
+		"}";
+	String expectedUnitToString =
+		"public class X {\n" + 
+		"  @A(\"Hello, World!\") @B @C(\'(\') String @E [] @D [] f;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0126", expectedUnitToString );
+}
+//To test type annotations on static class member access in a declaration
+public void test0127() throws IOException {
+	String source =
+		"public class X {\n" +
+		"	@A(\"Hello, World!\") Y<@B @C('(') String[] @D[]> f;\n" +
+		"}";
+	String expectedUnitToString =
+		"public class X {\n" + 
+		"  @A(\"Hello, World!\") Y<@B @C(\'(\') String[] @D []> f;\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0127", expectedUnitToString );
+}
+//type class literal expression
+public void test0128() throws IOException {
+	String source = 
+	"public class X {\n" + 
+	"	public boolean foo(String s) {\n" + 
+	"		return (s instanceof @C('_') Object[]);\n" + 
+	"	}\n" + 
+	"	public Object foo1(String s) {\n" + 
+	"		return new @B(3) @A(\"new Object\") Object[] {};\n" + 
+	"	}\n" + 
+	"	public Class foo2(String s) {\n" + 
+	"		return null;\n" + 
+	"	}\n" + 
+	"	public Class foo3(String s) {\n" + 
+	"		return null;\n" + 
+	"	}\n" + 
+	"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public boolean foo(String s) {\n" + 
+		"    return (s instanceof @C(\'_\') Object[]);\n" + 
+		"  }\n" + 
+		"  public Object foo1(String s) {\n" + 
+		"    return new @B(3) @A(\"new Object\") Object[]{};\n" + 
+		"  }\n" + 
+		"  public Class foo2(String s) {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"  public Class foo3(String s) {\n" + 
+		"    return null;\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0128", expectedUnitToString );
+}
+//instanceof checks 
+public void test0129() throws IOException {
+	String source = "public class Clazz {\n" +
+					"public static void main(Object o) {\n" +
+					"if (o instanceof @Readonly String) {\n" +
+					"}\n" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class Clazz {\n" + 
+		"  public Clazz() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(Object o) {\n" + 
+		"    if ((o instanceof @Readonly String))\n" + 
+		"        {\n" + 
+		"        }\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0129", expectedUnitToString);
+}
+//instanceof checks 
+public void test0130() throws IOException {
+	String source = "public class Clazz {\n" +
+					"public static void foo() {\n" +
+					"	if (o instanceof @Readonly String[]) {}" +
+					"}\n" +
+					"}";
+	String expectedUnitToString = 
+		"public class Clazz {\n" + 
+		"  public Clazz() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void foo() {\n" + 
+		"    if ((o instanceof @Readonly String[]))\n" + 
+		"        {\n" + 
+		"        }\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_ALL & ~CHECK_JAVAC_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+//cast
+public void test0131() throws IOException {
+	String source =
+		"public class X {\n" + 
+		"	public void foo(Object o) {\n" + 
+		"		if (o instanceof String[][]) {\n" +
+		"			String[][] tab = (@C('_') @B(3) String[] @A[]) o;\n" +
+		"			System.out.println(tab.length);\n" +
+		"		}\n" + 
+		"		System.out.println(o);\n" +
+		"	}\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo(Object o) {\n" + 
+		"    if ((o instanceof String[][]))\n" + 
+		"        {\n" + 
+		"          String[][] tab = (@C(\'_\') @B(3) String[] @A []) o;\n" + 
+		"          System.out.println(tab.length);\n" + 
+		"        }\n" + 
+		"    System.out.println(o);\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+//cast
+public void test0132() throws IOException {
+	String source =
+		"public class X {\n" + 
+		"	public void foo(Object o) {\n" + 
+		"		if (o instanceof String[][]) {\n" +
+		"			String[][] tab = (@C('_') @B(3) String@D[] @A[]) o;\n" +
+		"			System.out.println(tab.length);\n" +
+		"		}\n" + 
+		"		System.out.println(o);\n" +
+		"	}\n" + 
+		"}";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public void foo(Object o) {\n" + 
+		"    if ((o instanceof String[][]))\n" + 
+		"        {\n" + 
+		"          String[][] tab = (@C(\'_\') @B(3) String @D [] @A []) o;\n" + 
+		"          System.out.println(tab.length);\n" + 
+		"        }\n" + 
+		"    System.out.println(o);\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+//generic type arguments in a generic method invocation
+public void test0133() throws IOException {
+	String source =
+		"public class X {\n" +
+		"	static <T, U> T foo(T t, U u) {\n" +
+		"		return t;\n" +
+		"	}\n" +
+		"	public static void main(String[] args) {\n" +
+		"		System.out.println(X.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  static <T, U>T foo(T t, U u) {\n" + 
+		"    return t;\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    System.out.println(X.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+//generic type arguments in a generic method invocation
+public void test0134() throws IOException {
+	String source =
+		"public class X {\n" +
+		"\n" +
+		"	<T, U> T foo(T t, U u) {\n" +
+		"		return t;\n" +
+		"	}\n" +
+		"	public static void main(String[] args) {\n" +
+		"		X x = new X();\n" +
+		"		System.out.println(x.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  public X() {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  <T, U>T foo(T t, U u) {\n" + 
+		"    return t;\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" +
+		"    X x = new X();\n" +
+		"    System.out.println(x.<@D() @A(value = \"hello\") String, @B X>foo(\"SUCCESS\", null));\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+//generic type arguments in a generic constructor invocation
+public void test0135() throws IOException {
+	String source =
+		"public class X {\n" +
+		"	<T, U> X(T t, U u) {\n" +
+		"	}\n" +
+		"	public static void main(String[] args) {\n" +
+		"		X x = new <@D() @A(value = \"hello\") String, @B X> X();\n" +
+		"		System.out.println(x);\n" +
+		"	}\n" +
+		"}\n";
+	String expectedUnitToString = 
+		"public class X {\n" + 
+		"  <T, U>X(T t, U u) {\n" + 
+		"    super();\n" + 
+		"  }\n" + 
+		"  public static void main(String[] args) {\n" + 
+		"    X x = new <@D() @A(value = \"hello\") String, @B X>X();\n" + 
+		"    System.out.println(x);\n" + 
+		"  }\n" + 
+		"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383600 -- Receiver annotation - new syntax.
+public void test0136() throws IOException {
+	String source =
+			"public class X<T> {\n" +
+			"  public class Y<K> {\n" +
+			"    void foo(@Marker X<T> this) {\n" +
+			"    }\n" +
+			"    public class Z {\n" +
+			"      Z(@D() @A(value = \"hello\") X<T>.Y<K> X.Y.this) {\n" +
+			"      }\n" +
+			"    }\n" +
+			"  }\n" +
+			"  public static void main(String[] args) {\n" +
+			"    new X<String>().new Y<Integer>().new Z();\n" +
+			"  }\n" +
+			"}\n";
+	String expectedUnitToString = 
+			"public class X<T> {\n" + 
+			"  public class Y<K> {\n" + 
+			"    public class Z {\n" + 
+			"      Z(@D() @A(value = \"hello\") X<T>.Y<K> X.Y.this) {\n" + 
+			"        super();\n" + 
+			"      }\n" + 
+			"    }\n" + 
+			"    public Y() {\n" + 
+			"      super();\n" + 
+			"    }\n" + 
+			"    void foo(@Marker X<T> this) {\n" + 
+			"    }\n" + 
+			"  }\n" + 
+			"  public X() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  public static void main(String[] args) {\n" + 
+			"    new X<String>().new Y<Integer>().new Z();\n" + 
+			"  }\n" + 
+			"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0130", expectedUnitToString);
+}
+// Support type annotations for wildcard
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=388085
+public void test0137() throws IOException {
+	String source = 
+			"class X {\n" +
+			"	public void main(Four<@Marker ? super String, @Marker ? extends Object> param) {\n" +
+			"		One<@Marker ? extends Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String,@Marker ? extends Object>>>> one = null;\n" +
+			"		Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String,@Marker ? extends Object>>> two = null;\n" +
+			"		Three<@Marker ? extends Four<@Marker ? super String,@Marker ? extends Object>> three = null;\n" +
+			"		Four<@Marker ? super String,@Marker ? extends Object> four = param;\n" +
+			"	}\n" +
+			"}\n" +
+			"class One<R> {}\n" +
+			"class Two<S> {}\n" +
+			"class Three<T> {}\n" +
+			"class Four<U, V> {}\n" +
+			"@interface Marker {}";
+	String expectedUnitToString = 
+			"class X {\n" + 
+			"  X() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  public void main(Four<@Marker ? super String, @Marker ? extends Object> param) {\n" + 
+			"    One<@Marker ? extends Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;\n" + 
+			"    Two<@Marker ? extends Three<@Marker ? extends Four<@Marker ? super String, @Marker ? extends Object>>> two = null;\n" + 
+			"    Three<@Marker ? extends Four<@Marker ? super String, @Marker ? extends Object>> three = null;\n" + 
+			"    Four<@Marker ? super String, @Marker ? extends Object> four = param;\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"class One<R> {\n" + 
+			"  One() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"class Two<S> {\n" + 
+			"  Two() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"class Three<T> {\n" + 
+			"  Three() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"class Four<U, V> {\n" + 
+			"  Four() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"@interface Marker {\n" + 
+			"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0137", expectedUnitToString);
+}
+public void test0138() throws IOException {
+	String source = 
+			"import java.lang.annotation.Target;\n" +
+			"import static java.lang.annotation.ElementType.*;\n" +
+			"public class X {\n" +
+			"	public void foo() {\n" +
+			"		int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [bar()] @Marker @Marker2 [];\n" +
+			"		int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [X.bar2(2)] @Marker @Marker2 [];\n" +
+			"	}\n" +
+			"	public int bar() {\n" +
+			"		return 2;\n" +
+			"	}\n" +
+			"	public static int bar2(int k) {\n" +
+			"		return k;\n" + 
+			"	}\n" +
+			"}\n" +
+			"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+			"@interface Marker {}\n" +
+			"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+			"@interface Marker2 {}\n";
+	String expectedUnitToString = 
+			"import java.lang.annotation.Target;\n" + 
+			"import static java.lang.annotation.ElementType.*;\n" + 
+			"public class X {\n" + 
+			"  public X() {\n" + 
+			"    super();\n" + 
+			"  }\n" + 
+			"  public void foo() {\n" + 
+			"    int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [bar()] @Marker @Marker2 [];\n" + 
+			"    int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [X.bar2(2)] @Marker @Marker2 [];\n" + 
+			"  }\n" + 
+			"  public int bar() {\n" + 
+			"    return 2;\n" + 
+			"  }\n" + 
+			"  public static int bar2(int k) {\n" + 
+			"    return k;\n" + 
+			"  }\n" + 
+			"}\n" + 
+			"@Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker {\n" + 
+			"}\n" + 
+			"@Target(java.lang.annotation.ElementType.TYPE_USE) @interface Marker2 {\n" + 
+			"}\n";
+	checkParse(CHECK_PARSER, source.toCharArray(), null, "test0137", expectedUnitToString);
+}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InstanceofExpressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InstanceofExpressionTest.java
index f092e5e..233eafd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InstanceofExpressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/InstanceofExpressionTest.java
@@ -1,52 +1,52 @@
-/*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *
- *******************************************************************************/
-
-package org.eclipse.jdt.core.tests.compiler.regression;
-
-import junit.framework.Test;
-
-public class InstanceofExpressionTest extends AbstractRegressionTest {
-
-	public InstanceofExpressionTest(String name) {
-		super(name);
-	}
-
-	public static Test suite() {
-		return buildAllCompliancesTestSuite(testClass());
-	}
-
-	public static Class testClass() {
-		return InstanceofExpressionTest.class;
-	}
-
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=341828
-	public void test001() {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.io.InputStream;\n" +
-				"public class X {\n" +
-				"    void foo(InputStream is) {\n" +
-				"    if (is instanceof FileInputStream)\n" +
-				"        System.out.println(\"Hello\");\n" +
-				"    }\n" +
-				"}",
-			},
-			"----------\n" +
-			"1. ERROR in X.java (at line 4)\n" +
-			"	if (is instanceof FileInputStream)\n" +
-			"	                  ^^^^^^^^^^^^^^^\n" +
-			"FileInputStream cannot be resolved to a type\n" +
-			"----------\n"
-		);
-	}
-}
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *
+ *******************************************************************************/
+
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import junit.framework.Test;
+
+public class InstanceofExpressionTest extends AbstractRegressionTest {
+
+	public InstanceofExpressionTest(String name) {
+		super(name);
+	}
+
+	public static Test suite() {
+		return buildAllCompliancesTestSuite(testClass());
+	}
+
+	public static Class testClass() {
+		return InstanceofExpressionTest.class;
+	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=341828
+	public void test001() {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.io.InputStream;\n" +
+				"public class X {\n" +
+				"    void foo(InputStream is) {\n" +
+				"    if (is instanceof FileInputStream)\n" +
+				"        System.out.println(\"Hello\");\n" +
+				"    }\n" +
+				"}",
+			},
+			"----------\n" +
+			"1. ERROR in X.java (at line 4)\n" +
+			"	if (is instanceof FileInputStream)\n" +
+			"	                  ^^^^^^^^^^^^^^^\n" +
+			"FileInputStream cannot be resolved to a type\n" +
+			"----------\n"
+		);
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
index 061d417..86b8e34 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeTypeAnnotationTest.java
@@ -1,4486 +1,4486 @@
-/*******************************************************************************
- * Copyright (c) 2011, 2014 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.tests.compiler.regression;
-
-import java.io.File;
-import java.util.Map;
-
-import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-
-import junit.framework.Test;
-
-public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
-
-	static { 
-//		TESTS_NUMBERS = new int [] { 35 };
-//		TESTS_NAMES = new String [] { "test0390882b" };
-	}
-	public static Class testClass() {
-		return NegativeTypeAnnotationTest.class;
-	}
-	public static Test suite() {
-		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
-	}
-	public NegativeTypeAnnotationTest(String testName){
-		super(testName);
-	}
-	public void test001() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X extends @Marker2 Object {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X extends @Marker2 Object {}\n" + 
-				"	                        ^^^^^^^\n" + 
-				"Marker2 cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test002() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.io.Serializable;\n" +
-					"public class X implements @Marker2 Serializable {\n" +
-					"	private static final long serialVersionUID = 1L;\n" +
-					"}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	public class X implements @Marker2 Serializable {\n" + 
-				"	                           ^^^^^^^\n" + 
-				"Marker2 cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test003() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X extends @Marker Object {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X extends @Marker Object {}\n" + 
-				"	                        ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test004() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X<@Marker T> {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X<@Marker T> {}\n" + 
-				"	                ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test005() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X<@Marker T> {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X<@Marker T> {}\n" + 
-				"	                ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test006() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"Y.java",
-				"class Y {}\n",
-				"X.java",
-				"public class X extends @A(id=\"Hello, World!\") @B @C('(') Y {\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X extends @A(id=\"Hello, World!\") @B @C(\'(\') Y {\n" + 
-		"	                        ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X extends @A(id=\"Hello, World!\") @B @C(\'(\') Y {\n" + 
-		"	                                               ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 1)\n" + 
-		"	public class X extends @A(id=\"Hello, World!\") @B @C(\'(\') Y {\n" + 
-		"	                                                  ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	public void test007() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"I.java",
-				"interface I {}\n",
-				"J.java",
-				"interface J {}\n",
-				"X.java",
-				"public class X implements @A(id=\"Hello, World!\") I, @B @C('(') J {}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X implements @A(id=\"Hello, World!\") I, @B @C(\'(\') J {}\n" + 
-		"	                           ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X implements @A(id=\"Hello, World!\") I, @B @C(\'(\') J {}\n" + 
-		"	                                                     ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 1)\n" + 
-		"	public class X implements @A(id=\"Hello, World!\") I, @B @C(\'(\') J {}\n" + 
-		"	                                                        ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	public void test010() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"Y.java",
-				"class Y<T> {}\n",
-				"X.java",
-				"public class X extends @A(\"Hello, World!\") Y<@B @C('(') String> {\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String> {\n" + 
-		"	                        ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String> {\n" + 
-		"	                                              ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 1)\n" + 
-		"	public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String> {\n" + 
-		"	                                                 ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	public void test011() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"I.java",
-				"interface I<T> {}\n",
-				"J.java",
-				"interface J<T> {}\n",
-				"X.java",
-				"public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C('(') Integer> {}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C(\'(\') Integer> {}\n" + 
-		"	                             ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C(\'(\') Integer> {}\n" + 
-		"	                                                           ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 1)\n" + 
-		"	public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C(\'(\') Integer> {}\n" + 
-		"	                                                                ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// throws
-	public void test012() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"E.java",
-				"class E extends RuntimeException {\n" +
-				"	private static final long serialVersionUID = 1L;\n" +
-				"}\n",
-				"E1.java",
-				"class E1 extends RuntimeException {\n" +
-				"	private static final long serialVersionUID = 1L;\n" +
-				"}\n",
-				"E2.java",
-				"class E2 extends RuntimeException {\n" +
-				"	private static final long serialVersionUID = 1L;\n" +
-				"}\n",
-				"X.java",
-				"public class X {\n" +
-				"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C('(') E2 {}\n" +
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C(\'(\') E2 {}\n" + 
-		"	                   ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 2)\n" + 
-		"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C(\'(\') E2 {}\n" + 
-		"	                                              ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 2)\n" + 
-		"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C(\'(\') E2 {}\n" + 
-		"	                                                 ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// method receiver
-	public void test013() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	void foo(@B(3) X this) {}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	void foo(@B(3) X this) {}\n" + 
-		"	          ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// method return type
-	public void test014() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	@B(3) int foo() {\n" +
-				"		return 1;\n" +
-				"	}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	@B(3) int foo() {\n" + 
-		"	 ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// field type
-	public void test015() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	@B(3) int field;\n" +
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	@B(3) int field;\n" + 
-		"	 ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// method parameter
-	public void test016() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	int foo(@B(3) String s) {\n" +
-				"		return s.length();\n" +
-				"	}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	int foo(@B(3) String s) {\n" + 
-		"	         ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// method parameter generic or array
-	public void test017() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	int foo(String @B(3) [] s) {\n" +
-				"		return s.length;\n" +
-				"	}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	int foo(String @B(3) [] s) {\n" + 
-		"	                ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// field type generic or array
-	public void test018() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	int @B(3) [] field;\n" +
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	int @B(3) [] field;\n" + 
-		"	     ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// class type parameter
-	public void test019() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X<@A @B(3) T> {}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X<@A @B(3) T> {}\n" + 
-		"	                ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X<@A @B(3) T> {}\n" + 
-		"	                   ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// method type parameter
-	public void test020() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	<@A @B(3) T> void foo(T t) {}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	<@A @B(3) T> void foo(T t) {}\n" + 
-		"	  ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 2)\n" + 
-		"	<@A @B(3) T> void foo(T t) {}\n" + 
-		"	     ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// class type parameter bound
-	public void test021() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"Z.java",
-				"public class Z {}",
-				"X.java",
-				"public class X<T extends @A Z & @B(3) Cloneable> {}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X<T extends @A Z & @B(3) Cloneable> {}\n" + 
-		"	                          ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X<T extends @A Z & @B(3) Cloneable> {}\n" + 
-		"	                                 ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// class type parameter bound generic or array
-	public void test022() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"Y.java",
-				"public class Y<T> {}",
-				"X.java",
-				"public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 1)\n" + 
-		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
-		"	                            ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 1)\n" + 
-		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
-		"	                                      ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 1)\n" + 
-		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
-		"	                                            ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"4. ERROR in X.java (at line 1)\n" + 
-		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
-		"	                                                    ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// method type parameter bound
-	public void test023() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"Z.java",
-				"public class Z {}",
-				"X.java",
-				"public class X {\n" +
-				"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" +
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" + 
-		"	            ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 2)\n" + 
-		"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" + 
-		"	                   ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// class type parameter bound generic or array
-	public void test024() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"Z.java",
-				"public class Z {}",
-				"Y.java",
-				"public class Y<T> {}",
-				"X.java",
-				"public class X {\n" +
-				"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" +
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 2)\n" + 
-		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
-		"	              ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 2)\n" + 
-		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
-		"	                   ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 2)\n" + 
-		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
-		"	                         ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"4. ERROR in X.java (at line 2)\n" + 
-		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
-		"	                                 ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// local variable + generic or array
-	public void test025() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	void foo(String s) {\n" + 
-				"		@C int i;\n" + 
-				"		@A String [] @B(3)[] tab = new String[][] {};\n" + 
-				"		if (tab != null) {\n" + 
-				"			i = 0;\n" + 
-				"			System.out.println(i + tab.length);\n" + 
-				"		} else {\n" + 
-				"			System.out.println(tab.length);\n" + 
-				"		}\n" + 
-				"		i = 4;\n" + 
-				"		System.out.println(-i + tab.length);\n" + 
-				"	}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 3)\n" + 
-		"	@C int i;\n" + 
-		"	 ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 4)\n" + 
-		"	@A String [] @B(3)[] tab = new String[][] {};\n" + 
-		"	 ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 4)\n" + 
-		"	@A String [] @B(3)[] tab = new String[][] {};\n" + 
-		"	              ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// type argument constructor call
-	public void test026() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	<T> X(T t) {\n" + 
-				"	}\n" + 
-				"	public Object foo() {\n" + 
-				"		X x = new <@A @B(1) String>X(null);\n" + 
-				"		return x;\n" + 
-				"	}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 5)\n" + 
-		"	X x = new <@A @B(1) String>X(null);\n" + 
-		"	            ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 5)\n" + 
-		"	X x = new <@A @B(1) String>X(null);\n" + 
-		"	               ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// type argument constructor call generic or array
-	public void test027() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" + 
-				"	<T> X(T t) {\n" + 
-				"	}\n" + 
-				"	public Object foo() {\n" + 
-				"		X x = new <@A @B(1) String>X(null);\n" + 
-				"		return x;\n" + 
-				"	}\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 5)\n" + 
-		"	X x = new <@A @B(1) String>X(null);\n" + 
-		"	            ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 5)\n" + 
-		"	X x = new <@A @B(1) String>X(null);\n" + 
-		"	               ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// type argument method call and generic or array
-	public void test028() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" +
-				"\n" +
-				"	static <T, U> T foo(T t, U u) {\n" +
-				"		return t;\n" +
-				"	}\n" +
-				"	public static void main(String[] args) {\n" +
-				"		System.out.println(X.<@A @B(1) String[], @C('-') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" +
-				"	}\n" +
-				"}\n",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 7)\n" + 
-		"	System.out.println(X.<@A @B(1) String[], @C(\'-\') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" + 
-		"	                       ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 7)\n" + 
-		"	System.out.println(X.<@A @B(1) String[], @C(\'-\') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" + 
-		"	                          ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 7)\n" + 
-		"	System.out.println(X.<@A @B(1) String[], @C(\'-\') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" + 
-		"	                                          ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	public void test029() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X extends @Marker2 Object {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X extends @Marker2 Object {}\n" + 
-				"	                        ^^^^^^^\n" + 
-				"Marker2 cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test030() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.io.Serializable;\n" +
-					"public class X implements @Marker2 Serializable {\n" +
-					"	private static final long serialVersionUID = 1L;\n" +
-					"}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	public class X implements @Marker2 Serializable {\n" + 
-				"	                           ^^^^^^^\n" + 
-				"Marker2 cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test031() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"Marker.java",
-					"import java.lang.annotation.Target;\n" + 
-					"import static java.lang.annotation.ElementType.*;\n" + 
-					"@Target(TYPE)\n" + 
-					"@interface Marker {}",
-					"X.java",
-					"public class X<@Marker T> {}",
-
-					"java/lang/annotation/ElementType.java",
-					"package java.lang.annotation;\n" +
-					"public enum ElementType {\n" +
-					"    TYPE,\n" +
-					"    FIELD,\n" +
-					"    METHOD,\n" +
-					"    PARAMETER,\n" +
-					"    CONSTRUCTOR,\n" +
-					"    LOCAL_VARIABLE,\n" +
-					"    ANNOTATION_TYPE,\n" +
-					"    PACKAGE,\n" +
-					"    TYPE_PARAMETER,\n" +
-					"    TYPE_USE\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X<@Marker T> {}\n" + 
-				"	               ^^^^^^^\n" + 
-				"The annotation @Marker is disallowed for this location\n" + 
-				"----------\n");
-	}
-	public void test032() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"Marker.java",
-					"@interface Marker {}",
-					"X.java",
-					"public class X<@Marker T> {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X<@Marker T> {}\n" + 
-				"	               ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	public void test033() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"Marker.java",
-					"@interface Marker {}",
-					"Y.java",
-					"public class Y {}",
-					"X.java",
-					"public class X extends @Marker Y {}",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X extends @Marker Y {}\n" + 
-				"	                       ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	// check locations
-	public void test034() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.util.Map;\n" +
-				"import java.util.List;\n" +
-				"public class X {\n" + 
-				"	@H String @E[] @F[] @G[] field;\n" + 
-				"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-				"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 4)\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"	 ^\n" + 
-		"H cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 4)\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"	           ^\n" + 
-		"E cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 4)\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"	                ^\n" + 
-		"F cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"4. ERROR in X.java (at line 4)\n" + 
-		"	@H String @E[] @F[] @G[] field;\n" + 
-		"	                     ^\n" + 
-		"G cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"5. ERROR in X.java (at line 5)\n" + 
-		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-		"	 ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"6. ERROR in X.java (at line 5)\n" + 
-		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-		"	        ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"7. ERROR in X.java (at line 5)\n" + 
-		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-		"	                   ^\n" + 
-		"C cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"8. ERROR in X.java (at line 5)\n" + 
-		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
-		"	                           ^\n" + 
-		"D cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"9. ERROR in X.java (at line 6)\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"	 ^\n" + 
-		"A cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"10. ERROR in X.java (at line 6)\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"	        ^\n" + 
-		"B cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"11. ERROR in X.java (at line 6)\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"	                   ^\n" + 
-		"H cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"12. ERROR in X.java (at line 6)\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"	                             ^\n" + 
-		"E cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"13. ERROR in X.java (at line 6)\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"	                                  ^\n" + 
-		"F cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"14. ERROR in X.java (at line 6)\n" + 
-		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
-		"	                                       ^\n" + 
-		"G cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// check locations
-	public void test035() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.util.Map;\n" +
-				"import java.util.List;\n" +
-				"public class X {\n" + 
-				"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-				"}",
-		},
-		"----------\n" + 
-		"1. ERROR in X.java (at line 4)\n" + 
-		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-		"	 ^\n" + 
-		"H cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 4)\n" + 
-		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-		"	                     ^\n" + 
-		"E cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"3. ERROR in X.java (at line 4)\n" + 
-		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-		"	                          ^\n" + 
-		"F cannot be resolved to a type\n" + 
-		"----------\n" + 
-		"4. ERROR in X.java (at line 4)\n" + 
-		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
-		"	                               ^\n" + 
-		"G cannot be resolved to a type\n" + 
-		"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383884 -- Compiler tolerates illegal dimension annotation in class literal expressions
-	public void test036() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" +
-				"  public static void main(String[] args) {\n" +
-				"    System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" +
-				"    System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" +
-				"    System.out.println(int [] [] [] [] [].class);\n" +
-				"    System.out.println(X [] [] [] [] [].class);\n" +
-				"  }\n" +
-				"}\n" +
-				"@interface Empty {\n" +
-				"}\n" +
-				"@interface NonEmpty {\n" +
-				"}\n",
-		},
-		"----------\n" + 
-		"1. WARNING in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                       ^^^^^^^^^\n" + 
-		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n" + 
-		"2. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                       ^^^^^^^^^\n" + 
-		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-		"----------\n" + 
-		"3. WARNING in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                       ^^^^^^^^^^^^^^^^\n" + 
-		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n" + 
-		"4. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                       ^^^^^^^^^\n" + 
-		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-		"----------\n" + 
-		"5. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                 ^^^^^^\n" + 
-		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-		"----------\n" + 
-		"6. WARNING in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                              ^^^^^^^^^\n" + 
-		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n" + 
-		"7. ERROR in X.java (at line 3)\n" + 
-		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                              ^^^^^^^^^\n" + 
-		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-		"----------\n" + 
-		"8. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                     ^^^^^^^^^\n" + 
-		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n" + 
-		"9. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                     ^^^^^^^^^^^^^^^^\n" + 
-		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n" + 
-		"10. ERROR in X.java (at line 4)\n" + 
-		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
-		"	                                                            ^^^^^^^^^\n" + 
-		"Syntax error, type annotations are illegal here\n" + 
-		"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383950
-	// [1.8][compiler] Type annotations must have target type meta annotation TYPE_USE
-	public void test037() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"@interface Marker {}\n" +
-					"@Marker	// line 2: Don't complain \n" +
-					"public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" +
-					"	public @Marker Object foo(@Marker Object obj) {  // 4: Don't complain on both\n" +
-					"		return null;\n" +
-					"	}\n" +
-					"}\n",
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 3)\n" + 
-				"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
-				"	               ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 3)\n" + 
-				"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
-				"	                                   ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383950
-	// [1.8][compiler] Type annotations must have target type meta annotation TYPE_USE
-	public void test038() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.Target;\n" + 
-						"import static java.lang.annotation.ElementType.*;\n" + 
-						"@Target({PACKAGE, TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER, LOCAL_VARIABLE})\n" + 
-						"@interface Marker {}\n" +
-						"public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" +
-						"}\n",
-					},
-					"----------\n" + 
-					"1. ERROR in X.java (at line 5)\n" + 
-					"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
-					"	               ^^^^^^^\n" + 
-					"The annotation @Marker is disallowed for this location\n" + 
-					"----------\n" + 
-					"2. ERROR in X.java (at line 5)\n" + 
-					"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
-					"	                                   ^^^^^^^\n" + 
-					"The annotation @Marker is disallowed for this location\n" + 
-					"----------\n");
-	}
-	// JSR 308: "It is not permitted to annotate the type name in an import statement."
-	public void test039() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import @Marker java.lang.String; // Compilation error \n" +
-						"public class X { \n" +
-						"}\n" + 
-						"@interface Marker {}\n"
-					}, 
-					"----------\n" + 
-					"1. ERROR in X.java (at line 1)\n" + 
-					"	import @Marker java.lang.String; // Compilation error \n" + 
-					"	       ^^^^^^^\n" + 
-					"Syntax error, type annotations are illegal here\n" + 
-					"----------\n");
-	}
-	// Test that type name can't be left out in a cast expression with an annotations 
-	public void test040() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X { \n" +
-						"	public void foo(Object myObject) {\n" +
-						"		String myString = (@NonNull) myObject;" +
-						"	}\n" +
-						"}\n" + 
-						"@interface NonNull {}\n"
-					}, 
-					"----------\n" + 
-					"1. ERROR in X.java (at line 3)\n" + 
-					"	String myString = (@NonNull) myObject;	}\n" + 
-					"	                   ^\n" + 
-					"Syntax error on token \"@\", delete this token\n" + 
-					"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385111
-	// [1.8][compiler] Compiler fails to flag undefined annotation type. 
-	public void test0385111() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.util.ArrayList;\n" +
-						"import java.util.List;\n" +
-						"public class X {\n" +
-						"    public void foo(String fileName) {\n" +
-						"        List<String> l = new @MissingTypeNotIgnored ArrayList<String>();\n" +
-						"        List<String> l1 = new @MissingTypeIgnored ArrayList<>();\n" +
-						"    }\n" +
-						"}\n",
-					},
-					"----------\n" + 
-					"1. ERROR in X.java (at line 5)\n" + 
-					"	List<String> l = new @MissingTypeNotIgnored ArrayList<String>();\n" + 
-					"	                      ^^^^^^^^^^^^^^^^^^^^^\n" + 
-					"MissingTypeNotIgnored cannot be resolved to a type\n" + 
-					"----------\n" + 
-					"2. ERROR in X.java (at line 6)\n" + 
-					"	List<String> l1 = new @MissingTypeIgnored ArrayList<>();\n" + 
-					"	                       ^^^^^^^^^^^^^^^^^^\n" + 
-					"MissingTypeIgnored cannot be resolved to a type\n" + 
-					"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385111
-	// Test to exercise assorted cleanup along with bug fix. 
-	public void test0385111a() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"    public void foo(String fileName) {\n" +
-						"        try (@Annot X x = null; @Annot X x2 = null) {\n"+
-						"        } catch (@Annot NullPointerException | @Annot UnsupportedOperationException e) {\n" +
-						"        }\n" +
-						"    }\n" +
-						"}\n",
-					},
-					"----------\n" + 
-					"1. ERROR in X.java (at line 3)\n" + 
-					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
-					"	      ^^^^^\n" + 
-					"Annot cannot be resolved to a type\n" + 
-					"----------\n" + 
-					"2. ERROR in X.java (at line 3)\n" + 
-					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
-					"	            ^\n" + 
-					"The resource type X does not implement java.lang.AutoCloseable\n" + 
-					"----------\n" + 
-					"3. ERROR in X.java (at line 3)\n" + 
-					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
-					"	                         ^^^^^\n" + 
-					"Annot cannot be resolved to a type\n" + 
-					"----------\n" + 
-					"4. ERROR in X.java (at line 3)\n" + 
-					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
-					"	                               ^\n" + 
-					"The resource type X does not implement java.lang.AutoCloseable\n" + 
-					"----------\n" + 
-					"5. ERROR in X.java (at line 4)\n" + 
-					"	} catch (@Annot NullPointerException | @Annot UnsupportedOperationException e) {\n" + 
-					"	          ^^^^^\n" + 
-					"Annot cannot be resolved to a type\n" + 
-					"----------\n" + 
-					"6. ERROR in X.java (at line 4)\n" + 
-					"	} catch (@Annot NullPointerException | @Annot UnsupportedOperationException e) {\n" + 
-					"	                                        ^^^^^\n" + 
-					"Annot cannot be resolved to a type\n" + 
-					"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
-	public void test0383913() {
-		this.runNegativeTest(
-				new String[]{
-						"X.java",
-						"public class X {\n" +
-						"	public void foo(Object obj, X this) {}\n" +
-						"	public void foo(Object obj1, X this, Object obj2) {}\n" +
-						"	public void foo(Object obj, Object obj2, Object obj3, X this) {}\n" +
-						"	class Y {\n" +
-						"		Y(Object obj, Y Y.this){}\n" +
-						"	}\n" +
-						"}"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	public void foo(Object obj, X this) {}\n" + 
-				"	                              ^^^^\n" + 
-				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 3)\n" + 
-				"	public void foo(Object obj1, X this, Object obj2) {}\n" + 
-				"	                               ^^^^\n" + 
-				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 4)\n" + 
-				"	public void foo(Object obj, Object obj2, Object obj3, X this) {}\n" + 
-				"	                                                        ^^^^\n" + 
-				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 6)\n" + 
-				"	Y(Object obj, Y Y.this){}\n" + 
-				"	                  ^^^^\n" + 
-				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
-	public void test0383913b() {
-		this.runNegativeTest(
-				new String[] {
-						"Outer.java",
-						"public class Outer {\n" +
-						"    Outer(Outer Outer.this) {}\n" +
-						"    Outer(Outer this, int i) {}\n" +
-						"    class Inner<K,V> {\n" +
-						"        class InnerMost<T> {\n" +
-						"            InnerMost(Outer.Inner this) {}\n" +
-						"            InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" +
-						"            InnerMost(Outer Outer.this, float f) {}\n" +
-						"            InnerMost(Outer.Inner<K,V>.InnerMost<T> Outer.Inner.InnerMost.this, Object obj) {}\n" +
-						"            InnerMost(Inner<K,V> Outer.Inner.InnerMost.this, int i) {}\n" +
-						"            InnerMost(Outer.Inner<K, V> this, float f, int i) {}\n" +
-						"            InnerMost(Outer.Inner<K,V> Inner.this, long l) {}\n" +
-						"        }\n" +
-						"    }\n" +
-						"}\n"},
-						"----------\n" + 
-						"1. ERROR in Outer.java (at line 2)\n" + 
-						"	Outer(Outer Outer.this) {}\n" + 
-						"	                  ^^^^\n" + 
-						"Explicit 'this' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
-						"----------\n" + 
-						"2. ERROR in Outer.java (at line 3)\n" + 
-						"	Outer(Outer this, int i) {}\n" + 
-						"	            ^^^^\n" + 
-						"Explicit 'this' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
-						"----------\n" + 
-						"3. WARNING in Outer.java (at line 6)\n" + 
-						"	InnerMost(Outer.Inner this) {}\n" + 
-						"	          ^^^^^^^^^^^\n" + 
-						"Outer.Inner is a raw type. References to generic type Outer.Inner<K,V> should be parameterized\n" + 
-						"----------\n" + 
-						"4. ERROR in Outer.java (at line 6)\n" + 
-						"	InnerMost(Outer.Inner this) {}\n" + 
-						"	          ^^^^^^^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
-						"----------\n" + 
-						"5. ERROR in Outer.java (at line 6)\n" + 
-						"	InnerMost(Outer.Inner this) {}\n" + 
-						"	                      ^^^^\n" + 
-						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
-						"----------\n" + 
-						"6. WARNING in Outer.java (at line 7)\n" + 
-						"	InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" + 
-						"	          ^^^^^^^^^^^\n" + 
-						"Outer.Inner is a raw type. References to generic type Outer.Inner<K,V> should be parameterized\n" + 
-						"----------\n" + 
-						"7. ERROR in Outer.java (at line 7)\n" + 
-						"	InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" + 
-						"	          ^^^^^^^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
-						"----------\n" + 
-						"8. ERROR in Outer.java (at line 7)\n" + 
-						"	InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" + 
-						"	                      ^^^^^^^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
-						"----------\n" + 
-						"9. ERROR in Outer.java (at line 8)\n" + 
-						"	InnerMost(Outer Outer.this, float f) {}\n" + 
-						"	          ^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
-						"----------\n" + 
-						"10. ERROR in Outer.java (at line 8)\n" + 
-						"	InnerMost(Outer Outer.this, float f) {}\n" + 
-						"	                ^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
-						"----------\n" + 
-						"11. ERROR in Outer.java (at line 9)\n" + 
-						"	InnerMost(Outer.Inner<K,V>.InnerMost<T> Outer.Inner.InnerMost.this, Object obj) {}\n" + 
-						"	          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
-						"----------\n" + 
-						"12. ERROR in Outer.java (at line 9)\n" + 
-						"	InnerMost(Outer.Inner<K,V>.InnerMost<T> Outer.Inner.InnerMost.this, Object obj) {}\n" + 
-						"	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
-						"----------\n" + 
-						"13. ERROR in Outer.java (at line 10)\n" + 
-						"	InnerMost(Inner<K,V> Outer.Inner.InnerMost.this, int i) {}\n" + 
-						"	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
-						"----------\n" + 
-						"14. ERROR in Outer.java (at line 11)\n" + 
-						"	InnerMost(Outer.Inner<K, V> this, float f, int i) {}\n" + 
-						"	                            ^^^^\n" + 
-						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
-						"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
-	public void test0383913c() {
-		this.runNegativeTest(
-				new String[] {
-						"Outer.java",
-						"public class Outer {\n" +
-						"    class Inner<K,V> {\n" +
-						"        class InnerMost<T> {\n" +
-						"            public void foo(Outer Outer.this) {}\n" +
-						"            public void foo(Inner<K,V> Inner.this, int i) {}\n" +
-						"            public void foo(InnerMost this, int i, int j) {}\n" +
-						"            public void foo(Inner.InnerMost<T> this, Object obj) {}\n" +
-						"            public void foo(InnerMost<T> this, float f) {}\n" +
-						"            public void foo(Inner<K,V>.InnerMost<T> this, long l) {}\n" +
-						"            public void foo(Outer.Inner<K,V>.InnerMost<T> this, float f, float ff) {}\n" +
-						"            public void foo(InnerMost<T> Outer.Inner.InnerMost.this, int i, float f) {}\n" +
-						"        }\n" +
-						"    }\n" +
-						"}\n"},
-						"----------\n" + 
-						"1. ERROR in Outer.java (at line 4)\n" + 
-						"	public void foo(Outer Outer.this) {}\n" + 
-						"	                ^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
-						"----------\n" + 
-						"2. ERROR in Outer.java (at line 4)\n" + 
-						"	public void foo(Outer Outer.this) {}\n" + 
-						"	                      ^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter for a method cannot have a qualifying name\n" + 
-						"----------\n" + 
-						"3. ERROR in Outer.java (at line 5)\n" + 
-						"	public void foo(Inner<K,V> Inner.this, int i) {}\n" + 
-						"	                ^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
-						"----------\n" + 
-						"4. ERROR in Outer.java (at line 5)\n" + 
-						"	public void foo(Inner<K,V> Inner.this, int i) {}\n" + 
-						"	                           ^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter for a method cannot have a qualifying name\n" + 
-						"----------\n" + 
-						"5. WARNING in Outer.java (at line 6)\n" + 
-						"	public void foo(InnerMost this, int i, int j) {}\n" + 
-						"	                ^^^^^^^^^\n" + 
-						"Outer.Inner.InnerMost is a raw type. References to generic type Outer.Inner<K,V>.InnerMost<T> should be parameterized\n" + 
-						"----------\n" + 
-						"6. ERROR in Outer.java (at line 6)\n" + 
-						"	public void foo(InnerMost this, int i, int j) {}\n" + 
-						"	                ^^^^^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
-						"----------\n" + 
-						"7. ERROR in Outer.java (at line 7)\n" + 
-						"	public void foo(Inner.InnerMost<T> this, Object obj) {}\n" + 
-						"	                ^^^^^^^^^^^^^^^\n" + 
-						"The member type Outer.Inner.InnerMost<T> must be qualified with a parameterized type, since it is not static\n" + 
-						"----------\n" + 
-						"8. ERROR in Outer.java (at line 7)\n" + 
-						"	public void foo(Inner.InnerMost<T> this, Object obj) {}\n" + 
-						"	                ^^^^^^^^^^^^^^^\n" + 
-						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
-						"----------\n" +
-						"9. ERROR in Outer.java (at line 11)\n" + 
-						"	public void foo(InnerMost<T> Outer.Inner.InnerMost.this, int i, float f) {}\n" + 
-						"	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-						"The explicit 'this' parameter for a method cannot have a qualifying name\n" + 
-						"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
-	public void test0383913d() {
-		this.runNegativeTest(
-				new String[] {
-						"Outer.java",
-						"import java.lang.annotation.Target;\n" + 
-						"import static java.lang.annotation.ElementType.*;\n" + 
-						"public class Outer {\n" +
-						"    class Inner<K,V> {\n" +
-						"		public Inner(@Missing Outer Outer.this) {}\n" +
-						"        class InnerMost<T> {\n" +
-						"            public void bar() {\n" +
-						"                new AnonymousInner() {\n" +
-						"                    public void foobar(AnonymousInner this) {}\n" +
-						"                };\n" +
-						"            }\n" +
-						"            void bar(int i) {\n" +
-						"                class Local {\n" +
-						"                    public int hashCode(Local this, int k) { return 0; }\n" +
-						"                    public int hashCode(Outer.Local this) { return 0; }\n" +
-						"                }\n" +
-						"            }\n" +
-						"        }\n" +
-						"    }\n" +
-						"    static class StaticNested {\n" +
-						"        public StaticNested(@Marker Outer.StaticNested Outer.StaticNested.this) {}\n" +
-						"    }\n" +
-						"    public static void foo(@Marker Outer this) {}\n" +
-						"    public void foo(@Missing Outer this, int i) {}\n" +
-						"}\n" +
-						"interface AnonymousInner {\n" +
-						"    public void foobar(AnonymousInner this);\n" +
-						"}\n" +
-						"@Target(TYPE_USE)\n" + 
-						"@interface Marker {}",
-
-						"java/lang/annotation/ElementType.java",
-						"package java.lang.annotation;\n" +
-						"public enum ElementType {\n" +
-						"    TYPE,\n" +
-						"    FIELD,\n" +
-						"    METHOD,\n" +
-						"    PARAMETER,\n" +
-						"    CONSTRUCTOR,\n" +
-						"    LOCAL_VARIABLE,\n" +
-						"    ANNOTATION_TYPE,\n" +
-						"    PACKAGE,\n" +
-						"    TYPE_PARAMETER,\n" +
-						"    TYPE_USE\n" +
-						"}\n"
-					},
-							"----------\n" + 
-							"1. ERROR in Outer.java (at line 5)\n" + 
-							"	public Inner(@Missing Outer Outer.this) {}\n" + 
-							"	              ^^^^^^^\n" + 
-							"Missing cannot be resolved to a type\n" + 
-							"----------\n" + 
-							"2. ERROR in Outer.java (at line 9)\n" + 
-							"	public void foobar(AnonymousInner this) {}\n" + 
-							"	                                  ^^^^\n" + 
-							"Explicit \'this\' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
-							"----------\n" + 
-							"3. ERROR in Outer.java (at line 15)\n" + 
-							"	public int hashCode(Outer.Local this) { return 0; }\n" + 
-							"	                    ^^^^^^^^^^^\n" + 
-							"Outer.Local cannot be resolved to a type\n" + 
-							"----------\n" + 
-							"4. ERROR in Outer.java (at line 21)\n" + 
-							"	public StaticNested(@Marker Outer.StaticNested Outer.StaticNested.this) {}\n" + 
-							"	                    ^^^^^^^\n" + 
-							"Type annotations are not allowed on type names used to access static members\n" + 
-							"----------\n" + 
-							"5. ERROR in Outer.java (at line 21)\n" + 
-							"	public StaticNested(@Marker Outer.StaticNested Outer.StaticNested.this) {}\n" + 
-							"	                                                                  ^^^^\n" + 
-							"Explicit \'this\' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
-							"----------\n" + 
-							"6. ERROR in Outer.java (at line 23)\n" + 
-							"	public static void foo(@Marker Outer this) {}\n" + 
-							"	                                     ^^^^\n" + 
-							"Explicit \'this\' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
-							"----------\n" + 
-							"7. ERROR in Outer.java (at line 24)\n" + 
-							"	public void foo(@Missing Outer this, int i) {}\n" + 
-							"	                 ^^^^^^^\n" + 
-							"Missing cannot be resolved to a type\n" + 
-							"----------\n");
-	}
-	public void test0383908() {
-		this.runNegativeTest(
-				new String[]{"X.java",
-				"public class X { \n" +
-				"	void foo(X this) {}\n" +
-				"   void foo() {}\n" +
-				"}\n" +
-				"class Y {\n" +
-				"	void foo(Y this) {}\n" +
-				"	public static void main(String[] args) {\n" +
-				"		new Y().foo();\n" +
-				"	}\n" +
-				"}"}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	void foo(X this) {}\n" + 
-				"	     ^^^^^^^^^^^\n" + 
-				"Duplicate method foo() in type X\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 3)\n" + 
-				"	void foo() {}\n" + 
-				"	     ^^^^^\n" + 
-				"Duplicate method foo() in type X\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested package names.
-	public void test383596() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
-				"public class X {\n" +
-				"}"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 1)\n" + 
-			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	           ^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 1)\n" + 
-			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                        ^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 1)\n" + 
-			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                                           ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested package names.
-	public void test383596a() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
-				"public class X {\n" +
-				"}"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 1)\n" + 
-			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	^^^^^^^\n" + 
-			"Package annotations must be in file package-info.java\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 1)\n" + 
-			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                   ^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 1)\n" + 
-			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                                ^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"4. ERROR in X.java (at line 1)\n" + 
-			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                                                   ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested import names.
-	public void test039b() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
-				"public class X {\n" +
-				"}"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	       ^\n" + 
-			"The import p cannot be resolved\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	          ^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                       ^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"4. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
-			"	                                          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested import names.
-	public void test383596b() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" +
-				"public class X {\n" +
-				"}"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-			"	       ^\n" + 
-			"The import p cannot be resolved\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-			"	          ^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-			"	                       ^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n" + 
-			"4. ERROR in X.java (at line 1)\n" + 
-			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-			"	                                          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested static import names.
-	public void test041() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" +
-						"public class X {\n" +
-						"}"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
-				"	              ^\n" + 
-				"The import p cannot be resolved\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
-				"	                 ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
-				"	                              ^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
-				"	                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested static import names.
-	public void test042() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" +
-						"public class X {\n" +
-						"}"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-				"	              ^\n" + 
-				"The import p cannot be resolved\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-				"	                 ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-				"	                              ^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 1)\n" + 
-				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
-				"	                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit this.
-	// Much water has flown under the bridge. The grammar itself does not allow annotations in qualified name in explicit this.
-	// We now use the production UnannotatableName instead of plain Name. 
-	public void test043() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java",
-				"public class X {\n" +
-				"   class Y {\n" +
-			    "       class Z {\n" +
-				"           Z(X. @Marker Y  Y.this) {\n" +
-				"           }\n" +
-				"       }\n" +
-				"    }\n" +
-				"}"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 4)\n" + 
-			"	Z(X. @Marker Y  Y.this) {\n" + 
-			"	      ^^^^^^\n" + 
-			"Marker cannot be resolved to a type\n" + 
-			"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call -- super form
-	public void test044() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	static X x;\n" +
-						"	public class InnerBar {\n" +
-						"	}\n" +
-						"	public class SubInnerBar extends InnerBar {\n" +
-						"		SubInnerBar() {\n" +
-						"			X.@Marker x. @Marker @Marker @Marker x.super();\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
-				"	  ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
-				"	             ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. WARNING in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
-				"	                                     ^\n" + 
-				"The static field X.x should be accessed in a static way\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call, super form with explicit type arguments
-	public void test045() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	static X x;\n" +
-						"	public class InnerBar {\n" +
-						"	}\n" +
-						"	public class SubInnerBar extends InnerBar {\n" +
-						"		SubInnerBar() {\n" +
-						"			X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
-				"	  ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
-				"	             ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. WARNING in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
-				"	                                     ^\n" + 
-				"The static field X.x should be accessed in a static way\n" + 
-				"----------\n" + 
-				"4. WARNING in X.java (at line 7)\n" + 
-				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
-				"	                                        ^^^^^^\n" + 
-				"Unused type arguments for the non generic constructor X.InnerBar() of type X.InnerBar; it should not be parameterized with arguments <String>\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call - this form
-	public void test046() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	Bar bar;\n" +
-						"	class Bar {\n" +
-						"		//static Bar x;\n" +
-						"		public class InnerBar {\n" +
-						"			InnerBar(Bar x) {\n" +
-						"			}\n" +
-						"		}\n" +
-						"		public class SubInnerBar extends InnerBar {\n" +
-						"			SubInnerBar() {\n" +
-						"				X. @Marker bar.this();\n" +
-						"			}\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 11)\n" + 
-				"	X. @Marker bar.this();\n" + 
-				"	^^^^^^^^^^^^^^\n" + 
-				"Illegal enclosing instance specification for type X.Bar.SubInnerBar\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 11)\n" + 
-				"	X. @Marker bar.this();\n" + 
-				"	^^^^^^^^^^^^^^\n" + 
-				"Cannot make a static reference to the non-static field X.bar\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 11)\n" + 
-				"	X. @Marker bar.this();\n" + 
-				"	   ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-					"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call, this form with explicit type arguments
-	public void test047() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	Bar bar;\n" +
-						"	class Bar {\n" +
-						"		//static Bar x;\n" +
-						"		public class InnerBar {\n" +
-						"			InnerBar(Bar x) {\n" +
-						"			}\n" +
-						"		}\n" +
-						"		public class SubInnerBar extends InnerBar {\n" +
-						"			SubInnerBar() {\n" +
-						"				X.@Marker bar.<String>this();\n" +
-						"			}\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 11)\n" + 
-				"	X.@Marker bar.<String>this();\n" + 
-				"	^^^^^^^^^^^^^\n" + 
-				"Illegal enclosing instance specification for type X.Bar.SubInnerBar\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 11)\n" + 
-				"	X.@Marker bar.<String>this();\n" + 
-				"	^^^^^^^^^^^^^\n" + 
-				"Cannot make a static reference to the non-static field X.bar\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 11)\n" + 
-				"	X.@Marker bar.<String>this();\n" + 
-				"	  ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"4. WARNING in X.java (at line 11)\n" + 
-				"	X.@Marker bar.<String>this();\n" + 
-				"	               ^^^^^^\n" + 
-				"Unused type arguments for the non generic constructor X.Bar.SubInnerBar() of type X.Bar.SubInnerBar; it should not be parameterized with arguments <String>\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in PrimaryNoNewArray
-	public void test048() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	X bar;\n" +
-						"	private void foo(X x) {\n" +
-						"		System.out.println((x. @Marker bar));\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	System.out.println((x. @Marker bar));\n" + 
-				"	                       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified this.
-	public void test049() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	class Y {\n" +
-						"		class Z {\n" +
-						"			void foo() {\n" +
-						"				Object o = X.@Marker Y.this; \n" +
-						"			}\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	Object o = X.@Marker Y.this; \n" + 
-				"	             ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" +
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified super.
-	public void test050() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	public class Y  {\n" +
-						"		public void foo() {\n" +
-						"			X. @Marker Y.super.hashCode();\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	X. @Marker Y.super.hashCode();\n" + 
-				"	   ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in Name.class
-	public void test051() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	public class Y  {\n" +
-						"		public void foo() {\n" +
-						"			Class<?> c = X. @Marker @Illegal Y.class;\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	Class<?> c = X. @Marker @Illegal Y.class;\n" + 
-				"	                ^^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in Name [].class.
-	public void test052() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"	public class Y  {\n" +
-						"		public void foo() {\n" +
-						"			Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" + 
-				"	                ^^^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 4)\n" + 
-				"	Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" + 
-				"	                                   ^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in binary expressions with qualified names.
-	public void test053() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"public class X {\n" +
-						"    static int x;\n" +
-						"    static boolean fb;\n" +
-						"	 public void foo(boolean b) {\n" +
-						"		x = (X.@Marker x * 10);\n" +
-						"		x = (X.@Marker x / 10);\n" +
-						"		x = (X.@Marker x % 10);\n" +
-						"		x = (X.@Marker x + 10);\n" +
-						"		x = (X.@Marker x - 10);\n" +
-						"		x = (X.@Marker x << 10);\n" +
-						"		x = (X.@Marker x >> 10);\n" +
-						"		x = (X.@Marker x >>> 10);\n" +
-						"		b = (X.@Marker x < 10);\n" +
-						"		b = (X.@Marker x > 10);\n" +
-						"		b = (X.@Marker x <= 10);\n" +
-						"		b = (X.@Marker x >= 10);\n" +
-						"		b = (X.@Marker x instanceof Object);\n" +
-						"		b = (X.@Marker x == 10);\n" +
-						"		b = (X.@Marker x != 10);\n" +
-						"		x = (X.@Marker x & 10);\n" +
-						"		x = (X.@Marker x ^ 10);\n" +
-						"		x = (X.@Marker x | 10);\n" +
-						"		fb = (X.@Marker fb && true);\n" +
-						"		fb = (X.@Marker fb || true);\n" +
-						"		x = (X.@Marker fb ? 10 : 10);\n" +
-						"	 }\n" +
-						"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	x = (X.@Marker x * 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 6)\n" + 
-				"	x = (X.@Marker x / 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 7)\n" + 
-				"	x = (X.@Marker x % 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 8)\n" + 
-				"	x = (X.@Marker x + 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"5. ERROR in X.java (at line 9)\n" + 
-				"	x = (X.@Marker x - 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"6. ERROR in X.java (at line 10)\n" + 
-				"	x = (X.@Marker x << 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"7. ERROR in X.java (at line 11)\n" + 
-				"	x = (X.@Marker x >> 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"8. ERROR in X.java (at line 12)\n" + 
-				"	x = (X.@Marker x >>> 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"9. ERROR in X.java (at line 13)\n" + 
-				"	b = (X.@Marker x < 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"10. ERROR in X.java (at line 14)\n" + 
-				"	b = (X.@Marker x > 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"11. ERROR in X.java (at line 15)\n" + 
-				"	b = (X.@Marker x <= 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"12. ERROR in X.java (at line 16)\n" + 
-				"	b = (X.@Marker x >= 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"13. ERROR in X.java (at line 17)\n" + 
-				"	b = (X.@Marker x instanceof Object);\n" + 
-				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Incompatible conditional operand types int and Object\n" + 
-				"----------\n" + 
-				"14. ERROR in X.java (at line 17)\n" + 
-				"	b = (X.@Marker x instanceof Object);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"15. ERROR in X.java (at line 18)\n" + 
-				"	b = (X.@Marker x == 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"16. ERROR in X.java (at line 19)\n" + 
-				"	b = (X.@Marker x != 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"17. ERROR in X.java (at line 20)\n" + 
-				"	x = (X.@Marker x & 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"18. ERROR in X.java (at line 21)\n" + 
-				"	x = (X.@Marker x ^ 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"19. ERROR in X.java (at line 22)\n" + 
-				"	x = (X.@Marker x | 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"20. ERROR in X.java (at line 23)\n" + 
-				"	fb = (X.@Marker fb && true);\n" + 
-				"	        ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"21. ERROR in X.java (at line 24)\n" + 
-				"	fb = (X.@Marker fb || true);\n" + 
-				"	        ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"22. ERROR in X.java (at line 25)\n" + 
-				"	x = (X.@Marker fb ? 10 : 10);\n" + 
-				"	       ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in annotations with qualified names.
-	   This test is disabled. Now the grammar itself forbids annotations in the said place by using the production
-	   AnnotationName ::= '@' UnannotatableName. We don't want to add tests that will be fragile and unstable due to 
-	   syntax. If a construct is provably not parsed at the grammar level, that ought to be good enough.
-	*/
-	public void test054() throws Exception {
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names used as annotation values.
-	public void test055() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"@interface Annot {\n" +
-					"	String bar();\n" +
-					"}\n" +
-					"@Annot(bar = X. @Marker s)\n" +
-					"public class X {\n" +
-					"	final static String s = \"\";\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	@Annot(bar = X. @Marker s)\n" + 
-				"	                ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names that are postfix expressions.
-	public void test056() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"    static int x;\n" +
-					"    int foo() {\n" +
-					"        return X.@Marker x;\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	return X.@Marker x;\n" + 
-				"	         ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names used in array access.
-	public void test057() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"    static int x[];\n" +
-					"    int foo() {\n" +
-					"        return X.@Marker x[0];\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	return X.@Marker x[0];\n" + 
-				"	         ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name with type arguments used in method invocation.
-	public void test058() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"    static X x;\n" +
-					"    int foo() {\n" +
-					"        return X.@Marker x.<String> foo();\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	return X.@Marker x.<String> foo();\n" + 
-				"	         ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. WARNING in X.java (at line 4)\n" + 
-				"	return X.@Marker x.<String> foo();\n" + 
-				"	                    ^^^^^^\n" + 
-				"Unused type arguments for the non generic method foo() of type X; it should not be parameterized with arguments <String>\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in method invocation.
-	public void test059() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"    static X x;\n" +
-					"    int foo() {\n" +
-					"        return X.@Marker x. @Blah foo();\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	return X.@Marker x. @Blah foo();\n" + 
-				"	         ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 4)\n" + 
-				"	return X.@Marker x. @Blah foo();\n" + 
-				"	                    ^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in class instance creation
-	public void test060() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"    static Y y;\n" +
-					"    class Y {\n" +
-					"        class Z {\n" +
-					"            void foo() {\n" +
-					"                Z z = X. @Marker y.new Z();\n" +
-					"            }\n" +
-					"        }\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 6)\n" + 
-				"	Z z = X. @Marker y.new Z();\n" + 
-				"	         ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in class instance creation
-	public void test061() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"    static X x;\n" +
-					"    X getX() {\n" +
-					"        return (X.@Marker x);\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	return (X.@Marker x);\n" + 
-				"	          ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	public void test062() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	public <T> @Marker Object foo() {\n" +
-					"	}\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	public <T> @Marker Object foo() {\n" + 
-				"	           ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	public void test063() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	Object o = @Marker int.class;\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	Object o = @Marker int.class;\n" + 
-				"	           ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	public void test064() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"@interface X {\n" +
-					"	<T> @Marker String foo();\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	<T> @Marker String foo();\n" + 
-				"	    ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 2)\n" + 
-				"	<T> @Marker String foo();\n" + 
-				"	                   ^^^^^\n" + 
-				"Annotation attributes cannot be generic\n" + 
-				"----------\n");
-	}
-	public void test065() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	Object o = new <String> @Marker X();\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. WARNING in X.java (at line 2)\n" + 
-				"	Object o = new <String> @Marker X();\n" + 
-				"	                ^^^^^^\n" + 
-				"Unused type arguments for the non generic constructor X() of type X; it should not be parameterized with arguments <String>\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 2)\n" + 
-				"	Object o = new <String> @Marker X();\n" + 
-				"	                        ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	public void test066() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	Object o = new X().new <String> @Marker X();\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	Object o = new X().new <String> @Marker X();\n" + 
-				"	                                ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 2)\n" + 
-				"	Object o = new X().new <String> @Marker X();\n" + 
-				"	                                ^^^^^^^^^\n" + 
-				"X.X cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test067() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	Object o = x.new <String> @Marker X() {};\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	Object o = x.new <String> @Marker X() {};\n" + 
-				"	           ^\n" + 
-				"x cannot be resolved to a variable\n" + 
-				"----------\n");
-	}
-	public void test068() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	Object o = new <String> @Marker X() {};\n" +
-					"}\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. WARNING in X.java (at line 2)\n" + 
-				"	Object o = new <String> @Marker X() {};\n" + 
-				"	                ^^^^^^\n" + 
-				"Unused type arguments for the non generic constructor X() of type X; it should not be parameterized with arguments <String>\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 2)\n" + 
-				"	Object o = new <String> @Marker X() {};\n" + 
-				"	                        ^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385293
-	public void test069() throws Exception {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"class X<final T> {\n" +
-					"	Object o = (Object) (public X<final String>) null;\n" + 
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	class X<final T> {\n" + 
-				"	        ^^^^^\n" + 
-				"Syntax error on token \"final\", delete this token\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 2)\n" + 
-				"	Object o = (Object) (public X<final String>) null;\n" + 
-				"	                     ^^^^^^\n" + 
-				"Syntax error on token \"public\", delete this token\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 2)\n" + 
-				"	Object o = (Object) (public X<final String>) null;\n" + 
-				"	                              ^^^^^\n" + 
-				"Syntax error on token \"final\", delete this token\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=388085
-	public void test0388085() {
-		this.runNegativeTest(
-				new String[] {"X.java",
-						"class X {\n" +
-						"	public void main() {\n" +
-						"		final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;" +
-						"		one = null;\n" +
-						"	}\n" +
-						"}\n" +
-						"class One<R> {}\n" +
-						"class Two<S> {}\n" +
-						"class Three<T> {}\n" +
-						"class Four<U, V> {}\n"},
-							"----------\n" + 
-							"1. ERROR in X.java (at line 3)\n" + 
-							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-							"	           ^^^^^^\n" + 
-							"Marker cannot be resolved to a type\n" + 
-							"----------\n" + 
-							"2. ERROR in X.java (at line 3)\n" + 
-							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-							"	                                 ^^^^^^\n" + 
-							"Marker cannot be resolved to a type\n" + 
-							"----------\n" + 
-							"3. ERROR in X.java (at line 3)\n" + 
-							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-							"	                                                                      ^^^^^^\n" + 
-							"Marker cannot be resolved to a type\n" + 
-							"----------\n" + 
-							"4. ERROR in X.java (at line 3)\n" + 
-							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-							"	                                                                                              ^^^^^^\n" + 
-							"Marker cannot be resolved to a type\n" + 
-							"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=388085
-	public void test0388085a() {
-		this.runNegativeTest(
-				new String[] {"X.java",
-						"import java.lang.annotation.Target;\n" + 
-						"import static java.lang.annotation.ElementType.*;\n" + 
-						"class X {\n" +
-						"	public void main() {\n" +
-						"		final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;" +
-						"		one = null;\n" +
-						"	}\n" +
-						"}\n" +
-						"class One<R> {}\n" +
-						"class Two<S> {}\n" +
-						"class Three<T> {}\n" +
-						"class Four<U, V> {}\n" +
-						"@interface Marker {}"},
-						"----------\n" + 
-						"1. ERROR in X.java (at line 5)\n" + 
-						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-						"	          ^^^^^^^\n" + 
-						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-						"----------\n" + 
-						"2. ERROR in X.java (at line 5)\n" + 
-						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-						"	                                ^^^^^^^\n" + 
-						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-						"----------\n" + 
-						"3. ERROR in X.java (at line 5)\n" + 
-						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-						"	                                                                     ^^^^^^^\n" + 
-						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-						"----------\n" + 
-						"4. ERROR in X.java (at line 5)\n" + 
-						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
-						"	                                                                                             ^^^^^^^\n" + 
-						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-						"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=390882
-	public void test0390882() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.Target;\n" +
-					"import static java.lang.annotation.ElementType.*;\n" +
-					"public class X {    \n " +
-					"	Object o1 = (@Marker java.lang.Integer) null;   // 1. Right.\n" +
-					"	Object o2 = (java. @Marker lang.Integer) null;  // 2. Wrong.\n" +
-					"	Object o3 = (java.lang. @Marker Integer) null;  // 3. Legal.\n" +
-					"	public void foo(java. @Marker lang.Integer arg) {}\n" +
-					"	public void bar(java.lang. @Marker Integer arg) {}\n" +
-					"	public void foobar(@Marker java.lang.Integer arg) {}\n" +
-					"}\n" +
-					"@Target(TYPE_USE)\n" +
-					"@interface Marker {}\n",
-
-					"java/lang/annotation/ElementType.java",
-					"package java.lang.annotation;\n" +
-					"public enum ElementType {\n" +
-					"    TYPE,\n" +
-					"    FIELD,\n" +
-					"    METHOD,\n" +
-					"    PARAMETER,\n" +
-					"    CONSTRUCTOR,\n" +
-					"    LOCAL_VARIABLE,\n" +
-					"    ANNOTATION_TYPE,\n" +
-					"    PACKAGE,\n" +
-					"    TYPE_PARAMETER,\n" +
-					"    TYPE_USE\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	Object o1 = (@Marker java.lang.Integer) null;   // 1. Right.\n" + 
-				"	             ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 5)\n" + 
-				"	Object o2 = (java. @Marker lang.Integer) null;  // 2. Wrong.\n" + 
-				"	                   ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 7)\n" + 
-				"	public void foo(java. @Marker lang.Integer arg) {}\n" + 
-				"	                      ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 9)\n" + 
-				"	public void foobar(@Marker java.lang.Integer arg) {}\n" + 
-				"	                   ^^^^^^^\n" + 
-				"The annotation @Marker is disallowed for this location\n" + 
-				"----------\n");
-	}
-	public void test0390882a() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.Target;\n" +
-					"import static java.lang.annotation.ElementType.*;\n" +
-					"public class X {    \n " +
-					"	Object o1 = (java. @Marker @Annot lang.Integer) null;  // 1. Wrong.\n" +
-					"	Object o2 = (java.lang. @Marker @Annot Integer) null;  // 2. Legal\n" +
-					"	Object o3 = (java.@lang lang) null;  // 3. Wrong.\n" +
-					"}\n" +
-					"@Target(TYPE_USE)\n" +
-					"@interface Marker {}\n" +
-					"@Target(TYPE_USE)\n" +
-					"@interface Annot {}",
-
-					"java/lang/annotation/ElementType.java",
-					"package java.lang.annotation;\n" +
-					"public enum ElementType {\n" +
-					"    TYPE,\n" +
-					"    FIELD,\n" +
-					"    METHOD,\n" +
-					"    PARAMETER,\n" +
-					"    CONSTRUCTOR,\n" +
-					"    LOCAL_VARIABLE,\n" +
-					"    ANNOTATION_TYPE,\n" +
-					"    PACKAGE,\n" +
-					"    TYPE_PARAMETER,\n" +
-					"    TYPE_USE\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	Object o1 = (java. @Marker @Annot lang.Integer) null;  // 1. Wrong.\n" + 
-				"	                   ^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 6)\n" + 
-				"	Object o3 = (java.@lang lang) null;  // 3. Wrong.\n" + 
-				"	             ^^^^^^^^^^^^^^^\n" + 
-				"java.lang cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void test0390882b() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.Target;\n" +
-					"import static java.lang.annotation.ElementType.*;\n" +
-					"public class X {    \n " +
-					"	Object o1 = (@Marker @Annot java.util.List<String>) null; 	// 1. Wrong.\n" +
-					"	Object o2 = (java. @Marker @Annot lang.Integer[]) null;		// 2. Wrong.\n" +
-					"	Object o3 = (@Marker @Annot java.util.List<String>[]) null; // 3. Wrong.\n" +
-					"	Object o4 = (java.util.List<String> @Marker @Annot []) null; // 4. Right.\n" +
-					"	Object o5 = (java.lang.Integer @Marker @Annot []) null;	// 5. Right.\n" +
-					"}\n" +
-					"@Target(TYPE_USE)\n" +
-					"@interface Marker {}\n" +
-					"@Target(TYPE_USE)\n" +
-					"@interface Annot {}",
-
-					"java/lang/annotation/ElementType.java",
-					"package java.lang.annotation;\n" +
-					"public enum ElementType {\n" +
-					"    TYPE,\n" +
-					"    FIELD,\n" +
-					"    METHOD,\n" +
-					"    PARAMETER,\n" +
-					"    CONSTRUCTOR,\n" +
-					"    LOCAL_VARIABLE,\n" +
-					"    ANNOTATION_TYPE,\n" +
-					"    PACKAGE,\n" +
-					"    TYPE_PARAMETER,\n" +
-					"    TYPE_USE\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	Object o1 = (@Marker @Annot java.util.List<String>) null; 	// 1. Wrong.\n" + 
-				"	             ^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 5)\n" + 
-				"	Object o2 = (java. @Marker @Annot lang.Integer[]) null;		// 2. Wrong.\n" + 
-				"	                   ^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 6)\n" + 
-				"	Object o3 = (@Marker @Annot java.util.List<String>[]) null; // 3. Wrong.\n" + 
-				"	             ^^^^^^^^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385137
-	public void test0385137() {
-		this.runNegativeTest(
-				new String[]{ "A.java",
-				"package p;" +
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"public class A<T> { \n" +
-				"	static class B<T> {" +
-				"		static class C<K, V> {" +
-				"		}	" +
-				"	}\n" +
-				"   public void foo() {\n" +
-				"		Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" +
-				"		Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" +
-				"   }\n" +
-				"}\n" +
-				"@Target(TYPE_USE)\n" + 
-				"@interface Marker {}\n" +
-				"@Target(TYPE_USE)\n" + 
-				"@interface Annot {}\n",
-
-				"java/lang/annotation/ElementType.java",
-				"package java.lang.annotation;\n" +
-				"public enum ElementType {\n" +
-				"    TYPE,\n" +
-				"    FIELD,\n" +
-				"    METHOD,\n" +
-				"    PARAMETER,\n" +
-				"    CONSTRUCTOR,\n" +
-				"    LOCAL_VARIABLE,\n" +
-				"    ANNOTATION_TYPE,\n" +
-				"    PACKAGE,\n" +
-				"    TYPE_PARAMETER,\n" +
-				"    TYPE_USE\n" +
-				"}\n"},
-					"----------\n" + 
-					"1. ERROR in A.java (at line 6)\n" + 
-					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
-					"	            ^^^^^^^^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"2. WARNING in A.java (at line 6)\n" + 
-					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
-					"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-					"A.B.C is a raw type. References to generic type A<T>.B<T>.C<K,V> should be parameterized\n" + 
-					"----------\n" + 
-					"3. ERROR in A.java (at line 6)\n" + 
-					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
-					"	                             ^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"4. ERROR in A.java (at line 7)\n" + 
-					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
-					"	             ^^^^^^^\n" + 
-					"Syntax error, type annotations are illegal here\n" + 
-					"----------\n" + 
-					"5. WARNING in A.java (at line 7)\n" + 
-					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
-					"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-					"A.B.C is a raw type. References to generic type A<T>.B<T>.C<K,V> should be parameterized\n" + 
-					"----------\n" + 
-					"6. ERROR in A.java (at line 7)\n" + 
-					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
-					"	                       ^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"7. ERROR in A.java (at line 7)\n" + 
-					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
-					"	                                 ^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n");
-	}
-	public void test0385137a() {
-		this.runNegativeTest(
-				new String[]{"A.java",
-				"package p;" +
-				"import java.lang.annotation.Target;\n" + 
-				"import static java.lang.annotation.ElementType.*;\n" + 
-				"public class A { \n" +
-				"	static class B<T> {" +
-				"		static class C<K, V> {" +
-				"		}	" +
-				"	}\n" +
-				"   public void foo() {\n" +
-				"		Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" +
-				"		Object o2 = (@Marker @Annot A.@Annot B.C<Integer, String>) null;\n" +
-				"		Object o5 = (@Marker @Annot A.B<String>[]) null;\n" +
-				"   }\n" +
-				"}\n" +
-				"@Target(TYPE_USE)\n" + 
-				"@interface Marker {}\n" +
-				"@Target(TYPE_USE)\n" + 
-				"@interface Annot {}\n",
-
-				"java/lang/annotation/ElementType.java",
-				"package java.lang.annotation;\n" +
-				"public enum ElementType {\n" +
-				"    TYPE,\n" +
-				"    FIELD,\n" +
-				"    METHOD,\n" +
-				"    PARAMETER,\n" +
-				"    CONSTRUCTOR,\n" +
-				"    LOCAL_VARIABLE,\n" +
-				"    ANNOTATION_TYPE,\n" +
-				"    PACKAGE,\n" +
-				"    TYPE_PARAMETER,\n" +
-				"    TYPE_USE\n" +
-				"}\n",
-				},
-				"----------\n" + 
-					"1. ERROR in A.java (at line 6)\n" + 
-					"	Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" + 
-					"	             ^^^^^^^\n" + 
-					"Syntax error, type annotations are illegal here\n" + 
-					"----------\n" + 
-					"2. ERROR in A.java (at line 6)\n" + 
-					"	Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" + 
-					"	                       ^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"3. ERROR in A.java (at line 6)\n" + 
-					"	Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" + 
-					"	                                 ^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"4. ERROR in A.java (at line 7)\n" + 
-					"	Object o2 = (@Marker @Annot A.@Annot B.C<Integer, String>) null;\n" + 
-					"	             ^^^^^^^^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"5. ERROR in A.java (at line 7)\n" + 
-					"	Object o2 = (@Marker @Annot A.@Annot B.C<Integer, String>) null;\n" + 
-					"	                              ^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n" + 
-					"6. ERROR in A.java (at line 8)\n" + 
-					"	Object o5 = (@Marker @Annot A.B<String>[]) null;\n" + 
-					"	             ^^^^^^^^^^^^^^\n" + 
-					"Type annotations are not allowed on type names used to access static members\n" + 
-					"----------\n");
-	}
-	public void testBug391196() {
-		this.runNegativeTest(
-				new String[]{
-					"p/Bug391196.java",
-					"package p;\n" +
-					"public class Bug391196 {\n" +
-					"	@Marker\n" +
-					"	public class X<@Marker @Marker2 T> {\n" +
-					"		@Marker @Marker2 X(@Marker int i) {}\n" +
-					"		@Unresolved X() {}\n" +
-					"	}\n" +
-					"	@Marker\n" +
-					"	enum Color {RED, BLUE}\n" +
-					"	@Marker\n" +
-					"	interface Inter {}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker {}\n" + 
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker2 {}\n" + 
-					"}\n",
-					"java/lang/annotation/ElementType.java",
-					"package java.lang.annotation;\n" +
-					"public enum ElementType {\n" +
-					"    TYPE,\n" +
-					"    FIELD,\n" +
-					"    METHOD,\n" +
-					"    PARAMETER,\n" +
-					"    CONSTRUCTOR,\n" +
-					"    LOCAL_VARIABLE,\n" +
-					"    ANNOTATION_TYPE,\n" +
-					"    PACKAGE,\n" +
-					"    TYPE_PARAMETER,\n" +
-					"    TYPE_USE\n" +
-					"}\n",
-				},
-				"----------\n" + 
-				"1. ERROR in p\\Bug391196.java (at line 6)\n" + 
-				"	@Unresolved X() {}\n" + 
-				"	 ^^^^^^^^^^\n" + 
-				"Unresolved cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void testBug391315() {
-		this.runNegativeTest(
-				new String[]{
-				"X.java",
-				"class X<T> {\n" +
-				"	X<@Marker ?> l;\n" +
-				"	X<@Marker2 ?> l2;\n" +
-				"	X<@Marker3 ?> l3;\n" +
-				"	class Y {\n" +
-				"		void Y1(Y this) {}\n" +
-				"	}\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n" +
-				"@interface Marker3 {}\n",
-				"java/lang/annotation/ElementType.java",
-				"package java.lang.annotation;\n" +
-				"public enum ElementType {\n" +
-				"    TYPE,\n" +
-				"    FIELD,\n" +
-				"    METHOD,\n" +
-				"    PARAMETER,\n" +
-				"    CONSTRUCTOR,\n" +
-				"    LOCAL_VARIABLE,\n" +
-				"    ANNOTATION_TYPE,\n" +
-				"    PACKAGE,\n" +
-				"    TYPE_PARAMETER,\n" +
-				"    TYPE_USE\n" +
-				"}\n"},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	X<@Marker ?> l;\n" + 
-				"	  ^^^^^^^\n" + 
-				"The annotation @Marker is disallowed for this location\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 4)\n" + 
-				"	X<@Marker3 ?> l3;\n" + 
-				"	  ^^^^^^^^\n" + 
-				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
-				"----------\n");
-	}
-	public void testBug391315a() {
-		this.runNegativeTest(
-				new String[]{
-				"X.java",
-				"public class X<@Marker T> {\n" +
-				"	@Marker T t;\n" +
-				"	T t2 = (@Marker T) null;\n" +
-				"}\n" +
-				"class X2<@Marker2 T> {\n" +
-				"	@Marker2 T t;\n" +
-				"	T t2 = (@Marker2 T) null;\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
-				"@interface Marker2 {}",
-				"java/lang/annotation/ElementType.java",
-				"package java.lang.annotation;\n" +
-				"public enum ElementType {\n" +
-				"    TYPE,\n" +
-				"    FIELD,\n" +
-				"    METHOD,\n" +
-				"    PARAMETER,\n" +
-				"    CONSTRUCTOR,\n" +
-				"    LOCAL_VARIABLE,\n" +
-				"    ANNOTATION_TYPE,\n" +
-				"    PACKAGE,\n" +
-				"    TYPE_PARAMETER,\n" +
-				"    TYPE_USE\n" +
-				"}\n"},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 6)\n" + 
-				"	@Marker2 T t;\n" + 
-				"	^^^^^^^^\n" + 
-				"The annotation @Marker2 is disallowed for this location\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 7)\n" + 
-				"	T t2 = (@Marker2 T) null;\n" + 
-				"	        ^^^^^^^^\n" + 
-				"The annotation @Marker2 is disallowed for this location\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391500
-	public void testBug391500() {
-		this.runNegativeTest(
-				new String[]{
-				"X.java",
-				"public class X {\n" +
-				"	class Y {\n" +
-				"		class Z {\n" +
-				"		}\n" +
-				"		Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" +
-				"		Z z3 = new @Marker Z(){};\n" +
-				"	};\n" +
-				"}\n"},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" + 
-				"	            ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 5)\n" + 
-				"	Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" + 
-				"	                            ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 5)\n" + 
-				"	Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" + 
-				"	                                            ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 6)\n" + 
-				"	Z z3 = new @Marker Z(){};\n" + 
-				"	            ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	public void testBug391464() {
-		this.runNegativeTest(
-				new String[]{
-				"X.java",
-				"public class X<T> {\n" +
-				"	public void foo() {\n" +
-				"		Object o = (X @Marker []) null;\n" +
-				"		o = (java.lang.String @Marker []) null;\n" +
-				"		o = (X<String> @Marker []) null;\n" +
-				"		o = (java.util.List<String> @Marker []) null;\n" +
-				"		if (o == null) return;\n" +
-				"	}" +
-				"}\n"},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 3)\n" + 
-				"	Object o = (X @Marker []) null;\n" + 
-				"	               ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 4)\n" + 
-				"	o = (java.lang.String @Marker []) null;\n" + 
-				"	                       ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 5)\n" + 
-				"	o = (X<String> @Marker []) null;\n" + 
-				"	                ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 6)\n" + 
-				"	o = (java.util.List<String> @Marker []) null;\n" + 
-				"	                             ^^^^^^\n" + 
-				"Marker cannot be resolved to a type\n" + 
-				"----------\n");
-	}	
-	public void testBug391464_2() {
-		this.runNegativeTest(
-				new String[]{
-				"X.java",
-				"public class X  {\n" +
-				"	class Y {\n" +
-				"		class Z {}\n" +
-				"	}\n" +
-				"	@M X.@M Y.@Unreported Z z = null;\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface M {\n" +
-				"}\n",
-				
-				"java/lang/annotation/ElementType.java",
-				"package java.lang.annotation;\n" +
-				"public enum ElementType {\n" +
-				"    TYPE,\n" +
-				"    FIELD,\n" +
-				"    METHOD,\n" +
-				"    PARAMETER,\n" +
-				"    CONSTRUCTOR,\n" +
-				"    LOCAL_VARIABLE,\n" +
-				"    ANNOTATION_TYPE,\n" +
-				"    PACKAGE,\n" +
-				"    TYPE_PARAMETER,\n" +
-				"    TYPE_USE\n" +
-				"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	@M X.@M Y.@Unreported Z z = null;\n" + 
-				"	           ^^^^^^^^^^\n" + 
-				"Unreported cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391108
-	public void testBug391108() {
-		this.runNegativeTest(
-				new String[]{
-						"X.java",
-						"public class X {\n" +
-						"	@Marker @Marker2 @Marker3 public void foo() {}\n" +
-						"	@Marker @Marker2 @Marker3 void foo2() {}\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.METHOD)\n" +
-						"@interface Marker2 {}\n" +
-						"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.METHOD})\n" +
-						"@interface Marker3 {}",
-						"java/lang/annotation/ElementType.java",
-						"package java.lang.annotation;\n" +
-						"public enum ElementType {\n" +
-						"    TYPE,\n" +
-						"    FIELD,\n" +
-						"    METHOD,\n" +
-						"    PARAMETER,\n" +
-						"    CONSTRUCTOR,\n" +
-						"    LOCAL_VARIABLE,\n" +
-						"    ANNOTATION_TYPE,\n" +
-						"    PACKAGE,\n" +
-						"    TYPE_PARAMETER,\n" +
-						"    TYPE_USE\n" +
-						"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 2)\n" + 
-				"	@Marker @Marker2 @Marker3 public void foo() {}\n" + 
-				"	^^^^^^^\n" + 
-				"Type annotation is illegal for a method that returns void\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 3)\n" + 
-				"	@Marker @Marker2 @Marker3 void foo2() {}\n" + 
-				"	^^^^^^^\n" + 
-				"Type annotation is illegal for a method that returns void\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392119
-	public void test392119() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java", //-----------------------------------------------------------------------
-				"@Marker78 @Marker8 @Marker7\n" +
-				"public class X {\n" +
-				"    Zork z;\n" +
-				"}\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.TYPE})\n" +
-				"@interface Marker78 {\n" +
-				"}\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE})\n" +
-				"@interface Marker7 {\n" +
-				"}\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})\n" +
-				"@interface Marker8 {\n" +
-				"}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 3)\n" + 
-			"	Zork z;\n" + 
-			"	^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n",
-			null,
-			true, // flush output
-			null,
-			true, // generate output
-			false,
-			false);
-		String expectedOutput =
-				"  RuntimeInvisibleAnnotations: \n" + 
-				"    #24 @Marker78(\n" + 
-				"    )\n" + 
-				"    #25 @Marker8(\n" + 
-				"    )\n" + 
-				"    #26 @Marker7(\n" + 
-				"    )\n" + 
-				"  Attribute: MissingTypes Length: 4\n" + 
-				"}";
-		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392119, variant with explicit class file retention.
-	public void test392119b() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java", //-----------------------------------------------------------------------
-				"@Marker78 @Marker8 @Marker7\n" +
-				"public class X {\n" +
-				"    Zork z;\n" +
-				"}\n" +
-				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.TYPE})\n" +
-				"@interface Marker78 {\n" +
-				"}\n" +
-				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE})\n" +
-				"@interface Marker7 {\n" +
-				"}\n" +
-				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})\n" +
-				"@interface Marker8 {\n" +
-				"}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 3)\n" + 
-			"	Zork z;\n" + 
-			"	^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n",
-			null,
-			true, // flush output
-			null,
-			true, // generate output
-			false,
-			false);
-		String expectedOutput =
-				"  RuntimeInvisibleAnnotations: \n" + 
-				"    #24 @Marker78(\n" + 
-				"    )\n" + 
-				"    #25 @Marker8(\n" + 
-				"    )\n" + 
-				"    #26 @Marker7(\n" + 
-				"    )\n" + 
-				"  Attribute: MissingTypes Length: 4\n" + 
-				"}";
-		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392119, variant with explicit runtime retention.
-	public void test392119c() throws Exception {
-		this.runNegativeTest(
-			new String[] {
-				"X.java", //-----------------------------------------------------------------------
-				"@Marker78 @Marker8 @Marker7\n" +
-				"public class X {\n" +
-				"    Zork z;\n" +
-				"}\n" +
-				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.TYPE})\n" +
-				"@interface Marker78 {\n" +
-				"}\n" +
-				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE})\n" +
-				"@interface Marker7 {\n" +
-				"}\n" +
-				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
-				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})\n" +
-				"@interface Marker8 {\n" +
-				"}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 3)\n" + 
-			"	Zork z;\n" + 
-			"	^^^^\n" + 
-			"Zork cannot be resolved to a type\n" + 
-			"----------\n",
-			null,
-			true, // flush output
-			null,
-			true, // generate output
-			false,
-			false);
-		String expectedOutput =
-				"  RuntimeVisibleAnnotations: \n" + 
-				"    #24 @Marker78(\n" + 
-				"    )\n" + 
-				"    #25 @Marker8(\n" + 
-				"    )\n" + 
-				"    #26 @Marker7(\n" + 
-				"    )\n";
-		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=394355
-	public void testBug394355() {
-		this.runNegativeTest(
-			new String[]{
-				"X.java",
-				"import java.lang.annotation.Target;\n" +
-				"import static java.lang.annotation.ElementType.*;\n" +
-				"public class X {\n" +
-				"	public void foo(@Marker @Marker2 X this) {}\n" +
-				"	class Y {\n" +
-				"		Y(@Marker @Marker2 X X.this) {}\n" +
-				"	}\n" +
-				"}\n" +
-				"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@Target ({METHOD, PARAMETER, TYPE, PACKAGE, FIELD, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER})\n" +
-				"@interface Marker2 {}",
-				"java/lang/annotation/ElementType.java",
-				"package java.lang.annotation;\n" +
-				"public enum ElementType {\n" +
-				"    TYPE,\n" +
-				"    FIELD,\n" +
-				"    METHOD,\n" +
-				"    PARAMETER,\n" +
-				"    CONSTRUCTOR,\n" +
-				"    LOCAL_VARIABLE,\n" +
-				"    ANNOTATION_TYPE,\n" +
-				"    PACKAGE,\n" +
-				"    TYPE_PARAMETER,\n" +
-				"    TYPE_USE\n" +
-				"}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 4)\n" + 
-			"	public void foo(@Marker @Marker2 X this) {}\n" + 
-			"	                        ^^^^^^^^\n" + 
-			"The annotation @Marker2 is disallowed for this location\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 6)\n" + 
-			"	Y(@Marker @Marker2 X X.this) {}\n" + 
-			"	          ^^^^^^^^\n" + 
-			"The annotation @Marker2 is disallowed for this location\n" + 
-			"----------\n"); 
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399453
-	public void testBug399453() {
-		this.runNegativeTest(
-				new String[]{
-					"X.java",
-					"import java.lang.annotation.Target;\n" +
-					"import static java.lang.annotation.ElementType.*;\n" +
-					"public class X {\n" +
-					"	public void foo() {\n" +
-					"		int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] @Marker @Marker2 [];\n" +
-					"		int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker X.bar2(2)] @Marker @Marker2 [];\n" +
-					"	}\n" +
-					"	public int bar() {\n" +
-					"		return 2;\n" +
-					"	}\n" +
-					"	public static int bar2(int k) {\n" +
-					"		return k;\n" + 
-					"	}\n" +
-					"}\n" +
-					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker {}\n" +
-					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker2 {}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] @Marker @Marker2 [];\n" + 
-				"	                                                                               ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 6)\n" + 
-				"	int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker X.bar2(2)] @Marker @Marker2 [];\n" + 
-				"	                                                                               ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n"); 
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399453
-	public void testBug391894() {
-		this.runNegativeTest(
-				new String[]{
-					"X.java",
-					"import java.lang.annotation.Target;\n" +
-					"import static java.lang.annotation.ElementType.*;\n" +
-					"public class X {\n" +
-					"	public void foo() {\n" +
-					"		int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" +
-					"		int @Marker [] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" +
-					"	}\n" +
-					"	public int bar() {\n" +
-					"		return 2;\n" +
-					"	}\n" +
-					"}\n" +
-					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker {}\n" +
-					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker2 {}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 5)\n" + 
-				"	int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
-				"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Type mismatch: cannot convert from int[][] to int[][][]\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 5)\n" + 
-				"	int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
-				"	                                                                               ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 6)\n" + 
-				"	int @Marker [] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
-				"	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Type mismatch: cannot convert from int[][] to int[]\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 6)\n" + 
-				"	int @Marker [] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
-				"	                                                                           ^^^^^^^\n" + 
-				"Syntax error, type annotations are illegal here\n" + 
-				"----------\n"); 
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=402618, [1.8][compiler] Compiler fails to resolve type annotations on method/constructor references
-	public void test402618() {
-		this.runNegativeTest(
-				new String[]{
-					"X.java",
-					"import java.util.List;\n" +
-					"interface I {\n" +
-					"	void foo(List<String> l);\n" +
-					"}\n" +
-					"\n" +
-					"public class X {\n" +
-					"	public void main(String[] args) {\n" +
-					"		I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" +
-					"	}\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 8)\n" + 
-				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
-				"	       ^^^^^^^^\n" + 
-				"Readonly cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 8)\n" + 
-				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
-				"	                      ^^^^^^^\n" + 
-				"English cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"3. WARNING in X.java (at line 8)\n" + 
-				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
-				"	                                        ^^^^^^^^^^^^^^^^^^^^\n" + 
-				"Unused type arguments for the non generic method size() of type List<String>; it should not be parameterized with arguments <Integer>\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 8)\n" + 
-				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
-				"	                                         ^^^^^^^^^^^\n" + 
-				"NonNegative cannot be resolved to a type\n" + 
-				"----------\n"); 
-		}
-	public void testBug403132() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X {\n" +
-					"	class Y {\n" +
-					"		class Z {\n" +
-					"			public Z (@A X.@B Y Y.this, String str) {}\n" +
-					"    	 	public void foo (@A X.@B Y.@C Z this, String str) {}\n" +
-					"		}\n" +
-					"    }\n" +
-					"}\n"
-				}, 
-				"----------\n" + 
-				"1. ERROR in X.java (at line 4)\n" + 
-				"	public Z (@A X.@B Y Y.this, String str) {}\n" + 
-				"	           ^\n" + 
-				"A cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 4)\n" + 
-				"	public Z (@A X.@B Y Y.this, String str) {}\n" + 
-				"	                ^\n" + 
-				"B cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 5)\n" + 
-				"	public void foo (@A X.@B Y.@C Z this, String str) {}\n" + 
-				"	                  ^\n" + 
-				"A cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 5)\n" + 
-				"	public void foo (@A X.@B Y.@C Z this, String str) {}\n" + 
-				"	                       ^\n" + 
-				"B cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"5. ERROR in X.java (at line 5)\n" + 
-				"	public void foo (@A X.@B Y.@C Z this, String str) {}\n" + 
-				"	                            ^\n" + 
-				"C cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403410
-	public void testBug403410() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.Target;\n" +
-					"import static java.lang.annotation.ElementType.*;\n" +
-					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface A {}\n" +
-					"public class X {\n" +
-					"	class Y {\n" +
-					"		public Y (final @A X X.this) {}\n" +
-					"		public Y (static @A X X.this, int i) {}\n" +
-					"		public void foo(final @A Y this) {}\n" +
-					"		public void foo(static @A Y this, int i) {}\n" +
-					"}\n}"},
-					"----------\n" + 
-					"1. ERROR in X.java (at line 7)\n" + 
-					"	public Y (final @A X X.this) {}\n" + 
-					"	          ^^^^^^^^^^^^^^^^^\n" + 
-					"Syntax error, modifiers are not allowed here\n" + 
-					"----------\n" +
-					"2. ERROR in X.java (at line 8)\n" + 
-					"	public Y (static @A X X.this, int i) {}\n" + 
-					"	          ^^^^^^^^^^^^^^^^^^\n" + 
-					"Syntax error, modifiers are not allowed here\n" + 
-					"----------\n" + 
-					"3. ERROR in X.java (at line 9)\n" + 
-					"	public void foo(final @A Y this) {}\n" + 
-					"	                ^^^^^^^^^^^^^^^\n" + 
-					"Syntax error, modifiers are not allowed here\n" + 
-					"----------\n" + 
-					"4. ERROR in X.java (at line 10)\n" + 
-					"	public void foo(static @A Y this, int i) {}\n" + 
-					"	                ^^^^^^^^^^^^^^^^\n" + 
-					"Syntax error, modifiers are not allowed here\n" + 
-					"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403581,  [1.8][compiler] Compile error on varargs annotations.
-	public void test403581() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.util.List;\n" +
-					"public class X {\n" +
-					"	void foo(List<String> @Marker ... ls) {}\n" +
-					"}\n" +
-					"@java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker {\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. WARNING in X.java (at line 3)\n" + 
-				"	void foo(List<String> @Marker ... ls) {}\n" + 
-				"	                                  ^^\n" + 
-				"Type safety: Potential heap pollution via varargs parameter ls\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392671, [1.8][recovery] NPE with a method with explicit this and a following incomplete parameter
-	public void test392671() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"class X {\n" +
-					"    public void foobar(X this, int, int k) {} // NPE!\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	class X {\n" + 
-				"	        ^\n" + 
-				"Syntax error, insert \"}\" to complete ClassBody\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 2)\n" + 
-				"	public void foobar(X this, int, int k) {} // NPE!\n" + 
-				"	                           ^^^\n" + 
-				"Syntax error, insert \"... VariableDeclaratorId\" to complete FormalParameter\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 3)\n" + 
-				"	}\n" + 
-				"	^\n" + 
-				"Syntax error on token \"}\", delete this token\n" + 
-				"----------\n");
-	}
-	// [1.8][compiler] Missing expected error for incorrect placement of type annotation (https://bugs.eclipse.org/bugs/show_bug.cgi?id=406587)
-	public void test406587() {
-		this.runNegativeTest(
-				new String[] {
-					"p/X.java",
-					"package p;\n" +
-					"import java.lang.annotation.*;\n" +
-					"public class X {\n" +
-					"	@B(1) @A(1) String field1;\n" +
-					"	@B @A X.Y field3;\n" +
-					"	@A @B p.X.Y field4;\n" +
-					"	@B(1) @A(1) java.lang.@A(1) @B(1) String field2;\n" +
-					"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" +
-					"		@A(1) @B(1)  String local1;\n" +
-					"		@A(1) @B(1) java.lang.  @B(1) @A(1) String local2;\n" +
-					"		@B @A X.Y local3;\n" +
-					"		@B @A p.X.Y local4;\n" +
-					"		@B @A p.q.X local5;\n" +
-					"		return null;\n" +
-					"	}\n" +
-					"	class Y {}" +
-					"}\n" +
-					"@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\n" +
-					"@interface A {\n" +
-					"	int value() default -1;\n" +
-					"}\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface B {\n" +
-					"	int value() default -1;\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in p\\X.java (at line 6)\n" + 
-				"	@A @B p.X.Y field4;\n" + 
-				"	   ^^\n" + 
-				"The annotation @B is disallowed for this location\n" + 
-				"----------\n" + 
-				"2. ERROR in p\\X.java (at line 7)\n" + 
-				"	@B(1) @A(1) java.lang.@A(1) @B(1) String field2;\n" + 
-				"	^^\n" + 
-				"The annotation @B is disallowed for this location\n" + 
-				"----------\n" + 
-				"3. ERROR in p\\X.java (at line 7)\n" + 
-				"	@B(1) @A(1) java.lang.@A(1) @B(1) String field2;\n" + 
-				"	                      ^^\n" + 
-				"The annotation @A is disallowed for this location\n" + 
-				"----------\n" + 
-				"4. ERROR in p\\X.java (at line 8)\n" + 
-				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
-				"	       ^^\n" + 
-				"The annotation @B is disallowed for this location\n" + 
-				"----------\n" + 
-				"5. ERROR in p\\X.java (at line 8)\n" + 
-				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
-				"	                              ^^\n" + 
-				"The annotation @A is disallowed for this location\n" + 
-				"----------\n" + 
-				"6. ERROR in p\\X.java (at line 8)\n" + 
-				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
-				"	                                                            ^^\n" + 
-				"The annotation @B is disallowed for this location\n" + 
-				"----------\n" + 
-				"7. ERROR in p\\X.java (at line 8)\n" + 
-				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
-				"	                                                                             ^^\n" + 
-				"The annotation @A is disallowed for this location\n" + 
-				"----------\n" + 
-				"8. ERROR in p\\X.java (at line 10)\n" + 
-				"	@A(1) @B(1) java.lang.  @B(1) @A(1) String local2;\n" + 
-				"	      ^^\n" + 
-				"The annotation @B is disallowed for this location\n" + 
-				"----------\n" + 
-				"9. ERROR in p\\X.java (at line 10)\n" + 
-				"	@A(1) @B(1) java.lang.  @B(1) @A(1) String local2;\n" + 
-				"	                              ^^\n" + 
-				"The annotation @A is disallowed for this location\n" + 
-				"----------\n" + 
-				"10. ERROR in p\\X.java (at line 12)\n" + 
-				"	@B @A p.X.Y local4;\n" + 
-				"	^^\n" + 
-				"The annotation @B is disallowed for this location\n" + 
-				"----------\n" + 
-				"11. ERROR in p\\X.java (at line 13)\n" + 
-				"	@B @A p.q.X local5;\n" + 
-				"	      ^^^\n" + 
-				"p.q cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417076, Eclipse compiler rejects multiple annotations for varargs.
-	public void test417076() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface A {\n" +
-					"}\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface B {\n" +
-					"}\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface C {\n" +
-					"}\n" +
-					"public class X {\n" +
-					"	public @A String foo(int @B @C @D ... args) {\n" +
-					"	      return null;\n" +
-					"	}\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 13)\n" + 
-				"	public @A String foo(int @B @C @D ... args) {\n" + 
-				"	                                ^\n" + 
-				"D cannot be resolved to a type\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417076, Eclipse compiler rejects multiple annotations for varargs.
-	public void test417076b() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface A {\n" +
-					"}\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface B {\n" +
-					"}\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface C {\n" +
-					"}\n" +
-					"public class X {\n" +
-					"	public @A String foo(int @B @C @A ... args) {\n" +
-					"	      return null;\n" +
-					"	}\n" +
-					"	public @A String goo(int @B @C @A ... args) {\n" +
-					"	}\n" +
-					"}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 16)\n" + 
-				"	public @A String goo(int @B @C @A ... args) {\n" + 
-				"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-				"This method must return a result of type String\n" + 
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// This is the basic test case which demonstrated the issue for a local variable.
-	// We correctly identified the problem in function bar but failed to do so for foo.
-	public void test415308a() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface Illegal {\n" +
-					"}\n" +
-					"class Y {\n" +
-					"	static class Z {\n" +
-					"		Z() {}\n" +
-					"	}\n" +
-					"}\n" +
-					"class X {\n" +
-					"	Y.Z foo() {\n" +
-					"		@Illegal Y.Z z = null;\n" +
-					"		return z;\n" +
-					"	}\n" +
-					"	Y.Z bar() {\n" +
-					"		Y.Z z = (@Illegal Y.Z)null;\n" +
-					"		return z;\n" +
-					"	}\n" +
-					"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 14)\n" +
-				"	@Illegal Y.Z z = null;\n" +
-				"	^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n" +
-				"2. ERROR in X.java (at line 18)\n" +
-				"	Y.Z z = (@Illegal Y.Z)null;\n" +
-				"	         ^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// This test case is similar to test415308a. SimpleTypes on which annotations are applied are modified to array
-	// types.
-	public void test415308a2() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class Z {\n" +
-						"		Z() {}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"	Y.Z[] foo() {\n" +
-						"		@Illegal Y.Z[] z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.Z[] bar() {\n" +
-						"		Y.Z[] z = (@Illegal Y.Z[])null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 14)\n" +
-				"	@Illegal Y.Z[] z = null;\n" +
-				"	^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n" +
-				"2. ERROR in X.java (at line 18)\n" +
-				"	Y.Z[] z = (@Illegal Y.Z[])null;\n" +
-				"	           ^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// Testing type use annotations on nested types.
-	// We check all the qualifiers as we look for a static type. This test checks if we are able to
-	// go beyond 1 level as part of the loop.
-	public void test415308b() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class YY {\n" +
-						"		class Z {\n" +
-						"			Z() {}\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"	Y.YY.Z foo() {\n" +
-						"		@Illegal Y.YY.Z z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.YY.Z foo2() {\n" +
-						"		Y.@Illegal YY.Z z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.YY.Z foo3() {\n" +
-						"		Y.YY.@Illegal Z z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 16)\n" +
-				"	@Illegal Y.YY.Z z = null;\n" +
-				"	^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// This test case is similar to test415308a. SimpleTypes on which annotations are applied are modified to array
-	// types.
-	public void test415308b2() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class YY {\n" +
-						"		class Z {\n" +
-						"			Z() {}\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"	Y.YY.Z[] foo() {\n" +
-						"		@Illegal Y.YY.Z[] z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.YY.Z[] foo2() {\n" +
-						"		Y.@Illegal YY.Z[] z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.YY.Z[] foo3() {\n" +
-						"		Y.YY.@Illegal Z[] z = null;\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 16)\n" +
-				"	@Illegal Y.YY.Z[] z = null;\n" +
-				"	^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// The test case is to validate that we report errors for only type annotations and nothing else in case of
-	// of parameter types.
-	public void test415308c() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface IllegalTypeUse {\n" +
-						"}\n" +
-						"@Target({ElementType.TYPE_USE, ElementType.PARAMETER})\n" +
-						"@interface LegalTypeUseParam {\n" +
-						"}\n" +
-						"@Target(ElementType.PARAMETER)\n" +
-						"@interface LegalParam {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class Z {\n" +
-						"		Z() {}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"	Y.Z foo(@LegalParam Y.Z z) { //Legal\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.Z foo2(@LegalTypeUseParam Y.Z z) { //Legal\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"	Y.Z foo3(@IllegalTypeUse @LegalParam Y.Z z) { //Illegal\n" +
-						"		return z;\n" +
-						"	}\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 25)\n" +
-				"	Y.Z foo3(@IllegalTypeUse @LegalParam Y.Z z) { //Illegal\n" +
-				"	         ^^^^^^^^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	//[1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	//The test case is to validate type use annotation for class fields.
-	public void test415308d() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class Z {\n" +
-						"		Z() {}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"   @Illegal \n" +
-						"	Y.Z z;\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 13)\n" +
-				"	@Illegal \n" +
-				"	^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	//[1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	//The test case checks for annotations which are not exclusively TYPE_USE. We should not report a error.
-	public void test415308d2() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target({ElementType.TYPE_USE, ElementType.FIELD})\n" +
-						"@interface Legal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class Z {\n" +
-						"		Z() {}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"   @Legal \n" +
-						"	Y.Z z;\n" +
-						"}\n"
-				},
-				"");
-	}
-	//[1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	//The test case is to validate type use annotation for class fields.
-	//We check all the qualifiers as we look for a static type. This test checks if we are able to
-	//go beyond 1 level as part of the loop.
-	public void test415308e() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal2 {\n" +
-						"}\n" +
-						"@Target(ElementType.FIELD)\n" +
-						"@interface Legal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class YY {\n" +
-						"		class Z {\n" +
-						"			Z() {}\n" +
-						"		}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"   @Legal @Illegal @Illegal2\n" +
-						"	Y.YY.Z z;\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 21)\n" +
-				"	@Legal @Illegal @Illegal2\n" +
-				"	       ^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n" +
-				"2. ERROR in X.java (at line 21)\n" +
-				"	@Legal @Illegal @Illegal2\n" +
-				"	                ^^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// The test case is to validate type use annotations on return types for methods.
-	public void test415308f() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class Z {\n" +
-						"		Z() {}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"   public @Illegal Y.Z foo() { return null;}\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 13)\n" +
-				"	public @Illegal Y.Z foo() { return null;}\n" +
-				"	       ^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// The test case is a array version of test415308f.
-	public void test415308f2() {
-		this.runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface Illegal {\n" +
-						"}\n" +
-						"class Y {\n" +
-						"	static class Z {\n" +
-						"		Z() {}\n" +
-						"	}\n" +
-						"}\n" +
-						"class X {\n" +
-						"   public @Illegal Y.Z[] foo() { return null;}\n" +
-						"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 13)\n" +
-				"	public @Illegal Y.Z[] foo() { return null;}\n" +
-				"	       ^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
-	// The test case is used to test enums with type annotations.
-	public void test415308g() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface Illegal {\n" +
-					"}\n" +
-					"class Y {\n" +
-					"	enum A { B }\n" +
-					"}\n" +
-					"class X {\n" +
-					"	@Illegal Y.A foo(@Illegal Y.A a) {\n" +
-					"		return a;\n" +
-					"	}\n" +
-					"}\n"
-				},
-				"----------\n" +
-				"1. ERROR in X.java (at line 11)\n" +
-				"	@Illegal Y.A foo(@Illegal Y.A a) {\n" +
-				"	^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n" +
-				"2. ERROR in X.java (at line 11)\n" +
-				"	@Illegal Y.A foo(@Illegal Y.A a) {\n" +
-				"	                 ^^^^^^^^\n" +
-				"Type annotations are not allowed on type names used to access static members\n" +
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418041, NPE during AST creation.
-	public void test418041() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"import java.util.List;\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface Readonly {\n" +
-					"}\n" +
-					"class UnmodifiableList<T> implements\n" +
-					"@Readonly List<@Readonly T> { }\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.addAll(int, Collection<? extends T>)\n" + 
-				"----------\n" + 
-				"2. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.addAll(Collection<? extends T>)\n" + 
-				"----------\n" + 
-				"3. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.lastIndexOf(Object)\n" + 
-				"----------\n" + 
-				"4. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.subList(int, int)\n" + 
-				"----------\n" + 
-				"5. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.contains(Object)\n" + 
-				"----------\n" + 
-				"6. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.get(int)\n" + 
-				"----------\n" + 
-				"7. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.retainAll(Collection<?>)\n" + 
-				"----------\n" + 
-				"8. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.clear()\n" + 
-				"----------\n" + 
-				"9. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.indexOf(Object)\n" + 
-				"----------\n" + 
-				"10. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.toArray(T[])\n" + 
-				"----------\n" + 
-				"11. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.toArray()\n" + 
-				"----------\n" + 
-				"12. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.isEmpty()\n" + 
-				"----------\n" + 
-				"13. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.listIterator(int)\n" + 
-				"----------\n" + 
-				"14. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.listIterator()\n" + 
-				"----------\n" + 
-				"15. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.add(int, T)\n" + 
-				"----------\n" + 
-				"16. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.add(T)\n" + 
-				"----------\n" + 
-				"17. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.set(int, T)\n" + 
-				"----------\n" + 
-				"18. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.size()\n" + 
-				"----------\n" + 
-				"19. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.containsAll(Collection<?>)\n" + 
-				"----------\n" + 
-				"20. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.remove(int)\n" + 
-				"----------\n" + 
-				"21. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.remove(Object)\n" + 
-				"----------\n" + 
-				"22. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.removeAll(Collection<?>)\n" + 
-				"----------\n" + 
-				"23. ERROR in X.java (at line 7)\n" + 
-				"	class UnmodifiableList<T> implements\n" + 
-				"	      ^^^^^^^^^^^^^^^^\n" + 
-				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.iterator()\n" + 
-				"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418041, NPE during AST creation.
-	public void test418041a() {
-		this.runNegativeTest(
-				new String[] {
-					"X.java",
-					"public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {\n" +
-					"}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker {}\n"
-				},
-				"----------\n" + 
-				"1. ERROR in X.java (at line 1)\n" + 
-				"	public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {\n" + 
-				"	                                          ^\n" +
-				"Y cannot be resolved to a type\n" + 
-				"----------\n" + 
-				"2. WARNING in X.java (at line 1)\n" + 
-				"	public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {\n" + 
-				"	                                                                          ^^^^^^^^^^^^^^^\n" + 
-				"The type parameter Q should not be bounded by the final type Integer. Final types cannot be further extended\n" + 
-				"----------\n");
-	}
-	public void testWildcardCapture() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"import java.util.List;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface NonNull {\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface Nullable {\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	public static void main(String[] args) {\n" +
-				"		List<@Nullable ? extends X> lx1 = null;\n" +
-				"		List<@NonNull ? extends X> lx2 = null;\n" +
-				"		lx1 = lx2;\n" +
-				"		lx1.add(lx2.get(0));\n" +
-				"		lx1.add(lx1.get(0));\n" +
-				"       getAdd(lx1, lx2);\n" +
-				"	}\n" +
-				"	static <@NonNull P>  void getAdd(List<P> p1, List<P> p2) {\n" +
-				"		p1.add(p2.get(0));\n" +
-				"	}\n" +
-				"}\n"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 18)\n" + 
-			"	lx1.add(lx2.get(0));\n" + 
-			"	    ^^^\n" + 
-			"The method add(capture#3-of ? extends X) in the type List<capture#3-of ? extends X> is not applicable for the arguments (capture#4-of ? extends X)\n" + 
-			"----------\n" + 
-			"2. ERROR in X.java (at line 19)\n" + 
-			"	lx1.add(lx1.get(0));\n" + 
-			"	    ^^^\n" + 
-			"The method add(capture#5-of ? extends X) in the type List<capture#5-of ? extends X> is not applicable for the arguments (capture#6-of ? extends X)\n" + 
-			"----------\n" + 
-			"3. ERROR in X.java (at line 20)\n" + 
-			"	getAdd(lx1, lx2);\n" + 
-			"	^^^^^^\n" + 
-			"The method getAdd(List<P>, List<P>) in the type X is not applicable for the arguments (List<capture#7-of ? extends X>, List<capture#8-of ? extends X>)\n" + 
-			"----------\n");		
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=414038, [1.8][compiler] CCE in resolveAnnotations
-	public void testBug414038() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.*;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface NonNull { int[].class value() default 0;}\n" +
-				"public class X extends @NonNull() Object {    \n" +
-				"    public static int i = 0; \n" +
-				"}\n"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 3)\n" + 
-			"	@interface NonNull { int[].class value() default 0;}\n" + 
-			"	                          ^^^^^^\n" + 
-			"Syntax error on tokens, delete these tokens\n" + 
-			"----------\n");		
-	}	
-	public void testGenericConstructor() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.Annotation;\n" +
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"} \n" +
-				"public class X { \n" +
-				"\n" +
-				"	<P> @T X() {\n" +
-				"	}\n" +
-				"   @T <P> X(X x) {\n" +
-				"   }\n" +
-				"}\n"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 9)\n" + 
-			"	<P> @T X() {\n" + 
-			"	    ^\n" + 
-			"Syntax error on token \"@\", delete this token\n" + 
-			"----------\n");		
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419833, [1.8] NPE in CompilationUnitProblemFinder and ASTNode
-	public void test419833() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.Target;\n" +
-				"import java.lang.annotation.ElementType;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n" +
-				"class S {\n" +
-				"}\n" +
-				"interface I {\n" +
-				"}\n" +
-				"public class X extends @T S implements @T  {\n" +
-				"	public int foo() {\n" +
-				"       return 0;\n" +
-				"	}	\n" +
-				"}\n"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 10)\n" + 
-			"	public class X extends @T S implements @T  {\n" + 
-			"	                                       ^\n" + 
-			"Syntax error on token \"@\", delete this token\n" + 
-			"----------\n");		
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420038,  [1.8][compiler] Tolerate type annotations on array dimensions of class literals for now for compatibility. 
-	public void test420038() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	public static void main(String[] args) {\n" +
-				"		Class<?> c = int @T [].class; \n" +
-				"	}\n" +
-				"}\n"
-			}, 
-			"----------\n" + 
-			"1. WARNING in X.java (at line 8)\n" + 
-			"	Class<?> c = int @T [].class; \n" + 
-			"	                 ^^\n" + 
-			"Syntax error, type annotations are illegal here\n" + 
-			"----------\n");		
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420284, [1.8][compiler] IllegalStateException from TypeSystem.cacheDerivedType 
-	public void test420284() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.io.Serializable;\n" +
-				"import java.util.List;\n" +
-				"public class X {\n" +
-				"    void foo(Object o) {\n" +
-				"        Integer i = (Integer & Serializable) o;\n" +
-				"        List<@NonNull Integer> l;\n" +
-				"    }\n" +
-				"}\n"
-			}, 
-			"----------\n" + 
-			"1. ERROR in X.java (at line 6)\n" + 
-			"	List<@NonNull Integer> l;\n" + 
-			"	      ^^^^^^^\n" + 
-			"NonNull cannot be resolved to a type\n" + 
-			"----------\n");		
-	}	
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391521, [1.8][compiler] Error highlighting is not accurate for type references with type annotations
-	public void test391521() {
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"class Y {}\n" +
-				"public class X {\n" +
-				"    Y y1 = (@Marker Z) null;\n" +
-				"    Y y2 = new @Marker Z();\n" +
-				"    Y[] y3 = (@Marker Z[]) null;\n" +
-				"    Y[] y4 = new @Marker Z[0];\n" +
-				"    Y[] y5 = (@Marker Y.Z) null;\n" +
-				"    Y[] y6 = new @Marker Y.  Z();\n" +
-				"    Y[] y7 = (@Marker Y.Z[]) null;\n" +
-				"    Y[] y8 = new @Marker Y[0].  Z;\n" +
-				"    Y[] y9 = new @Marker Y.  Z[0];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker{}\n" +
-				"\n"
-			},
-			"----------\n" +
-			"1. ERROR in X.java (at line 3)\n" +
-			"	Y y1 = (@Marker Z) null;\n" +
-			"	       ^^^^^^^^^^^^^^^^\n" +
-			"Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"2. ERROR in X.java (at line 3)\n" +
-			"	Y y1 = (@Marker Z) null;\n" +
-			"	                ^\n" +
-			"Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"3. ERROR in X.java (at line 4)\n" +
-			"	Y y2 = new @Marker Z();\n" +
-			"	                   ^\n" +
-			"Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"4. ERROR in X.java (at line 5)\n" +
-			"	Y[] y3 = (@Marker Z[]) null;\n" +
-			"	         ^^^^^^^^^^^^^^^^^^\n" +
-			"Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"5. ERROR in X.java (at line 5)\n" +
-			"	Y[] y3 = (@Marker Z[]) null;\n" +
-			"	                  ^\n" +
-			"Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"6. ERROR in X.java (at line 6)\n" +
-			"	Y[] y4 = new @Marker Z[0];\n" +
-			"	                     ^\n" +
-			"Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"7. ERROR in X.java (at line 7)\n" +
-			"	Y[] y5 = (@Marker Y.Z) null;\n" +
-			"	                  ^^^\n" +
-			"Y.Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"8. ERROR in X.java (at line 8)\n" +
-			"	Y[] y6 = new @Marker Y.  Z();\n" +
-			"	                     ^^^^^\n" +
-			"Y.Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"9. ERROR in X.java (at line 9)\n" +
-			"	Y[] y7 = (@Marker Y.Z[]) null;\n" +
-			"	                  ^^^\n" +
-			"Y.Z cannot be resolved to a type\n" +
-			"----------\n" +
-			"10. ERROR in X.java (at line 10)\n" +
-			"	Y[] y8 = new @Marker Y[0].  Z;\n" +
-			"	                            ^\n" +
-			"Z cannot be resolved or is not a field\n" +
-			"----------\n" +
-			"11. ERROR in X.java (at line 11)\n" +
-			"	Y[] y9 = new @Marker Y.  Z[0];\n" +
-			"	                     ^^^^^\n" +
-			"Y.Z cannot be resolved to a type\n" +
-			"----------\n");
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=414038, [1.8][compiler] CCE in resolveAnnotations
-	public void test414038() {
-		runNegativeTest(
-			new String[] {
-					"X.java", 
-					"import java.lang.annotation.*;\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface NonNull { int[].class value() default 0;}\n" +
-					"public class X extends @NonNull() Object {    \n" +
-					"    public static int i = 0; \n" +
-					"}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in X.java (at line 3)\n" + 
-			"	@interface NonNull { int[].class value() default 0;}\n" + 
-			"	                          ^^^^^^\n" + 
-			"Syntax error on tokens, delete these tokens\n" + 
-			"----------\n",
-			true);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=421791,  [1.8][compiler] TYPE_USE annotations should be allowed on annotation type declarations
-	public void test421791() {
-		runNegativeTest(
-				new String[] {
-						"X.java",
-						"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface T {}\n" +
-						"@T\n" +
-						"@interface T2 {}\n" +
-						"public class X {}\n"
-				},
-				"",
-				true);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=424977,  [1.8][compiler]ArrayIndexIndexOutOfBoundException in annotated wrong<> code
-	public void testBug426977() {
-		Map customOptions = getCompilerOptions();
-		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-		runNegativeTest(
-			new String[] {
-				"test/X.java",
-				"package test;\n" +
-				"import java.lang.annotation.ElementType;\n" + 
-				"import java.lang.annotation.Target;\n" + 
-				"\n" + 
-				"public class X {\n" + 
-				"    test.@A Outer<>.@A Inner<> i;\n" + 
-				"}\n" +
-				"class Outer<T> {\n" +
-				"    class Inner {}\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE)\n" + 
-				"@interface A {}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in test\\X.java (at line 6)\n" + 
-			"	test.@A Outer<>.@A Inner<> i;\n" + 
-			"	^^^^^^^^^^^^^\n" + 
-			"Incorrect number of arguments for type Outer<T>; it cannot be parameterized with arguments <>\n" + 
-			"----------\n",
-			null,
-			true,
-			customOptions);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=424977,  [1.8][compiler] ArrayIndexIndexOutOfBoundException in annotated wrong<> code
-	public void testBug426977a() {
-		Map customOptions = getCompilerOptions();
-		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-		runNegativeTest(
-			new String[] {
-				"test/X.java",
-				"package test;\n" +
-				"import java.lang.annotation.ElementType;\n" + 
-				"import java.lang.annotation.Target;\n" + 
-				"\n" + 
-				"public class X {\n" + 
-				"    test.@A Outer<Object>.@A Inner<> i;\n" + 
-				"}\n" +
-				"class Outer<T> {\n" +
-				"    class Inner {}\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE)\n" + 
-				"@interface A {}\n"
-			},
-			"----------\n" + 
-			"1. ERROR in test\\X.java (at line 6)\n" + 
-			"	test.@A Outer<Object>.@A Inner<> i;\n" + 
-			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The type Outer<Object>.Inner is not generic; it cannot be parameterized with arguments <>\n" + 
-			"----------\n",
-			null,
-			true,
-			customOptions);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425599, [1.8][compiler] ISE when trying to compile qualified and annotated class instance creation
-	public void test425599() {
-		Map customOptions = getCompilerOptions();
-		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"public class X {\n" +
-				"    Object ax = new @A Outer().new Middle<String>();\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE) @interface A {}\n" +
-				"class Outer {\n" +
-				"    class Middle<E> {}\n" +
-				"}\n"
-			},
-			"",
-			null,
-			true,
-			customOptions);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=427955, [1.8][compiler] NPE in TypeSystem.getUnannotatedType
-	public void test427955() {
-		Map customOptions = getCompilerOptions();
-		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-		runNegativeTest(
-			new String[] {
-				"X.java",
-				"/**\n" +
-				" * @param <K> unused\n" +
-				" * @param <V> unused\n" +
-				" */\n" +
-				"public class X {}\n" +
-				"class Outer<K, V> {\n" +
-				"  void method() {\n" +
-				"    //Internal compiler error: java.lang.NullPointerException at\n" +
-				"    // org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76)\n" +
-				"    new Inner<>(null);\n" +
-				"  }\n" +
-				"  final class Inner<K2, V2> {\n" +
-				"    /**\n" +
-				"     * @param next unused \n" +
-				"     */\n" +
-				"    Inner(Inner<K2, V2> next) {}\n" +
-				"  }\n" +
-				"}\n"
-			},
-			"",
-			null,
-			true,
-			customOptions);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419827,  [1.8] Annotation with TYPE_USE as target is not allowed to use container with target TYPE
-	public void test419827a() {
-		runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Repeatable;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"\n" +
-					"@Target({ElementType.TYPE_USE})\n" +
-					"@Repeatable(FooContainer.class)\n" +
-					"@interface Foo {}\n" +
-					"@Target({ElementType.TYPE, ElementType.TYPE_USE})\n" +
-					"@interface FooContainer {\n" +
-					"	Foo[] value();\n" +
-					"}\n" +
-					"public class X{}\n"
-				},
-				"",
-				true);
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419827,  [1.8] Annotation with TYPE_USE as target is not allowed to use container with target TYPE
-	// Although the target of FooContainer is different from that of Foo, Foo container cannot be used in any place where
-	// Foo can't be used.
-	public void test419827b() {
-		runNegativeTest(
-				new String[] {
-					"X.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Repeatable;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"\n" +
-					"@Target({ElementType.TYPE_USE})\n" +
-					"@Repeatable(FooContainer.class)\n" +
-					"@interface Foo {}\n" +
-					"@Target({ElementType.TYPE})\n" +
-					"@interface FooContainer {\n" +
-					"	Foo[] value();\n" +
-					"}\n" +
-					"public class X{}\n"
-				},
-				"",
-				true);
-	}
-}
+/*******************************************************************************
+ * Copyright (c) 2011, 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.compiler.regression;
+
+import java.io.File;
+import java.util.Map;
+
+import org.eclipse.jdt.core.util.ClassFileBytesDisassembler;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+import junit.framework.Test;
+
+public class NegativeTypeAnnotationTest extends AbstractRegressionTest {
+
+	static { 
+//		TESTS_NUMBERS = new int [] { 35 };
+//		TESTS_NAMES = new String [] { "test0390882b" };
+	}
+	public static Class testClass() {
+		return NegativeTypeAnnotationTest.class;
+	}
+	public static Test suite() {
+		return buildMinimalComplianceTestSuite(testClass(), F_1_8);
+	}
+	public NegativeTypeAnnotationTest(String testName){
+		super(testName);
+	}
+	public void test001() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X extends @Marker2 Object {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X extends @Marker2 Object {}\n" + 
+				"	                        ^^^^^^^\n" + 
+				"Marker2 cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test002() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.io.Serializable;\n" +
+					"public class X implements @Marker2 Serializable {\n" +
+					"	private static final long serialVersionUID = 1L;\n" +
+					"}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	public class X implements @Marker2 Serializable {\n" + 
+				"	                           ^^^^^^^\n" + 
+				"Marker2 cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test003() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X extends @Marker Object {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X extends @Marker Object {}\n" + 
+				"	                        ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test004() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X<@Marker T> {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X<@Marker T> {}\n" + 
+				"	                ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test005() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X<@Marker T> {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X<@Marker T> {}\n" + 
+				"	                ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test006() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"Y.java",
+				"class Y {}\n",
+				"X.java",
+				"public class X extends @A(id=\"Hello, World!\") @B @C('(') Y {\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X extends @A(id=\"Hello, World!\") @B @C(\'(\') Y {\n" + 
+		"	                        ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X extends @A(id=\"Hello, World!\") @B @C(\'(\') Y {\n" + 
+		"	                                               ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 1)\n" + 
+		"	public class X extends @A(id=\"Hello, World!\") @B @C(\'(\') Y {\n" + 
+		"	                                                  ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	public void test007() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"I.java",
+				"interface I {}\n",
+				"J.java",
+				"interface J {}\n",
+				"X.java",
+				"public class X implements @A(id=\"Hello, World!\") I, @B @C('(') J {}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X implements @A(id=\"Hello, World!\") I, @B @C(\'(\') J {}\n" + 
+		"	                           ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X implements @A(id=\"Hello, World!\") I, @B @C(\'(\') J {}\n" + 
+		"	                                                     ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 1)\n" + 
+		"	public class X implements @A(id=\"Hello, World!\") I, @B @C(\'(\') J {}\n" + 
+		"	                                                        ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	public void test010() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"Y.java",
+				"class Y<T> {}\n",
+				"X.java",
+				"public class X extends @A(\"Hello, World!\") Y<@B @C('(') String> {\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String> {\n" + 
+		"	                        ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String> {\n" + 
+		"	                                              ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 1)\n" + 
+		"	public class X extends @A(\"Hello, World!\") Y<@B @C(\'(\') String> {\n" + 
+		"	                                                 ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	public void test011() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"I.java",
+				"interface I<T> {}\n",
+				"J.java",
+				"interface J<T> {}\n",
+				"X.java",
+				"public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C('(') Integer> {}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C(\'(\') Integer> {}\n" + 
+		"	                             ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C(\'(\') Integer> {}\n" + 
+		"	                                                           ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 1)\n" + 
+		"	public class X implements I<@A(\"Hello, World!\") String>,  @B J<@C(\'(\') Integer> {}\n" + 
+		"	                                                                ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// throws
+	public void test012() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"E.java",
+				"class E extends RuntimeException {\n" +
+				"	private static final long serialVersionUID = 1L;\n" +
+				"}\n",
+				"E1.java",
+				"class E1 extends RuntimeException {\n" +
+				"	private static final long serialVersionUID = 1L;\n" +
+				"}\n",
+				"E2.java",
+				"class E2 extends RuntimeException {\n" +
+				"	private static final long serialVersionUID = 1L;\n" +
+				"}\n",
+				"X.java",
+				"public class X {\n" +
+				"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C('(') E2 {}\n" +
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C(\'(\') E2 {}\n" + 
+		"	                   ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 2)\n" + 
+		"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C(\'(\') E2 {}\n" + 
+		"	                                              ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 2)\n" + 
+		"	void foo() throws @A(\"Hello, World!\") E, E1, @B @C(\'(\') E2 {}\n" + 
+		"	                                                 ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// method receiver
+	public void test013() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	void foo(@B(3) X this) {}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	void foo(@B(3) X this) {}\n" + 
+		"	          ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// method return type
+	public void test014() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	@B(3) int foo() {\n" +
+				"		return 1;\n" +
+				"	}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	@B(3) int foo() {\n" + 
+		"	 ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// field type
+	public void test015() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	@B(3) int field;\n" +
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	@B(3) int field;\n" + 
+		"	 ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// method parameter
+	public void test016() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	int foo(@B(3) String s) {\n" +
+				"		return s.length();\n" +
+				"	}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	int foo(@B(3) String s) {\n" + 
+		"	         ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// method parameter generic or array
+	public void test017() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	int foo(String @B(3) [] s) {\n" +
+				"		return s.length;\n" +
+				"	}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	int foo(String @B(3) [] s) {\n" + 
+		"	                ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// field type generic or array
+	public void test018() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	int @B(3) [] field;\n" +
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	int @B(3) [] field;\n" + 
+		"	     ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// class type parameter
+	public void test019() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X<@A @B(3) T> {}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X<@A @B(3) T> {}\n" + 
+		"	                ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X<@A @B(3) T> {}\n" + 
+		"	                   ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// method type parameter
+	public void test020() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	<@A @B(3) T> void foo(T t) {}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	<@A @B(3) T> void foo(T t) {}\n" + 
+		"	  ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 2)\n" + 
+		"	<@A @B(3) T> void foo(T t) {}\n" + 
+		"	     ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// class type parameter bound
+	public void test021() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"Z.java",
+				"public class Z {}",
+				"X.java",
+				"public class X<T extends @A Z & @B(3) Cloneable> {}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X<T extends @A Z & @B(3) Cloneable> {}\n" + 
+		"	                          ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X<T extends @A Z & @B(3) Cloneable> {}\n" + 
+		"	                                 ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// class type parameter bound generic or array
+	public void test022() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"Y.java",
+				"public class Y<T> {}",
+				"X.java",
+				"public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 1)\n" + 
+		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
+		"	                            ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 1)\n" + 
+		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
+		"	                                      ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 1)\n" + 
+		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
+		"	                                            ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 1)\n" + 
+		"	public class X<T extends Y<@A String @C[][]@B[]> & @B(3) Cloneable> {}\n" + 
+		"	                                                    ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// method type parameter bound
+	public void test023() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"Z.java",
+				"public class Z {}",
+				"X.java",
+				"public class X {\n" +
+				"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" +
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" + 
+		"	            ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 2)\n" + 
+		"	<T extends @A Z & @B(3) Cloneable> void foo(T t) {}\n" + 
+		"	                   ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// class type parameter bound generic or array
+	public void test024() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"Z.java",
+				"public class Z {}",
+				"Y.java",
+				"public class Y<T> {}",
+				"X.java",
+				"public class X {\n" +
+				"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" +
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 2)\n" + 
+		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
+		"	              ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 2)\n" + 
+		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
+		"	                   ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 2)\n" + 
+		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
+		"	                         ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 2)\n" + 
+		"	<T extends Y<@A Z @C[][]@B[]> & @B(3) Cloneable> void foo(T t) {}\n" + 
+		"	                                 ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// local variable + generic or array
+	public void test025() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	void foo(String s) {\n" + 
+				"		@C int i;\n" + 
+				"		@A String [] @B(3)[] tab = new String[][] {};\n" + 
+				"		if (tab != null) {\n" + 
+				"			i = 0;\n" + 
+				"			System.out.println(i + tab.length);\n" + 
+				"		} else {\n" + 
+				"			System.out.println(tab.length);\n" + 
+				"		}\n" + 
+				"		i = 4;\n" + 
+				"		System.out.println(-i + tab.length);\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	@C int i;\n" + 
+		"	 ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 4)\n" + 
+		"	@A String [] @B(3)[] tab = new String[][] {};\n" + 
+		"	 ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 4)\n" + 
+		"	@A String [] @B(3)[] tab = new String[][] {};\n" + 
+		"	              ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// type argument constructor call
+	public void test026() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	<T> X(T t) {\n" + 
+				"	}\n" + 
+				"	public Object foo() {\n" + 
+				"		X x = new <@A @B(1) String>X(null);\n" + 
+				"		return x;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	X x = new <@A @B(1) String>X(null);\n" + 
+		"	            ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	X x = new <@A @B(1) String>X(null);\n" + 
+		"	               ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// type argument constructor call generic or array
+	public void test027() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" + 
+				"	<T> X(T t) {\n" + 
+				"	}\n" + 
+				"	public Object foo() {\n" + 
+				"		X x = new <@A @B(1) String>X(null);\n" + 
+				"		return x;\n" + 
+				"	}\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	X x = new <@A @B(1) String>X(null);\n" + 
+		"	            ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	X x = new <@A @B(1) String>X(null);\n" + 
+		"	               ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// type argument method call and generic or array
+	public void test028() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"\n" +
+				"	static <T, U> T foo(T t, U u) {\n" +
+				"		return t;\n" +
+				"	}\n" +
+				"	public static void main(String[] args) {\n" +
+				"		System.out.println(X.<@A @B(1) String[], @C('-') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" +
+				"	}\n" +
+				"}\n",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 7)\n" + 
+		"	System.out.println(X.<@A @B(1) String[], @C(\'-\') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" + 
+		"	                       ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 7)\n" + 
+		"	System.out.println(X.<@A @B(1) String[], @C(\'-\') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" + 
+		"	                          ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 7)\n" + 
+		"	System.out.println(X.<@A @B(1) String[], @C(\'-\') X>foo(new String[]{\"SUCCESS\"}, null)[0]);\n" + 
+		"	                                          ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	public void test029() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X extends @Marker2 Object {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X extends @Marker2 Object {}\n" + 
+				"	                        ^^^^^^^\n" + 
+				"Marker2 cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test030() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.io.Serializable;\n" +
+					"public class X implements @Marker2 Serializable {\n" +
+					"	private static final long serialVersionUID = 1L;\n" +
+					"}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	public class X implements @Marker2 Serializable {\n" + 
+				"	                           ^^^^^^^\n" + 
+				"Marker2 cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test031() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"Marker.java",
+					"import java.lang.annotation.Target;\n" + 
+					"import static java.lang.annotation.ElementType.*;\n" + 
+					"@Target(TYPE)\n" + 
+					"@interface Marker {}",
+					"X.java",
+					"public class X<@Marker T> {}",
+
+					"java/lang/annotation/ElementType.java",
+					"package java.lang.annotation;\n" +
+					"public enum ElementType {\n" +
+					"    TYPE,\n" +
+					"    FIELD,\n" +
+					"    METHOD,\n" +
+					"    PARAMETER,\n" +
+					"    CONSTRUCTOR,\n" +
+					"    LOCAL_VARIABLE,\n" +
+					"    ANNOTATION_TYPE,\n" +
+					"    PACKAGE,\n" +
+					"    TYPE_PARAMETER,\n" +
+					"    TYPE_USE\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X<@Marker T> {}\n" + 
+				"	               ^^^^^^^\n" + 
+				"The annotation @Marker is disallowed for this location\n" + 
+				"----------\n");
+	}
+	public void test032() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"Marker.java",
+					"@interface Marker {}",
+					"X.java",
+					"public class X<@Marker T> {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X<@Marker T> {}\n" + 
+				"	               ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	public void test033() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"Marker.java",
+					"@interface Marker {}",
+					"Y.java",
+					"public class Y {}",
+					"X.java",
+					"public class X extends @Marker Y {}",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X extends @Marker Y {}\n" + 
+				"	                       ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	// check locations
+	public void test034() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.util.Map;\n" +
+				"import java.util.List;\n" +
+				"public class X {\n" + 
+				"	@H String @E[] @F[] @G[] field;\n" + 
+				"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+				"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"	 ^\n" + 
+		"H cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 4)\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"	           ^\n" + 
+		"E cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 4)\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"	                ^\n" + 
+		"F cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 4)\n" + 
+		"	@H String @E[] @F[] @G[] field;\n" + 
+		"	                     ^\n" + 
+		"G cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 5)\n" + 
+		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+		"	 ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"6. ERROR in X.java (at line 5)\n" + 
+		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+		"	        ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 5)\n" + 
+		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+		"	                   ^\n" + 
+		"C cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"8. ERROR in X.java (at line 5)\n" + 
+		"	@A Map<@B String, @C List<@D Object>> field2;\n" + 
+		"	                           ^\n" + 
+		"D cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"9. ERROR in X.java (at line 6)\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"	 ^\n" + 
+		"A cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"10. ERROR in X.java (at line 6)\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"	        ^\n" + 
+		"B cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"11. ERROR in X.java (at line 6)\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"	                   ^\n" + 
+		"H cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"12. ERROR in X.java (at line 6)\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"	                             ^\n" + 
+		"E cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"13. ERROR in X.java (at line 6)\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"	                                  ^\n" + 
+		"F cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"14. ERROR in X.java (at line 6)\n" + 
+		"	@A Map<@B String, @H String @E[] @F[] @G[]> field3;\n" + 
+		"	                                       ^\n" + 
+		"G cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// check locations
+	public void test035() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.util.Map;\n" +
+				"import java.util.List;\n" +
+				"public class X {\n" + 
+				"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
+				"}",
+		},
+		"----------\n" + 
+		"1. ERROR in X.java (at line 4)\n" + 
+		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
+		"	 ^\n" + 
+		"H cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 4)\n" + 
+		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
+		"	                     ^\n" + 
+		"E cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"3. ERROR in X.java (at line 4)\n" + 
+		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
+		"	                          ^\n" + 
+		"F cannot be resolved to a type\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 4)\n" + 
+		"	@H java.lang.String @E[] @F[] @G[] field;\n" + 
+		"	                               ^\n" + 
+		"G cannot be resolved to a type\n" + 
+		"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383884 -- Compiler tolerates illegal dimension annotation in class literal expressions
+	public void test036() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"  public static void main(String[] args) {\n" +
+				"    System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" +
+				"    System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" +
+				"    System.out.println(int [] [] [] [] [].class);\n" +
+				"    System.out.println(X [] [] [] [] [].class);\n" +
+				"  }\n" +
+				"}\n" +
+				"@interface Empty {\n" +
+				"}\n" +
+				"@interface NonEmpty {\n" +
+				"}\n",
+		},
+		"----------\n" + 
+		"1. WARNING in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                       ^^^^^^^^^\n" + 
+		"Syntax error, type annotations are illegal here\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                       ^^^^^^^^^\n" + 
+		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+		"----------\n" + 
+		"3. WARNING in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                       ^^^^^^^^^^^^^^^^\n" + 
+		"Syntax error, type annotations are illegal here\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                       ^^^^^^^^^\n" + 
+		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+		"----------\n" + 
+		"5. ERROR in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                                 ^^^^^^\n" + 
+		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+		"----------\n" + 
+		"6. WARNING in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                                              ^^^^^^^^^\n" + 
+		"Syntax error, type annotations are illegal here\n" + 
+		"----------\n" + 
+		"7. ERROR in X.java (at line 3)\n" + 
+		"	System.out.println(int @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                                              ^^^^^^^^^\n" + 
+		"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+		"----------\n" + 
+		"8. ERROR in X.java (at line 4)\n" + 
+		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                     ^^^^^^^^^\n" + 
+		"Syntax error, type annotations are illegal here\n" + 
+		"----------\n" + 
+		"9. ERROR in X.java (at line 4)\n" + 
+		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                     ^^^^^^^^^^^^^^^^\n" + 
+		"Syntax error, type annotations are illegal here\n" + 
+		"----------\n" + 
+		"10. ERROR in X.java (at line 4)\n" + 
+		"	System.out.println(X @NonEmpty [] [] @NonEmpty @Empty [] [] @NonEmpty[].class); // illegal!\n" + 
+		"	                                                            ^^^^^^^^^\n" + 
+		"Syntax error, type annotations are illegal here\n" + 
+		"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383950
+	// [1.8][compiler] Type annotations must have target type meta annotation TYPE_USE
+	public void test037() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"@interface Marker {}\n" +
+					"@Marker	// line 2: Don't complain \n" +
+					"public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" +
+					"	public @Marker Object foo(@Marker Object obj) {  // 4: Don't complain on both\n" +
+					"		return null;\n" +
+					"	}\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 3)\n" + 
+				"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
+				"	               ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 3)\n" + 
+				"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
+				"	                                   ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383950
+	// [1.8][compiler] Type annotations must have target type meta annotation TYPE_USE
+	public void test038() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.Target;\n" + 
+						"import static java.lang.annotation.ElementType.*;\n" + 
+						"@Target({PACKAGE, TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER, LOCAL_VARIABLE})\n" + 
+						"@interface Marker {}\n" +
+						"public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" +
+						"}\n",
+					},
+					"----------\n" + 
+					"1. ERROR in X.java (at line 5)\n" + 
+					"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
+					"	               ^^^^^^^\n" + 
+					"The annotation @Marker is disallowed for this location\n" + 
+					"----------\n" + 
+					"2. ERROR in X.java (at line 5)\n" + 
+					"	public class X<@Marker T>  extends @Marker Object{		// 3: Complain \n" + 
+					"	                                   ^^^^^^^\n" + 
+					"The annotation @Marker is disallowed for this location\n" + 
+					"----------\n");
+	}
+	// JSR 308: "It is not permitted to annotate the type name in an import statement."
+	public void test039() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import @Marker java.lang.String; // Compilation error \n" +
+						"public class X { \n" +
+						"}\n" + 
+						"@interface Marker {}\n"
+					}, 
+					"----------\n" + 
+					"1. ERROR in X.java (at line 1)\n" + 
+					"	import @Marker java.lang.String; // Compilation error \n" + 
+					"	       ^^^^^^^\n" + 
+					"Syntax error, type annotations are illegal here\n" + 
+					"----------\n");
+	}
+	// Test that type name can't be left out in a cast expression with an annotations 
+	public void test040() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X { \n" +
+						"	public void foo(Object myObject) {\n" +
+						"		String myString = (@NonNull) myObject;" +
+						"	}\n" +
+						"}\n" + 
+						"@interface NonNull {}\n"
+					}, 
+					"----------\n" + 
+					"1. ERROR in X.java (at line 3)\n" + 
+					"	String myString = (@NonNull) myObject;	}\n" + 
+					"	                   ^\n" + 
+					"Syntax error on token \"@\", delete this token\n" + 
+					"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385111
+	// [1.8][compiler] Compiler fails to flag undefined annotation type. 
+	public void test0385111() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.util.ArrayList;\n" +
+						"import java.util.List;\n" +
+						"public class X {\n" +
+						"    public void foo(String fileName) {\n" +
+						"        List<String> l = new @MissingTypeNotIgnored ArrayList<String>();\n" +
+						"        List<String> l1 = new @MissingTypeIgnored ArrayList<>();\n" +
+						"    }\n" +
+						"}\n",
+					},
+					"----------\n" + 
+					"1. ERROR in X.java (at line 5)\n" + 
+					"	List<String> l = new @MissingTypeNotIgnored ArrayList<String>();\n" + 
+					"	                      ^^^^^^^^^^^^^^^^^^^^^\n" + 
+					"MissingTypeNotIgnored cannot be resolved to a type\n" + 
+					"----------\n" + 
+					"2. ERROR in X.java (at line 6)\n" + 
+					"	List<String> l1 = new @MissingTypeIgnored ArrayList<>();\n" + 
+					"	                       ^^^^^^^^^^^^^^^^^^\n" + 
+					"MissingTypeIgnored cannot be resolved to a type\n" + 
+					"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385111
+	// Test to exercise assorted cleanup along with bug fix. 
+	public void test0385111a() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"    public void foo(String fileName) {\n" +
+						"        try (@Annot X x = null; @Annot X x2 = null) {\n"+
+						"        } catch (@Annot NullPointerException | @Annot UnsupportedOperationException e) {\n" +
+						"        }\n" +
+						"    }\n" +
+						"}\n",
+					},
+					"----------\n" + 
+					"1. ERROR in X.java (at line 3)\n" + 
+					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
+					"	      ^^^^^\n" + 
+					"Annot cannot be resolved to a type\n" + 
+					"----------\n" + 
+					"2. ERROR in X.java (at line 3)\n" + 
+					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
+					"	            ^\n" + 
+					"The resource type X does not implement java.lang.AutoCloseable\n" + 
+					"----------\n" + 
+					"3. ERROR in X.java (at line 3)\n" + 
+					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
+					"	                         ^^^^^\n" + 
+					"Annot cannot be resolved to a type\n" + 
+					"----------\n" + 
+					"4. ERROR in X.java (at line 3)\n" + 
+					"	try (@Annot X x = null; @Annot X x2 = null) {\n" + 
+					"	                               ^\n" + 
+					"The resource type X does not implement java.lang.AutoCloseable\n" + 
+					"----------\n" + 
+					"5. ERROR in X.java (at line 4)\n" + 
+					"	} catch (@Annot NullPointerException | @Annot UnsupportedOperationException e) {\n" + 
+					"	          ^^^^^\n" + 
+					"Annot cannot be resolved to a type\n" + 
+					"----------\n" + 
+					"6. ERROR in X.java (at line 4)\n" + 
+					"	} catch (@Annot NullPointerException | @Annot UnsupportedOperationException e) {\n" + 
+					"	                                        ^^^^^\n" + 
+					"Annot cannot be resolved to a type\n" + 
+					"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
+	public void test0383913() {
+		this.runNegativeTest(
+				new String[]{
+						"X.java",
+						"public class X {\n" +
+						"	public void foo(Object obj, X this) {}\n" +
+						"	public void foo(Object obj1, X this, Object obj2) {}\n" +
+						"	public void foo(Object obj, Object obj2, Object obj3, X this) {}\n" +
+						"	class Y {\n" +
+						"		Y(Object obj, Y Y.this){}\n" +
+						"	}\n" +
+						"}"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	public void foo(Object obj, X this) {}\n" + 
+				"	                              ^^^^\n" + 
+				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 3)\n" + 
+				"	public void foo(Object obj1, X this, Object obj2) {}\n" + 
+				"	                               ^^^^\n" + 
+				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 4)\n" + 
+				"	public void foo(Object obj, Object obj2, Object obj3, X this) {}\n" + 
+				"	                                                        ^^^^\n" + 
+				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 6)\n" + 
+				"	Y(Object obj, Y Y.this){}\n" + 
+				"	                  ^^^^\n" + 
+				"Only the first formal parameter may be declared explicitly as 'this'\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
+	public void test0383913b() {
+		this.runNegativeTest(
+				new String[] {
+						"Outer.java",
+						"public class Outer {\n" +
+						"    Outer(Outer Outer.this) {}\n" +
+						"    Outer(Outer this, int i) {}\n" +
+						"    class Inner<K,V> {\n" +
+						"        class InnerMost<T> {\n" +
+						"            InnerMost(Outer.Inner this) {}\n" +
+						"            InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" +
+						"            InnerMost(Outer Outer.this, float f) {}\n" +
+						"            InnerMost(Outer.Inner<K,V>.InnerMost<T> Outer.Inner.InnerMost.this, Object obj) {}\n" +
+						"            InnerMost(Inner<K,V> Outer.Inner.InnerMost.this, int i) {}\n" +
+						"            InnerMost(Outer.Inner<K, V> this, float f, int i) {}\n" +
+						"            InnerMost(Outer.Inner<K,V> Inner.this, long l) {}\n" +
+						"        }\n" +
+						"    }\n" +
+						"}\n"},
+						"----------\n" + 
+						"1. ERROR in Outer.java (at line 2)\n" + 
+						"	Outer(Outer Outer.this) {}\n" + 
+						"	                  ^^^^\n" + 
+						"Explicit 'this' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
+						"----------\n" + 
+						"2. ERROR in Outer.java (at line 3)\n" + 
+						"	Outer(Outer this, int i) {}\n" + 
+						"	            ^^^^\n" + 
+						"Explicit 'this' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
+						"----------\n" + 
+						"3. WARNING in Outer.java (at line 6)\n" + 
+						"	InnerMost(Outer.Inner this) {}\n" + 
+						"	          ^^^^^^^^^^^\n" + 
+						"Outer.Inner is a raw type. References to generic type Outer.Inner<K,V> should be parameterized\n" + 
+						"----------\n" + 
+						"4. ERROR in Outer.java (at line 6)\n" + 
+						"	InnerMost(Outer.Inner this) {}\n" + 
+						"	          ^^^^^^^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
+						"----------\n" + 
+						"5. ERROR in Outer.java (at line 6)\n" + 
+						"	InnerMost(Outer.Inner this) {}\n" + 
+						"	                      ^^^^\n" + 
+						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
+						"----------\n" + 
+						"6. WARNING in Outer.java (at line 7)\n" + 
+						"	InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" + 
+						"	          ^^^^^^^^^^^\n" + 
+						"Outer.Inner is a raw type. References to generic type Outer.Inner<K,V> should be parameterized\n" + 
+						"----------\n" + 
+						"7. ERROR in Outer.java (at line 7)\n" + 
+						"	InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" + 
+						"	          ^^^^^^^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
+						"----------\n" + 
+						"8. ERROR in Outer.java (at line 7)\n" + 
+						"	InnerMost(Outer.Inner Outer.Inner.this, int i, float f) {}\n" + 
+						"	                      ^^^^^^^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
+						"----------\n" + 
+						"9. ERROR in Outer.java (at line 8)\n" + 
+						"	InnerMost(Outer Outer.this, float f) {}\n" + 
+						"	          ^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
+						"----------\n" + 
+						"10. ERROR in Outer.java (at line 8)\n" + 
+						"	InnerMost(Outer Outer.this, float f) {}\n" + 
+						"	                ^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
+						"----------\n" + 
+						"11. ERROR in Outer.java (at line 9)\n" + 
+						"	InnerMost(Outer.Inner<K,V>.InnerMost<T> Outer.Inner.InnerMost.this, Object obj) {}\n" + 
+						"	          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>\n" + 
+						"----------\n" + 
+						"12. ERROR in Outer.java (at line 9)\n" + 
+						"	InnerMost(Outer.Inner<K,V>.InnerMost<T> Outer.Inner.InnerMost.this, Object obj) {}\n" + 
+						"	                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
+						"----------\n" + 
+						"13. ERROR in Outer.java (at line 10)\n" + 
+						"	InnerMost(Inner<K,V> Outer.Inner.InnerMost.this, int i) {}\n" + 
+						"	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
+						"----------\n" + 
+						"14. ERROR in Outer.java (at line 11)\n" + 
+						"	InnerMost(Outer.Inner<K, V> this, float f, int i) {}\n" + 
+						"	                            ^^^^\n" + 
+						"The explicit 'this' parameter is expected to be qualified with Inner\n" + 
+						"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
+	public void test0383913c() {
+		this.runNegativeTest(
+				new String[] {
+						"Outer.java",
+						"public class Outer {\n" +
+						"    class Inner<K,V> {\n" +
+						"        class InnerMost<T> {\n" +
+						"            public void foo(Outer Outer.this) {}\n" +
+						"            public void foo(Inner<K,V> Inner.this, int i) {}\n" +
+						"            public void foo(InnerMost this, int i, int j) {}\n" +
+						"            public void foo(Inner.InnerMost<T> this, Object obj) {}\n" +
+						"            public void foo(InnerMost<T> this, float f) {}\n" +
+						"            public void foo(Inner<K,V>.InnerMost<T> this, long l) {}\n" +
+						"            public void foo(Outer.Inner<K,V>.InnerMost<T> this, float f, float ff) {}\n" +
+						"            public void foo(InnerMost<T> Outer.Inner.InnerMost.this, int i, float f) {}\n" +
+						"        }\n" +
+						"    }\n" +
+						"}\n"},
+						"----------\n" + 
+						"1. ERROR in Outer.java (at line 4)\n" + 
+						"	public void foo(Outer Outer.this) {}\n" + 
+						"	                ^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
+						"----------\n" + 
+						"2. ERROR in Outer.java (at line 4)\n" + 
+						"	public void foo(Outer Outer.this) {}\n" + 
+						"	                      ^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter for a method cannot have a qualifying name\n" + 
+						"----------\n" + 
+						"3. ERROR in Outer.java (at line 5)\n" + 
+						"	public void foo(Inner<K,V> Inner.this, int i) {}\n" + 
+						"	                ^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
+						"----------\n" + 
+						"4. ERROR in Outer.java (at line 5)\n" + 
+						"	public void foo(Inner<K,V> Inner.this, int i) {}\n" + 
+						"	                           ^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter for a method cannot have a qualifying name\n" + 
+						"----------\n" + 
+						"5. WARNING in Outer.java (at line 6)\n" + 
+						"	public void foo(InnerMost this, int i, int j) {}\n" + 
+						"	                ^^^^^^^^^\n" + 
+						"Outer.Inner.InnerMost is a raw type. References to generic type Outer.Inner<K,V>.InnerMost<T> should be parameterized\n" + 
+						"----------\n" + 
+						"6. ERROR in Outer.java (at line 6)\n" + 
+						"	public void foo(InnerMost this, int i, int j) {}\n" + 
+						"	                ^^^^^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
+						"----------\n" + 
+						"7. ERROR in Outer.java (at line 7)\n" + 
+						"	public void foo(Inner.InnerMost<T> this, Object obj) {}\n" + 
+						"	                ^^^^^^^^^^^^^^^\n" + 
+						"The member type Outer.Inner.InnerMost<T> must be qualified with a parameterized type, since it is not static\n" + 
+						"----------\n" + 
+						"8. ERROR in Outer.java (at line 7)\n" + 
+						"	public void foo(Inner.InnerMost<T> this, Object obj) {}\n" + 
+						"	                ^^^^^^^^^^^^^^^\n" + 
+						"The declared type of the explicit 'this' parameter is expected to be Outer.Inner<K,V>.InnerMost<T>\n" + 
+						"----------\n" +
+						"9. ERROR in Outer.java (at line 11)\n" + 
+						"	public void foo(InnerMost<T> Outer.Inner.InnerMost.this, int i, float f) {}\n" + 
+						"	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+						"The explicit 'this' parameter for a method cannot have a qualifying name\n" + 
+						"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383913
+	public void test0383913d() {
+		this.runNegativeTest(
+				new String[] {
+						"Outer.java",
+						"import java.lang.annotation.Target;\n" + 
+						"import static java.lang.annotation.ElementType.*;\n" + 
+						"public class Outer {\n" +
+						"    class Inner<K,V> {\n" +
+						"		public Inner(@Missing Outer Outer.this) {}\n" +
+						"        class InnerMost<T> {\n" +
+						"            public void bar() {\n" +
+						"                new AnonymousInner() {\n" +
+						"                    public void foobar(AnonymousInner this) {}\n" +
+						"                };\n" +
+						"            }\n" +
+						"            void bar(int i) {\n" +
+						"                class Local {\n" +
+						"                    public int hashCode(Local this, int k) { return 0; }\n" +
+						"                    public int hashCode(Outer.Local this) { return 0; }\n" +
+						"                }\n" +
+						"            }\n" +
+						"        }\n" +
+						"    }\n" +
+						"    static class StaticNested {\n" +
+						"        public StaticNested(@Marker Outer.StaticNested Outer.StaticNested.this) {}\n" +
+						"    }\n" +
+						"    public static void foo(@Marker Outer this) {}\n" +
+						"    public void foo(@Missing Outer this, int i) {}\n" +
+						"}\n" +
+						"interface AnonymousInner {\n" +
+						"    public void foobar(AnonymousInner this);\n" +
+						"}\n" +
+						"@Target(TYPE_USE)\n" + 
+						"@interface Marker {}",
+
+						"java/lang/annotation/ElementType.java",
+						"package java.lang.annotation;\n" +
+						"public enum ElementType {\n" +
+						"    TYPE,\n" +
+						"    FIELD,\n" +
+						"    METHOD,\n" +
+						"    PARAMETER,\n" +
+						"    CONSTRUCTOR,\n" +
+						"    LOCAL_VARIABLE,\n" +
+						"    ANNOTATION_TYPE,\n" +
+						"    PACKAGE,\n" +
+						"    TYPE_PARAMETER,\n" +
+						"    TYPE_USE\n" +
+						"}\n"
+					},
+							"----------\n" + 
+							"1. ERROR in Outer.java (at line 5)\n" + 
+							"	public Inner(@Missing Outer Outer.this) {}\n" + 
+							"	              ^^^^^^^\n" + 
+							"Missing cannot be resolved to a type\n" + 
+							"----------\n" + 
+							"2. ERROR in Outer.java (at line 9)\n" + 
+							"	public void foobar(AnonymousInner this) {}\n" + 
+							"	                                  ^^^^\n" + 
+							"Explicit \'this\' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
+							"----------\n" + 
+							"3. ERROR in Outer.java (at line 15)\n" + 
+							"	public int hashCode(Outer.Local this) { return 0; }\n" + 
+							"	                    ^^^^^^^^^^^\n" + 
+							"Outer.Local cannot be resolved to a type\n" + 
+							"----------\n" + 
+							"4. ERROR in Outer.java (at line 21)\n" + 
+							"	public StaticNested(@Marker Outer.StaticNested Outer.StaticNested.this) {}\n" + 
+							"	                    ^^^^^^^\n" + 
+							"Type annotations are not allowed on type names used to access static members\n" + 
+							"----------\n" + 
+							"5. ERROR in Outer.java (at line 21)\n" + 
+							"	public StaticNested(@Marker Outer.StaticNested Outer.StaticNested.this) {}\n" + 
+							"	                                                                  ^^^^\n" + 
+							"Explicit \'this\' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
+							"----------\n" + 
+							"6. ERROR in Outer.java (at line 23)\n" + 
+							"	public static void foo(@Marker Outer this) {}\n" + 
+							"	                                     ^^^^\n" + 
+							"Explicit \'this\' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors\n" + 
+							"----------\n" + 
+							"7. ERROR in Outer.java (at line 24)\n" + 
+							"	public void foo(@Missing Outer this, int i) {}\n" + 
+							"	                 ^^^^^^^\n" + 
+							"Missing cannot be resolved to a type\n" + 
+							"----------\n");
+	}
+	public void test0383908() {
+		this.runNegativeTest(
+				new String[]{"X.java",
+				"public class X { \n" +
+				"	void foo(X this) {}\n" +
+				"   void foo() {}\n" +
+				"}\n" +
+				"class Y {\n" +
+				"	void foo(Y this) {}\n" +
+				"	public static void main(String[] args) {\n" +
+				"		new Y().foo();\n" +
+				"	}\n" +
+				"}"}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	void foo(X this) {}\n" + 
+				"	     ^^^^^^^^^^^\n" + 
+				"Duplicate method foo() in type X\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 3)\n" + 
+				"	void foo() {}\n" + 
+				"	     ^^^^^\n" + 
+				"Duplicate method foo() in type X\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested package names.
+	public void test383596() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	           ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                        ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                           ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested package names.
+	public void test383596a() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	^^^^^^^\n" + 
+			"Package annotations must be in file package-info.java\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                   ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 1)\n" + 
+			"	@Marker package p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                                   ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested import names.
+	public void test039b() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	       ^\n" + 
+			"The import p cannot be resolved\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	          ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                       ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z. z2;\n" + 
+			"	                                          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested import names.
+	public void test383596b() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" +
+				"public class X {\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	       ^\n" + 
+			"The import p cannot be resolved\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	          ^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	                       ^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n" + 
+			"4. ERROR in X.java (at line 1)\n" + 
+			"	import p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+			"	                                          ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested static import names.
+	public void test041() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" +
+						"public class X {\n" +
+						"}"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	              ^\n" + 
+				"The import p cannot be resolved\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	                 ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	                              ^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.z2;\n" + 
+				"	                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on nested static import names.
+	public void test042() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" +
+						"public class X {\n" +
+						"}"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	              ^\n" + 
+				"The import p cannot be resolved\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	                 ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	                              ^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 1)\n" + 
+				"	import static p. @Marker q.x. @Marker @Marker y. @Marker @Marker @Marker z.*;\n" + 
+				"	                                                 ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit this.
+	// Much water has flown under the bridge. The grammar itself does not allow annotations in qualified name in explicit this.
+	// We now use the production UnannotatableName instead of plain Name. 
+	public void test043() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java",
+				"public class X {\n" +
+				"   class Y {\n" +
+			    "       class Z {\n" +
+				"           Z(X. @Marker Y  Y.this) {\n" +
+				"           }\n" +
+				"       }\n" +
+				"    }\n" +
+				"}"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	Z(X. @Marker Y  Y.this) {\n" + 
+			"	      ^^^^^^\n" + 
+			"Marker cannot be resolved to a type\n" + 
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call -- super form
+	public void test044() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	static X x;\n" +
+						"	public class InnerBar {\n" +
+						"	}\n" +
+						"	public class SubInnerBar extends InnerBar {\n" +
+						"		SubInnerBar() {\n" +
+						"			X.@Marker x. @Marker @Marker @Marker x.super();\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
+				"	  ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
+				"	             ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. WARNING in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.super();\n" + 
+				"	                                     ^\n" + 
+				"The static field X.x should be accessed in a static way\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call, super form with explicit type arguments
+	public void test045() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	static X x;\n" +
+						"	public class InnerBar {\n" +
+						"	}\n" +
+						"	public class SubInnerBar extends InnerBar {\n" +
+						"		SubInnerBar() {\n" +
+						"			X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	  ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	             ^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. WARNING in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	                                     ^\n" + 
+				"The static field X.x should be accessed in a static way\n" + 
+				"----------\n" + 
+				"4. WARNING in X.java (at line 7)\n" + 
+				"	X.@Marker x. @Marker @Marker @Marker x.<String>super();\n" + 
+				"	                                        ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X.InnerBar() of type X.InnerBar; it should not be parameterized with arguments <String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call - this form
+	public void test046() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	Bar bar;\n" +
+						"	class Bar {\n" +
+						"		//static Bar x;\n" +
+						"		public class InnerBar {\n" +
+						"			InnerBar(Bar x) {\n" +
+						"			}\n" +
+						"		}\n" +
+						"		public class SubInnerBar extends InnerBar {\n" +
+						"			SubInnerBar() {\n" +
+						"				X. @Marker bar.this();\n" +
+						"			}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	X. @Marker bar.this();\n" + 
+				"	^^^^^^^^^^^^^^\n" + 
+				"Illegal enclosing instance specification for type X.Bar.SubInnerBar\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	X. @Marker bar.this();\n" + 
+				"	^^^^^^^^^^^^^^\n" + 
+				"Cannot make a static reference to the non-static field X.bar\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 11)\n" + 
+				"	X. @Marker bar.this();\n" + 
+				"	   ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+					"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in explicit constructor call, this form with explicit type arguments
+	public void test047() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	Bar bar;\n" +
+						"	class Bar {\n" +
+						"		//static Bar x;\n" +
+						"		public class InnerBar {\n" +
+						"			InnerBar(Bar x) {\n" +
+						"			}\n" +
+						"		}\n" +
+						"		public class SubInnerBar extends InnerBar {\n" +
+						"			SubInnerBar() {\n" +
+						"				X.@Marker bar.<String>this();\n" +
+						"			}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	^^^^^^^^^^^^^\n" + 
+				"Illegal enclosing instance specification for type X.Bar.SubInnerBar\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	^^^^^^^^^^^^^\n" + 
+				"Cannot make a static reference to the non-static field X.bar\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	  ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. WARNING in X.java (at line 11)\n" + 
+				"	X.@Marker bar.<String>this();\n" + 
+				"	               ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X.Bar.SubInnerBar() of type X.Bar.SubInnerBar; it should not be parameterized with arguments <String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations on Qualified name in PrimaryNoNewArray
+	public void test048() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	X bar;\n" +
+						"	private void foo(X x) {\n" +
+						"		System.out.println((x. @Marker bar));\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	System.out.println((x. @Marker bar));\n" + 
+				"	                       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified this.
+	public void test049() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	class Y {\n" +
+						"		class Z {\n" +
+						"			void foo() {\n" +
+						"				Object o = X.@Marker Y.this; \n" +
+						"			}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	Object o = X.@Marker Y.this; \n" + 
+				"	             ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" +
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified super.
+	public void test050() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	public class Y  {\n" +
+						"		public void foo() {\n" +
+						"			X. @Marker Y.super.hashCode();\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	X. @Marker Y.super.hashCode();\n" + 
+				"	   ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in Name.class
+	public void test051() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	public class Y  {\n" +
+						"		public void foo() {\n" +
+						"			Class<?> c = X. @Marker @Illegal Y.class;\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Class<?> c = X. @Marker @Illegal Y.class;\n" + 
+				"	                ^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in Name [].class.
+	public void test052() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"	public class Y  {\n" +
+						"		public void foo() {\n" +
+						"			Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" + 
+				"	                ^^^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	Class<?> c = X. @Marker @Another Y @YetMore [].class;\n" + 
+				"	                                   ^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in binary expressions with qualified names.
+	public void test053() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X {\n" +
+						"    static int x;\n" +
+						"    static boolean fb;\n" +
+						"	 public void foo(boolean b) {\n" +
+						"		x = (X.@Marker x * 10);\n" +
+						"		x = (X.@Marker x / 10);\n" +
+						"		x = (X.@Marker x % 10);\n" +
+						"		x = (X.@Marker x + 10);\n" +
+						"		x = (X.@Marker x - 10);\n" +
+						"		x = (X.@Marker x << 10);\n" +
+						"		x = (X.@Marker x >> 10);\n" +
+						"		x = (X.@Marker x >>> 10);\n" +
+						"		b = (X.@Marker x < 10);\n" +
+						"		b = (X.@Marker x > 10);\n" +
+						"		b = (X.@Marker x <= 10);\n" +
+						"		b = (X.@Marker x >= 10);\n" +
+						"		b = (X.@Marker x instanceof Object);\n" +
+						"		b = (X.@Marker x == 10);\n" +
+						"		b = (X.@Marker x != 10);\n" +
+						"		x = (X.@Marker x & 10);\n" +
+						"		x = (X.@Marker x ^ 10);\n" +
+						"		x = (X.@Marker x | 10);\n" +
+						"		fb = (X.@Marker fb && true);\n" +
+						"		fb = (X.@Marker fb || true);\n" +
+						"		x = (X.@Marker fb ? 10 : 10);\n" +
+						"	 }\n" +
+						"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	x = (X.@Marker x * 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 6)\n" + 
+				"	x = (X.@Marker x / 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 7)\n" + 
+				"	x = (X.@Marker x % 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 8)\n" + 
+				"	x = (X.@Marker x + 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"5. ERROR in X.java (at line 9)\n" + 
+				"	x = (X.@Marker x - 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"6. ERROR in X.java (at line 10)\n" + 
+				"	x = (X.@Marker x << 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"7. ERROR in X.java (at line 11)\n" + 
+				"	x = (X.@Marker x >> 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"8. ERROR in X.java (at line 12)\n" + 
+				"	x = (X.@Marker x >>> 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"9. ERROR in X.java (at line 13)\n" + 
+				"	b = (X.@Marker x < 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"10. ERROR in X.java (at line 14)\n" + 
+				"	b = (X.@Marker x > 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"11. ERROR in X.java (at line 15)\n" + 
+				"	b = (X.@Marker x <= 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"12. ERROR in X.java (at line 16)\n" + 
+				"	b = (X.@Marker x >= 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"13. ERROR in X.java (at line 17)\n" + 
+				"	b = (X.@Marker x instanceof Object);\n" + 
+				"	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Incompatible conditional operand types int and Object\n" + 
+				"----------\n" + 
+				"14. ERROR in X.java (at line 17)\n" + 
+				"	b = (X.@Marker x instanceof Object);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"15. ERROR in X.java (at line 18)\n" + 
+				"	b = (X.@Marker x == 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"16. ERROR in X.java (at line 19)\n" + 
+				"	b = (X.@Marker x != 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"17. ERROR in X.java (at line 20)\n" + 
+				"	x = (X.@Marker x & 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"18. ERROR in X.java (at line 21)\n" + 
+				"	x = (X.@Marker x ^ 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"19. ERROR in X.java (at line 22)\n" + 
+				"	x = (X.@Marker x | 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"20. ERROR in X.java (at line 23)\n" + 
+				"	fb = (X.@Marker fb && true);\n" + 
+				"	        ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"21. ERROR in X.java (at line 24)\n" + 
+				"	fb = (X.@Marker fb || true);\n" + 
+				"	        ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"22. ERROR in X.java (at line 25)\n" + 
+				"	x = (X.@Marker fb ? 10 : 10);\n" + 
+				"	       ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in annotations with qualified names.
+	   This test is disabled. Now the grammar itself forbids annotations in the said place by using the production
+	   AnnotationName ::= '@' UnannotatableName. We don't want to add tests that will be fragile and unstable due to 
+	   syntax. If a construct is provably not parsed at the grammar level, that ought to be good enough.
+	*/
+	public void test054() throws Exception {
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names used as annotation values.
+	public void test055() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"@interface Annot {\n" +
+					"	String bar();\n" +
+					"}\n" +
+					"@Annot(bar = X. @Marker s)\n" +
+					"public class X {\n" +
+					"	final static String s = \"\";\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	@Annot(bar = X. @Marker s)\n" + 
+				"	                ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names that are postfix expressions.
+	public void test056() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static int x;\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x;\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x;\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified names used in array access.
+	public void test057() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static int x[];\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x[0];\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x[0];\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name with type arguments used in method invocation.
+	public void test058() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static X x;\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x.<String> foo();\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x.<String> foo();\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. WARNING in X.java (at line 4)\n" + 
+				"	return X.@Marker x.<String> foo();\n" + 
+				"	                    ^^^^^^\n" + 
+				"Unused type arguments for the non generic method foo() of type X; it should not be parameterized with arguments <String>\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in method invocation.
+	public void test059() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static X x;\n" +
+					"    int foo() {\n" +
+					"        return X.@Marker x. @Blah foo();\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x. @Blah foo();\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	return X.@Marker x. @Blah foo();\n" + 
+				"	                    ^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in class instance creation
+	public void test060() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static Y y;\n" +
+					"    class Y {\n" +
+					"        class Z {\n" +
+					"            void foo() {\n" +
+					"                Z z = X. @Marker y.new Z();\n" +
+					"            }\n" +
+					"        }\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 6)\n" + 
+				"	Z z = X. @Marker y.new Z();\n" + 
+				"	         ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=383596 -- reject annotations in qualified name used in class instance creation
+	public void test061() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"    static X x;\n" +
+					"    X getX() {\n" +
+					"        return (X.@Marker x);\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	return (X.@Marker x);\n" + 
+				"	          ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test062() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	public <T> @Marker Object foo() {\n" +
+					"	}\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	public <T> @Marker Object foo() {\n" + 
+				"	           ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	public void test063() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = @Marker int.class;\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	Object o = @Marker int.class;\n" + 
+				"	           ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	public void test064() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"@interface X {\n" +
+					"	<T> @Marker String foo();\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	<T> @Marker String foo();\n" + 
+				"	    ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	<T> @Marker String foo();\n" + 
+				"	                   ^^^^^\n" + 
+				"Annotation attributes cannot be generic\n" + 
+				"----------\n");
+	}
+	public void test065() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = new <String> @Marker X();\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. WARNING in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X();\n" + 
+				"	                ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X() of type X; it should not be parameterized with arguments <String>\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X();\n" + 
+				"	                        ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	public void test066() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = new X().new <String> @Marker X();\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new X().new <String> @Marker X();\n" + 
+				"	                                ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new X().new <String> @Marker X();\n" + 
+				"	                                ^^^^^^^^^\n" + 
+				"X.X cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test067() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = x.new <String> @Marker X() {};\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	Object o = x.new <String> @Marker X() {};\n" + 
+				"	           ^\n" + 
+				"x cannot be resolved to a variable\n" + 
+				"----------\n");
+	}
+	public void test068() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	Object o = new <String> @Marker X() {};\n" +
+					"}\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. WARNING in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X() {};\n" + 
+				"	                ^^^^^^\n" + 
+				"Unused type arguments for the non generic constructor X() of type X; it should not be parameterized with arguments <String>\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = new <String> @Marker X() {};\n" + 
+				"	                        ^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385293
+	public void test069() throws Exception {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"class X<final T> {\n" +
+					"	Object o = (Object) (public X<final String>) null;\n" + 
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	class X<final T> {\n" + 
+				"	        ^^^^^\n" + 
+				"Syntax error on token \"final\", delete this token\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	Object o = (Object) (public X<final String>) null;\n" + 
+				"	                     ^^^^^^\n" + 
+				"Syntax error on token \"public\", delete this token\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 2)\n" + 
+				"	Object o = (Object) (public X<final String>) null;\n" + 
+				"	                              ^^^^^\n" + 
+				"Syntax error on token \"final\", delete this token\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=388085
+	public void test0388085() {
+		this.runNegativeTest(
+				new String[] {"X.java",
+						"class X {\n" +
+						"	public void main() {\n" +
+						"		final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;" +
+						"		one = null;\n" +
+						"	}\n" +
+						"}\n" +
+						"class One<R> {}\n" +
+						"class Two<S> {}\n" +
+						"class Three<T> {}\n" +
+						"class Four<U, V> {}\n"},
+							"----------\n" + 
+							"1. ERROR in X.java (at line 3)\n" + 
+							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+							"	           ^^^^^^\n" + 
+							"Marker cannot be resolved to a type\n" + 
+							"----------\n" + 
+							"2. ERROR in X.java (at line 3)\n" + 
+							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+							"	                                 ^^^^^^\n" + 
+							"Marker cannot be resolved to a type\n" + 
+							"----------\n" + 
+							"3. ERROR in X.java (at line 3)\n" + 
+							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+							"	                                                                      ^^^^^^\n" + 
+							"Marker cannot be resolved to a type\n" + 
+							"----------\n" + 
+							"4. ERROR in X.java (at line 3)\n" + 
+							"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+							"	                                                                                              ^^^^^^\n" + 
+							"Marker cannot be resolved to a type\n" + 
+							"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=388085
+	public void test0388085a() {
+		this.runNegativeTest(
+				new String[] {"X.java",
+						"import java.lang.annotation.Target;\n" + 
+						"import static java.lang.annotation.ElementType.*;\n" + 
+						"class X {\n" +
+						"	public void main() {\n" +
+						"		final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;" +
+						"		one = null;\n" +
+						"	}\n" +
+						"}\n" +
+						"class One<R> {}\n" +
+						"class Two<S> {}\n" +
+						"class Three<T> {}\n" +
+						"class Four<U, V> {}\n" +
+						"@interface Marker {}"},
+						"----------\n" + 
+						"1. ERROR in X.java (at line 5)\n" + 
+						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+						"	          ^^^^^^^\n" + 
+						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+						"----------\n" + 
+						"2. ERROR in X.java (at line 5)\n" + 
+						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+						"	                                ^^^^^^^\n" + 
+						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+						"----------\n" + 
+						"3. ERROR in X.java (at line 5)\n" + 
+						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+						"	                                                                     ^^^^^^^\n" + 
+						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+						"----------\n" + 
+						"4. ERROR in X.java (at line 5)\n" + 
+						"	final One<@Marker ? extends Two<@Marker ? super Three<? extends Four<@Marker ? super String, @Marker ? extends Object>>>> one = null;		one = null;\n" + 
+						"	                                                                                             ^^^^^^^\n" + 
+						"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+						"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=390882
+	public void test0390882() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.Target;\n" +
+					"import static java.lang.annotation.ElementType.*;\n" +
+					"public class X {    \n " +
+					"	Object o1 = (@Marker java.lang.Integer) null;   // 1. Right.\n" +
+					"	Object o2 = (java. @Marker lang.Integer) null;  // 2. Wrong.\n" +
+					"	Object o3 = (java.lang. @Marker Integer) null;  // 3. Legal.\n" +
+					"	public void foo(java. @Marker lang.Integer arg) {}\n" +
+					"	public void bar(java.lang. @Marker Integer arg) {}\n" +
+					"	public void foobar(@Marker java.lang.Integer arg) {}\n" +
+					"}\n" +
+					"@Target(TYPE_USE)\n" +
+					"@interface Marker {}\n",
+
+					"java/lang/annotation/ElementType.java",
+					"package java.lang.annotation;\n" +
+					"public enum ElementType {\n" +
+					"    TYPE,\n" +
+					"    FIELD,\n" +
+					"    METHOD,\n" +
+					"    PARAMETER,\n" +
+					"    CONSTRUCTOR,\n" +
+					"    LOCAL_VARIABLE,\n" +
+					"    ANNOTATION_TYPE,\n" +
+					"    PACKAGE,\n" +
+					"    TYPE_PARAMETER,\n" +
+					"    TYPE_USE\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Object o1 = (@Marker java.lang.Integer) null;   // 1. Right.\n" + 
+				"	             ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 5)\n" + 
+				"	Object o2 = (java. @Marker lang.Integer) null;  // 2. Wrong.\n" + 
+				"	                   ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 7)\n" + 
+				"	public void foo(java. @Marker lang.Integer arg) {}\n" + 
+				"	                      ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 9)\n" + 
+				"	public void foobar(@Marker java.lang.Integer arg) {}\n" + 
+				"	                   ^^^^^^^\n" + 
+				"The annotation @Marker is disallowed for this location\n" + 
+				"----------\n");
+	}
+	public void test0390882a() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.Target;\n" +
+					"import static java.lang.annotation.ElementType.*;\n" +
+					"public class X {    \n " +
+					"	Object o1 = (java. @Marker @Annot lang.Integer) null;  // 1. Wrong.\n" +
+					"	Object o2 = (java.lang. @Marker @Annot Integer) null;  // 2. Legal\n" +
+					"	Object o3 = (java.@lang lang) null;  // 3. Wrong.\n" +
+					"}\n" +
+					"@Target(TYPE_USE)\n" +
+					"@interface Marker {}\n" +
+					"@Target(TYPE_USE)\n" +
+					"@interface Annot {}",
+
+					"java/lang/annotation/ElementType.java",
+					"package java.lang.annotation;\n" +
+					"public enum ElementType {\n" +
+					"    TYPE,\n" +
+					"    FIELD,\n" +
+					"    METHOD,\n" +
+					"    PARAMETER,\n" +
+					"    CONSTRUCTOR,\n" +
+					"    LOCAL_VARIABLE,\n" +
+					"    ANNOTATION_TYPE,\n" +
+					"    PACKAGE,\n" +
+					"    TYPE_PARAMETER,\n" +
+					"    TYPE_USE\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Object o1 = (java. @Marker @Annot lang.Integer) null;  // 1. Wrong.\n" + 
+				"	                   ^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 6)\n" + 
+				"	Object o3 = (java.@lang lang) null;  // 3. Wrong.\n" + 
+				"	             ^^^^^^^^^^^^^^^\n" + 
+				"java.lang cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void test0390882b() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.Target;\n" +
+					"import static java.lang.annotation.ElementType.*;\n" +
+					"public class X {    \n " +
+					"	Object o1 = (@Marker @Annot java.util.List<String>) null; 	// 1. Wrong.\n" +
+					"	Object o2 = (java. @Marker @Annot lang.Integer[]) null;		// 2. Wrong.\n" +
+					"	Object o3 = (@Marker @Annot java.util.List<String>[]) null; // 3. Wrong.\n" +
+					"	Object o4 = (java.util.List<String> @Marker @Annot []) null; // 4. Right.\n" +
+					"	Object o5 = (java.lang.Integer @Marker @Annot []) null;	// 5. Right.\n" +
+					"}\n" +
+					"@Target(TYPE_USE)\n" +
+					"@interface Marker {}\n" +
+					"@Target(TYPE_USE)\n" +
+					"@interface Annot {}",
+
+					"java/lang/annotation/ElementType.java",
+					"package java.lang.annotation;\n" +
+					"public enum ElementType {\n" +
+					"    TYPE,\n" +
+					"    FIELD,\n" +
+					"    METHOD,\n" +
+					"    PARAMETER,\n" +
+					"    CONSTRUCTOR,\n" +
+					"    LOCAL_VARIABLE,\n" +
+					"    ANNOTATION_TYPE,\n" +
+					"    PACKAGE,\n" +
+					"    TYPE_PARAMETER,\n" +
+					"    TYPE_USE\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	Object o1 = (@Marker @Annot java.util.List<String>) null; 	// 1. Wrong.\n" + 
+				"	             ^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 5)\n" + 
+				"	Object o2 = (java. @Marker @Annot lang.Integer[]) null;		// 2. Wrong.\n" + 
+				"	                   ^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 6)\n" + 
+				"	Object o3 = (@Marker @Annot java.util.List<String>[]) null; // 3. Wrong.\n" + 
+				"	             ^^^^^^^^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=385137
+	public void test0385137() {
+		this.runNegativeTest(
+				new String[]{ "A.java",
+				"package p;" +
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"public class A<T> { \n" +
+				"	static class B<T> {" +
+				"		static class C<K, V> {" +
+				"		}	" +
+				"	}\n" +
+				"   public void foo() {\n" +
+				"		Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" +
+				"		Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" +
+				"   }\n" +
+				"}\n" +
+				"@Target(TYPE_USE)\n" + 
+				"@interface Marker {}\n" +
+				"@Target(TYPE_USE)\n" + 
+				"@interface Annot {}\n",
+
+				"java/lang/annotation/ElementType.java",
+				"package java.lang.annotation;\n" +
+				"public enum ElementType {\n" +
+				"    TYPE,\n" +
+				"    FIELD,\n" +
+				"    METHOD,\n" +
+				"    PARAMETER,\n" +
+				"    CONSTRUCTOR,\n" +
+				"    LOCAL_VARIABLE,\n" +
+				"    ANNOTATION_TYPE,\n" +
+				"    PACKAGE,\n" +
+				"    TYPE_PARAMETER,\n" +
+				"    TYPE_USE\n" +
+				"}\n"},
+					"----------\n" + 
+					"1. ERROR in A.java (at line 6)\n" + 
+					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
+					"	            ^^^^^^^^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"2. WARNING in A.java (at line 6)\n" + 
+					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
+					"	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+					"A.B.C is a raw type. References to generic type A<T>.B<T>.C<K,V> should be parameterized\n" + 
+					"----------\n" + 
+					"3. ERROR in A.java (at line 6)\n" + 
+					"	Object o = (@Marker @Annot A.@Marker B.@Marker C) null;\n" + 
+					"	                             ^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"4. ERROR in A.java (at line 7)\n" + 
+					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
+					"	             ^^^^^^^\n" + 
+					"Syntax error, type annotations are illegal here\n" + 
+					"----------\n" + 
+					"5. WARNING in A.java (at line 7)\n" + 
+					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
+					"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+					"A.B.C is a raw type. References to generic type A<T>.B<T>.C<K,V> should be parameterized\n" + 
+					"----------\n" + 
+					"6. ERROR in A.java (at line 7)\n" + 
+					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
+					"	                       ^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"7. ERROR in A.java (at line 7)\n" + 
+					"	Object o2 = (@Marker p.@Marker A.@Marker B.@Marker C) null;\n" + 
+					"	                                 ^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n");
+	}
+	public void test0385137a() {
+		this.runNegativeTest(
+				new String[]{"A.java",
+				"package p;" +
+				"import java.lang.annotation.Target;\n" + 
+				"import static java.lang.annotation.ElementType.*;\n" + 
+				"public class A { \n" +
+				"	static class B<T> {" +
+				"		static class C<K, V> {" +
+				"		}	" +
+				"	}\n" +
+				"   public void foo() {\n" +
+				"		Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" +
+				"		Object o2 = (@Marker @Annot A.@Annot B.C<Integer, String>) null;\n" +
+				"		Object o5 = (@Marker @Annot A.B<String>[]) null;\n" +
+				"   }\n" +
+				"}\n" +
+				"@Target(TYPE_USE)\n" + 
+				"@interface Marker {}\n" +
+				"@Target(TYPE_USE)\n" + 
+				"@interface Annot {}\n",
+
+				"java/lang/annotation/ElementType.java",
+				"package java.lang.annotation;\n" +
+				"public enum ElementType {\n" +
+				"    TYPE,\n" +
+				"    FIELD,\n" +
+				"    METHOD,\n" +
+				"    PARAMETER,\n" +
+				"    CONSTRUCTOR,\n" +
+				"    LOCAL_VARIABLE,\n" +
+				"    ANNOTATION_TYPE,\n" +
+				"    PACKAGE,\n" +
+				"    TYPE_PARAMETER,\n" +
+				"    TYPE_USE\n" +
+				"}\n",
+				},
+				"----------\n" + 
+					"1. ERROR in A.java (at line 6)\n" + 
+					"	Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" + 
+					"	             ^^^^^^^\n" + 
+					"Syntax error, type annotations are illegal here\n" + 
+					"----------\n" + 
+					"2. ERROR in A.java (at line 6)\n" + 
+					"	Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" + 
+					"	                       ^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"3. ERROR in A.java (at line 6)\n" + 
+					"	Object o1 = (@Marker p.@Marker A.@Marker B.@Marker C[]) null;\n" + 
+					"	                                 ^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"4. ERROR in A.java (at line 7)\n" + 
+					"	Object o2 = (@Marker @Annot A.@Annot B.C<Integer, String>) null;\n" + 
+					"	             ^^^^^^^^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"5. ERROR in A.java (at line 7)\n" + 
+					"	Object o2 = (@Marker @Annot A.@Annot B.C<Integer, String>) null;\n" + 
+					"	                              ^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n" + 
+					"6. ERROR in A.java (at line 8)\n" + 
+					"	Object o5 = (@Marker @Annot A.B<String>[]) null;\n" + 
+					"	             ^^^^^^^^^^^^^^\n" + 
+					"Type annotations are not allowed on type names used to access static members\n" + 
+					"----------\n");
+	}
+	public void testBug391196() {
+		this.runNegativeTest(
+				new String[]{
+					"p/Bug391196.java",
+					"package p;\n" +
+					"public class Bug391196 {\n" +
+					"	@Marker\n" +
+					"	public class X<@Marker @Marker2 T> {\n" +
+					"		@Marker @Marker2 X(@Marker int i) {}\n" +
+					"		@Unresolved X() {}\n" +
+					"	}\n" +
+					"	@Marker\n" +
+					"	enum Color {RED, BLUE}\n" +
+					"	@Marker\n" +
+					"	interface Inter {}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {}\n" + 
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker2 {}\n" + 
+					"}\n",
+					"java/lang/annotation/ElementType.java",
+					"package java.lang.annotation;\n" +
+					"public enum ElementType {\n" +
+					"    TYPE,\n" +
+					"    FIELD,\n" +
+					"    METHOD,\n" +
+					"    PARAMETER,\n" +
+					"    CONSTRUCTOR,\n" +
+					"    LOCAL_VARIABLE,\n" +
+					"    ANNOTATION_TYPE,\n" +
+					"    PACKAGE,\n" +
+					"    TYPE_PARAMETER,\n" +
+					"    TYPE_USE\n" +
+					"}\n",
+				},
+				"----------\n" + 
+				"1. ERROR in p\\Bug391196.java (at line 6)\n" + 
+				"	@Unresolved X() {}\n" + 
+				"	 ^^^^^^^^^^\n" + 
+				"Unresolved cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void testBug391315() {
+		this.runNegativeTest(
+				new String[]{
+				"X.java",
+				"class X<T> {\n" +
+				"	X<@Marker ?> l;\n" +
+				"	X<@Marker2 ?> l2;\n" +
+				"	X<@Marker3 ?> l3;\n" +
+				"	class Y {\n" +
+				"		void Y1(Y this) {}\n" +
+				"	}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@interface Marker3 {}\n",
+				"java/lang/annotation/ElementType.java",
+				"package java.lang.annotation;\n" +
+				"public enum ElementType {\n" +
+				"    TYPE,\n" +
+				"    FIELD,\n" +
+				"    METHOD,\n" +
+				"    PARAMETER,\n" +
+				"    CONSTRUCTOR,\n" +
+				"    LOCAL_VARIABLE,\n" +
+				"    ANNOTATION_TYPE,\n" +
+				"    PACKAGE,\n" +
+				"    TYPE_PARAMETER,\n" +
+				"    TYPE_USE\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	X<@Marker ?> l;\n" + 
+				"	  ^^^^^^^\n" + 
+				"The annotation @Marker is disallowed for this location\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	X<@Marker3 ?> l3;\n" + 
+				"	  ^^^^^^^^\n" + 
+				"Annotation types that do not specify explicit target element types cannot be applied here\n" + 
+				"----------\n");
+	}
+	public void testBug391315a() {
+		this.runNegativeTest(
+				new String[]{
+				"X.java",
+				"public class X<@Marker T> {\n" +
+				"	@Marker T t;\n" +
+				"	T t2 = (@Marker T) null;\n" +
+				"}\n" +
+				"class X2<@Marker2 T> {\n" +
+				"	@Marker2 T t;\n" +
+				"	T t2 = (@Marker2 T) null;\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
+				"@interface Marker2 {}",
+				"java/lang/annotation/ElementType.java",
+				"package java.lang.annotation;\n" +
+				"public enum ElementType {\n" +
+				"    TYPE,\n" +
+				"    FIELD,\n" +
+				"    METHOD,\n" +
+				"    PARAMETER,\n" +
+				"    CONSTRUCTOR,\n" +
+				"    LOCAL_VARIABLE,\n" +
+				"    ANNOTATION_TYPE,\n" +
+				"    PACKAGE,\n" +
+				"    TYPE_PARAMETER,\n" +
+				"    TYPE_USE\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 6)\n" + 
+				"	@Marker2 T t;\n" + 
+				"	^^^^^^^^\n" + 
+				"The annotation @Marker2 is disallowed for this location\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	T t2 = (@Marker2 T) null;\n" + 
+				"	        ^^^^^^^^\n" + 
+				"The annotation @Marker2 is disallowed for this location\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391500
+	public void testBug391500() {
+		this.runNegativeTest(
+				new String[]{
+				"X.java",
+				"public class X {\n" +
+				"	class Y {\n" +
+				"		class Z {\n" +
+				"		}\n" +
+				"		Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" +
+				"		Z z3 = new @Marker Z(){};\n" +
+				"	};\n" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" + 
+				"	            ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 5)\n" + 
+				"	Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" + 
+				"	                            ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 5)\n" + 
+				"	Z z1 = new @Marker X().new @Marker Y().new @Marker Z();\n" + 
+				"	                                            ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 6)\n" + 
+				"	Z z3 = new @Marker Z(){};\n" + 
+				"	            ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	public void testBug391464() {
+		this.runNegativeTest(
+				new String[]{
+				"X.java",
+				"public class X<T> {\n" +
+				"	public void foo() {\n" +
+				"		Object o = (X @Marker []) null;\n" +
+				"		o = (java.lang.String @Marker []) null;\n" +
+				"		o = (X<String> @Marker []) null;\n" +
+				"		o = (java.util.List<String> @Marker []) null;\n" +
+				"		if (o == null) return;\n" +
+				"	}" +
+				"}\n"},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 3)\n" + 
+				"	Object o = (X @Marker []) null;\n" + 
+				"	               ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	o = (java.lang.String @Marker []) null;\n" + 
+				"	                       ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 5)\n" + 
+				"	o = (X<String> @Marker []) null;\n" + 
+				"	                ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 6)\n" + 
+				"	o = (java.util.List<String> @Marker []) null;\n" + 
+				"	                             ^^^^^^\n" + 
+				"Marker cannot be resolved to a type\n" + 
+				"----------\n");
+	}	
+	public void testBug391464_2() {
+		this.runNegativeTest(
+				new String[]{
+				"X.java",
+				"public class X  {\n" +
+				"	class Y {\n" +
+				"		class Z {}\n" +
+				"	}\n" +
+				"	@M X.@M Y.@Unreported Z z = null;\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface M {\n" +
+				"}\n",
+				
+				"java/lang/annotation/ElementType.java",
+				"package java.lang.annotation;\n" +
+				"public enum ElementType {\n" +
+				"    TYPE,\n" +
+				"    FIELD,\n" +
+				"    METHOD,\n" +
+				"    PARAMETER,\n" +
+				"    CONSTRUCTOR,\n" +
+				"    LOCAL_VARIABLE,\n" +
+				"    ANNOTATION_TYPE,\n" +
+				"    PACKAGE,\n" +
+				"    TYPE_PARAMETER,\n" +
+				"    TYPE_USE\n" +
+				"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	@M X.@M Y.@Unreported Z z = null;\n" + 
+				"	           ^^^^^^^^^^\n" + 
+				"Unreported cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391108
+	public void testBug391108() {
+		this.runNegativeTest(
+				new String[]{
+						"X.java",
+						"public class X {\n" +
+						"	@Marker @Marker2 @Marker3 public void foo() {}\n" +
+						"	@Marker @Marker2 @Marker3 void foo2() {}\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.METHOD)\n" +
+						"@interface Marker2 {}\n" +
+						"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.METHOD})\n" +
+						"@interface Marker3 {}",
+						"java/lang/annotation/ElementType.java",
+						"package java.lang.annotation;\n" +
+						"public enum ElementType {\n" +
+						"    TYPE,\n" +
+						"    FIELD,\n" +
+						"    METHOD,\n" +
+						"    PARAMETER,\n" +
+						"    CONSTRUCTOR,\n" +
+						"    LOCAL_VARIABLE,\n" +
+						"    ANNOTATION_TYPE,\n" +
+						"    PACKAGE,\n" +
+						"    TYPE_PARAMETER,\n" +
+						"    TYPE_USE\n" +
+						"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 2)\n" + 
+				"	@Marker @Marker2 @Marker3 public void foo() {}\n" + 
+				"	^^^^^^^\n" + 
+				"Type annotation is illegal for a method that returns void\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 3)\n" + 
+				"	@Marker @Marker2 @Marker3 void foo2() {}\n" + 
+				"	^^^^^^^\n" + 
+				"Type annotation is illegal for a method that returns void\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392119
+	public void test392119() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java", //-----------------------------------------------------------------------
+				"@Marker78 @Marker8 @Marker7\n" +
+				"public class X {\n" +
+				"    Zork z;\n" +
+				"}\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.TYPE})\n" +
+				"@interface Marker78 {\n" +
+				"}\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE})\n" +
+				"@interface Marker7 {\n" +
+				"}\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})\n" +
+				"@interface Marker8 {\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	Zork z;\n" + 
+			"	^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n",
+			null,
+			true, // flush output
+			null,
+			true, // generate output
+			false,
+			false);
+		String expectedOutput =
+				"  RuntimeInvisibleAnnotations: \n" + 
+				"    #24 @Marker78(\n" + 
+				"    )\n" + 
+				"    #25 @Marker8(\n" + 
+				"    )\n" + 
+				"    #26 @Marker7(\n" + 
+				"    )\n" + 
+				"  Attribute: MissingTypes Length: 4\n" + 
+				"}";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392119, variant with explicit class file retention.
+	public void test392119b() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java", //-----------------------------------------------------------------------
+				"@Marker78 @Marker8 @Marker7\n" +
+				"public class X {\n" +
+				"    Zork z;\n" +
+				"}\n" +
+				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.TYPE})\n" +
+				"@interface Marker78 {\n" +
+				"}\n" +
+				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE})\n" +
+				"@interface Marker7 {\n" +
+				"}\n" +
+				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.CLASS)\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})\n" +
+				"@interface Marker8 {\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	Zork z;\n" + 
+			"	^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n",
+			null,
+			true, // flush output
+			null,
+			true, // generate output
+			false,
+			false);
+		String expectedOutput =
+				"  RuntimeInvisibleAnnotations: \n" + 
+				"    #24 @Marker78(\n" + 
+				"    )\n" + 
+				"    #25 @Marker8(\n" + 
+				"    )\n" + 
+				"    #26 @Marker7(\n" + 
+				"    )\n" + 
+				"  Attribute: MissingTypes Length: 4\n" + 
+				"}";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392119, variant with explicit runtime retention.
+	public void test392119c() throws Exception {
+		this.runNegativeTest(
+			new String[] {
+				"X.java", //-----------------------------------------------------------------------
+				"@Marker78 @Marker8 @Marker7\n" +
+				"public class X {\n" +
+				"    Zork z;\n" +
+				"}\n" +
+				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE, java.lang.annotation.ElementType.TYPE})\n" +
+				"@interface Marker78 {\n" +
+				"}\n" +
+				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE})\n" +
+				"@interface Marker7 {\n" +
+				"}\n" +
+				"@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)\n" +
+				"@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})\n" +
+				"@interface Marker8 {\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	Zork z;\n" + 
+			"	^^^^\n" + 
+			"Zork cannot be resolved to a type\n" + 
+			"----------\n",
+			null,
+			true, // flush output
+			null,
+			true, // generate output
+			false,
+			false);
+		String expectedOutput =
+				"  RuntimeVisibleAnnotations: \n" + 
+				"    #24 @Marker78(\n" + 
+				"    )\n" + 
+				"    #25 @Marker8(\n" + 
+				"    )\n" + 
+				"    #26 @Marker7(\n" + 
+				"    )\n";
+		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=394355
+	public void testBug394355() {
+		this.runNegativeTest(
+			new String[]{
+				"X.java",
+				"import java.lang.annotation.Target;\n" +
+				"import static java.lang.annotation.ElementType.*;\n" +
+				"public class X {\n" +
+				"	public void foo(@Marker @Marker2 X this) {}\n" +
+				"	class Y {\n" +
+				"		Y(@Marker @Marker2 X X.this) {}\n" +
+				"	}\n" +
+				"}\n" +
+				"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@Target ({METHOD, PARAMETER, TYPE, PACKAGE, FIELD, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER})\n" +
+				"@interface Marker2 {}",
+				"java/lang/annotation/ElementType.java",
+				"package java.lang.annotation;\n" +
+				"public enum ElementType {\n" +
+				"    TYPE,\n" +
+				"    FIELD,\n" +
+				"    METHOD,\n" +
+				"    PARAMETER,\n" +
+				"    CONSTRUCTOR,\n" +
+				"    LOCAL_VARIABLE,\n" +
+				"    ANNOTATION_TYPE,\n" +
+				"    PACKAGE,\n" +
+				"    TYPE_PARAMETER,\n" +
+				"    TYPE_USE\n" +
+				"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 4)\n" + 
+			"	public void foo(@Marker @Marker2 X this) {}\n" + 
+			"	                        ^^^^^^^^\n" + 
+			"The annotation @Marker2 is disallowed for this location\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 6)\n" + 
+			"	Y(@Marker @Marker2 X X.this) {}\n" + 
+			"	          ^^^^^^^^\n" + 
+			"The annotation @Marker2 is disallowed for this location\n" + 
+			"----------\n"); 
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399453
+	public void testBug399453() {
+		this.runNegativeTest(
+				new String[]{
+					"X.java",
+					"import java.lang.annotation.Target;\n" +
+					"import static java.lang.annotation.ElementType.*;\n" +
+					"public class X {\n" +
+					"	public void foo() {\n" +
+					"		int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] @Marker @Marker2 [];\n" +
+					"		int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker X.bar2(2)] @Marker @Marker2 [];\n" +
+					"	}\n" +
+					"	public int bar() {\n" +
+					"		return 2;\n" +
+					"	}\n" +
+					"	public static int bar2(int k) {\n" +
+					"		return k;\n" + 
+					"	}\n" +
+					"}\n" +
+					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {}\n" +
+					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker2 {}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] @Marker @Marker2 [];\n" + 
+				"	                                                                               ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 6)\n" + 
+				"	int @Marker [][][] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker X.bar2(2)] @Marker @Marker2 [];\n" + 
+				"	                                                                               ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n"); 
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=399453
+	public void testBug391894() {
+		this.runNegativeTest(
+				new String[]{
+					"X.java",
+					"import java.lang.annotation.Target;\n" +
+					"import static java.lang.annotation.ElementType.*;\n" +
+					"public class X {\n" +
+					"	public void foo() {\n" +
+					"		int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" +
+					"		int @Marker [] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" +
+					"	}\n" +
+					"	public int bar() {\n" +
+					"		return 2;\n" +
+					"	}\n" +
+					"}\n" +
+					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {}\n" +
+					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker2 {}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 5)\n" + 
+				"	int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
+				"	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Type mismatch: cannot convert from int[][] to int[][][]\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 5)\n" + 
+				"	int @Marker [][][] i = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
+				"	                                                                               ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 6)\n" + 
+				"	int @Marker [] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
+				"	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Type mismatch: cannot convert from int[][] to int[]\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 6)\n" + 
+				"	int @Marker [] j = new @Marker2 int @Marker @Marker2 [2] @Marker @Marker2 [@Marker bar()] ;\n" + 
+				"	                                                                           ^^^^^^^\n" + 
+				"Syntax error, type annotations are illegal here\n" + 
+				"----------\n"); 
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=402618, [1.8][compiler] Compiler fails to resolve type annotations on method/constructor references
+	public void test402618() {
+		this.runNegativeTest(
+				new String[]{
+					"X.java",
+					"import java.util.List;\n" +
+					"interface I {\n" +
+					"	void foo(List<String> l);\n" +
+					"}\n" +
+					"\n" +
+					"public class X {\n" +
+					"	public void main(String[] args) {\n" +
+					"		I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" +
+					"	}\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 8)\n" + 
+				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
+				"	       ^^^^^^^^\n" + 
+				"Readonly cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 8)\n" + 
+				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
+				"	                      ^^^^^^^\n" + 
+				"English cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"3. WARNING in X.java (at line 8)\n" + 
+				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
+				"	                                        ^^^^^^^^^^^^^^^^^^^^\n" + 
+				"Unused type arguments for the non generic method size() of type List<String>; it should not be parameterized with arguments <Integer>\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 8)\n" + 
+				"	I i = @Readonly List<@English String>::<@NonNegative Integer>size;\n" + 
+				"	                                         ^^^^^^^^^^^\n" + 
+				"NonNegative cannot be resolved to a type\n" + 
+				"----------\n"); 
+		}
+	public void testBug403132() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X {\n" +
+					"	class Y {\n" +
+					"		class Z {\n" +
+					"			public Z (@A X.@B Y Y.this, String str) {}\n" +
+					"    	 	public void foo (@A X.@B Y.@C Z this, String str) {}\n" +
+					"		}\n" +
+					"    }\n" +
+					"}\n"
+				}, 
+				"----------\n" + 
+				"1. ERROR in X.java (at line 4)\n" + 
+				"	public Z (@A X.@B Y Y.this, String str) {}\n" + 
+				"	           ^\n" + 
+				"A cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 4)\n" + 
+				"	public Z (@A X.@B Y Y.this, String str) {}\n" + 
+				"	                ^\n" + 
+				"B cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 5)\n" + 
+				"	public void foo (@A X.@B Y.@C Z this, String str) {}\n" + 
+				"	                  ^\n" + 
+				"A cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 5)\n" + 
+				"	public void foo (@A X.@B Y.@C Z this, String str) {}\n" + 
+				"	                       ^\n" + 
+				"B cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"5. ERROR in X.java (at line 5)\n" + 
+				"	public void foo (@A X.@B Y.@C Z this, String str) {}\n" + 
+				"	                            ^\n" + 
+				"C cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403410
+	public void testBug403410() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.Target;\n" +
+					"import static java.lang.annotation.ElementType.*;\n" +
+					"@Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface A {}\n" +
+					"public class X {\n" +
+					"	class Y {\n" +
+					"		public Y (final @A X X.this) {}\n" +
+					"		public Y (static @A X X.this, int i) {}\n" +
+					"		public void foo(final @A Y this) {}\n" +
+					"		public void foo(static @A Y this, int i) {}\n" +
+					"}\n}"},
+					"----------\n" + 
+					"1. ERROR in X.java (at line 7)\n" + 
+					"	public Y (final @A X X.this) {}\n" + 
+					"	          ^^^^^^^^^^^^^^^^^\n" + 
+					"Syntax error, modifiers are not allowed here\n" + 
+					"----------\n" +
+					"2. ERROR in X.java (at line 8)\n" + 
+					"	public Y (static @A X X.this, int i) {}\n" + 
+					"	          ^^^^^^^^^^^^^^^^^^\n" + 
+					"Syntax error, modifiers are not allowed here\n" + 
+					"----------\n" + 
+					"3. ERROR in X.java (at line 9)\n" + 
+					"	public void foo(final @A Y this) {}\n" + 
+					"	                ^^^^^^^^^^^^^^^\n" + 
+					"Syntax error, modifiers are not allowed here\n" + 
+					"----------\n" + 
+					"4. ERROR in X.java (at line 10)\n" + 
+					"	public void foo(static @A Y this, int i) {}\n" + 
+					"	                ^^^^^^^^^^^^^^^^\n" + 
+					"Syntax error, modifiers are not allowed here\n" + 
+					"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=403581,  [1.8][compiler] Compile error on varargs annotations.
+	public void test403581() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.util.List;\n" +
+					"public class X {\n" +
+					"	void foo(List<String> @Marker ... ls) {}\n" +
+					"}\n" +
+					"@java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. WARNING in X.java (at line 3)\n" + 
+				"	void foo(List<String> @Marker ... ls) {}\n" + 
+				"	                                  ^^\n" + 
+				"Type safety: Potential heap pollution via varargs parameter ls\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=392671, [1.8][recovery] NPE with a method with explicit this and a following incomplete parameter
+	public void test392671() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"class X {\n" +
+					"    public void foobar(X this, int, int k) {} // NPE!\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	class X {\n" + 
+				"	        ^\n" + 
+				"Syntax error, insert \"}\" to complete ClassBody\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 2)\n" + 
+				"	public void foobar(X this, int, int k) {} // NPE!\n" + 
+				"	                           ^^^\n" + 
+				"Syntax error, insert \"... VariableDeclaratorId\" to complete FormalParameter\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 3)\n" + 
+				"	}\n" + 
+				"	^\n" + 
+				"Syntax error on token \"}\", delete this token\n" + 
+				"----------\n");
+	}
+	// [1.8][compiler] Missing expected error for incorrect placement of type annotation (https://bugs.eclipse.org/bugs/show_bug.cgi?id=406587)
+	public void test406587() {
+		this.runNegativeTest(
+				new String[] {
+					"p/X.java",
+					"package p;\n" +
+					"import java.lang.annotation.*;\n" +
+					"public class X {\n" +
+					"	@B(1) @A(1) String field1;\n" +
+					"	@B @A X.Y field3;\n" +
+					"	@A @B p.X.Y field4;\n" +
+					"	@B(1) @A(1) java.lang.@A(1) @B(1) String field2;\n" +
+					"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" +
+					"		@A(1) @B(1)  String local1;\n" +
+					"		@A(1) @B(1) java.lang.  @B(1) @A(1) String local2;\n" +
+					"		@B @A X.Y local3;\n" +
+					"		@B @A p.X.Y local4;\n" +
+					"		@B @A p.q.X local5;\n" +
+					"		return null;\n" +
+					"	}\n" +
+					"	class Y {}" +
+					"}\n" +
+					"@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\n" +
+					"@interface A {\n" +
+					"	int value() default -1;\n" +
+					"}\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface B {\n" +
+					"	int value() default -1;\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in p\\X.java (at line 6)\n" + 
+				"	@A @B p.X.Y field4;\n" + 
+				"	   ^^\n" + 
+				"The annotation @B is disallowed for this location\n" + 
+				"----------\n" + 
+				"2. ERROR in p\\X.java (at line 7)\n" + 
+				"	@B(1) @A(1) java.lang.@A(1) @B(1) String field2;\n" + 
+				"	^^\n" + 
+				"The annotation @B is disallowed for this location\n" + 
+				"----------\n" + 
+				"3. ERROR in p\\X.java (at line 7)\n" + 
+				"	@B(1) @A(1) java.lang.@A(1) @B(1) String field2;\n" + 
+				"	                      ^^\n" + 
+				"The annotation @A is disallowed for this location\n" + 
+				"----------\n" + 
+				"4. ERROR in p\\X.java (at line 8)\n" + 
+				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
+				"	       ^^\n" + 
+				"The annotation @B is disallowed for this location\n" + 
+				"----------\n" + 
+				"5. ERROR in p\\X.java (at line 8)\n" + 
+				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
+				"	                              ^^\n" + 
+				"The annotation @A is disallowed for this location\n" + 
+				"----------\n" + 
+				"6. ERROR in p\\X.java (at line 8)\n" + 
+				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
+				"	                                                            ^^\n" + 
+				"The annotation @B is disallowed for this location\n" + 
+				"----------\n" + 
+				"7. ERROR in p\\X.java (at line 8)\n" + 
+				"	public @B(1) @A(1) java.lang. @A(1) @B(1)  String foo(@A(1) @B(1) java.lang. @A(1) @B(1) String str1) {\n" + 
+				"	                                                                             ^^\n" + 
+				"The annotation @A is disallowed for this location\n" + 
+				"----------\n" + 
+				"8. ERROR in p\\X.java (at line 10)\n" + 
+				"	@A(1) @B(1) java.lang.  @B(1) @A(1) String local2;\n" + 
+				"	      ^^\n" + 
+				"The annotation @B is disallowed for this location\n" + 
+				"----------\n" + 
+				"9. ERROR in p\\X.java (at line 10)\n" + 
+				"	@A(1) @B(1) java.lang.  @B(1) @A(1) String local2;\n" + 
+				"	                              ^^\n" + 
+				"The annotation @A is disallowed for this location\n" + 
+				"----------\n" + 
+				"10. ERROR in p\\X.java (at line 12)\n" + 
+				"	@B @A p.X.Y local4;\n" + 
+				"	^^\n" + 
+				"The annotation @B is disallowed for this location\n" + 
+				"----------\n" + 
+				"11. ERROR in p\\X.java (at line 13)\n" + 
+				"	@B @A p.q.X local5;\n" + 
+				"	      ^^^\n" + 
+				"p.q cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417076, Eclipse compiler rejects multiple annotations for varargs.
+	public void test417076() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface A {\n" +
+					"}\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface B {\n" +
+					"}\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface C {\n" +
+					"}\n" +
+					"public class X {\n" +
+					"	public @A String foo(int @B @C @D ... args) {\n" +
+					"	      return null;\n" +
+					"	}\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 13)\n" + 
+				"	public @A String foo(int @B @C @D ... args) {\n" + 
+				"	                                ^\n" + 
+				"D cannot be resolved to a type\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=417076, Eclipse compiler rejects multiple annotations for varargs.
+	public void test417076b() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface A {\n" +
+					"}\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface B {\n" +
+					"}\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface C {\n" +
+					"}\n" +
+					"public class X {\n" +
+					"	public @A String foo(int @B @C @A ... args) {\n" +
+					"	      return null;\n" +
+					"	}\n" +
+					"	public @A String goo(int @B @C @A ... args) {\n" +
+					"	}\n" +
+					"}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 16)\n" + 
+				"	public @A String goo(int @B @C @A ... args) {\n" + 
+				"	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+				"This method must return a result of type String\n" + 
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// This is the basic test case which demonstrated the issue for a local variable.
+	// We correctly identified the problem in function bar but failed to do so for foo.
+	public void test415308a() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface Illegal {\n" +
+					"}\n" +
+					"class Y {\n" +
+					"	static class Z {\n" +
+					"		Z() {}\n" +
+					"	}\n" +
+					"}\n" +
+					"class X {\n" +
+					"	Y.Z foo() {\n" +
+					"		@Illegal Y.Z z = null;\n" +
+					"		return z;\n" +
+					"	}\n" +
+					"	Y.Z bar() {\n" +
+					"		Y.Z z = (@Illegal Y.Z)null;\n" +
+					"		return z;\n" +
+					"	}\n" +
+					"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 14)\n" +
+				"	@Illegal Y.Z z = null;\n" +
+				"	^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n" +
+				"2. ERROR in X.java (at line 18)\n" +
+				"	Y.Z z = (@Illegal Y.Z)null;\n" +
+				"	         ^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// This test case is similar to test415308a. SimpleTypes on which annotations are applied are modified to array
+	// types.
+	public void test415308a2() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class Z {\n" +
+						"		Z() {}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"	Y.Z[] foo() {\n" +
+						"		@Illegal Y.Z[] z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.Z[] bar() {\n" +
+						"		Y.Z[] z = (@Illegal Y.Z[])null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 14)\n" +
+				"	@Illegal Y.Z[] z = null;\n" +
+				"	^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n" +
+				"2. ERROR in X.java (at line 18)\n" +
+				"	Y.Z[] z = (@Illegal Y.Z[])null;\n" +
+				"	           ^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// Testing type use annotations on nested types.
+	// We check all the qualifiers as we look for a static type. This test checks if we are able to
+	// go beyond 1 level as part of the loop.
+	public void test415308b() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class YY {\n" +
+						"		class Z {\n" +
+						"			Z() {}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"	Y.YY.Z foo() {\n" +
+						"		@Illegal Y.YY.Z z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.YY.Z foo2() {\n" +
+						"		Y.@Illegal YY.Z z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.YY.Z foo3() {\n" +
+						"		Y.YY.@Illegal Z z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 16)\n" +
+				"	@Illegal Y.YY.Z z = null;\n" +
+				"	^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// This test case is similar to test415308a. SimpleTypes on which annotations are applied are modified to array
+	// types.
+	public void test415308b2() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class YY {\n" +
+						"		class Z {\n" +
+						"			Z() {}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"	Y.YY.Z[] foo() {\n" +
+						"		@Illegal Y.YY.Z[] z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.YY.Z[] foo2() {\n" +
+						"		Y.@Illegal YY.Z[] z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.YY.Z[] foo3() {\n" +
+						"		Y.YY.@Illegal Z[] z = null;\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 16)\n" +
+				"	@Illegal Y.YY.Z[] z = null;\n" +
+				"	^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// The test case is to validate that we report errors for only type annotations and nothing else in case of
+	// of parameter types.
+	public void test415308c() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface IllegalTypeUse {\n" +
+						"}\n" +
+						"@Target({ElementType.TYPE_USE, ElementType.PARAMETER})\n" +
+						"@interface LegalTypeUseParam {\n" +
+						"}\n" +
+						"@Target(ElementType.PARAMETER)\n" +
+						"@interface LegalParam {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class Z {\n" +
+						"		Z() {}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"	Y.Z foo(@LegalParam Y.Z z) { //Legal\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.Z foo2(@LegalTypeUseParam Y.Z z) { //Legal\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"	Y.Z foo3(@IllegalTypeUse @LegalParam Y.Z z) { //Illegal\n" +
+						"		return z;\n" +
+						"	}\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 25)\n" +
+				"	Y.Z foo3(@IllegalTypeUse @LegalParam Y.Z z) { //Illegal\n" +
+				"	         ^^^^^^^^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	//[1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	//The test case is to validate type use annotation for class fields.
+	public void test415308d() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class Z {\n" +
+						"		Z() {}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"   @Illegal \n" +
+						"	Y.Z z;\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 13)\n" +
+				"	@Illegal \n" +
+				"	^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	//[1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	//The test case checks for annotations which are not exclusively TYPE_USE. We should not report a error.
+	public void test415308d2() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target({ElementType.TYPE_USE, ElementType.FIELD})\n" +
+						"@interface Legal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class Z {\n" +
+						"		Z() {}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"   @Legal \n" +
+						"	Y.Z z;\n" +
+						"}\n"
+				},
+				"");
+	}
+	//[1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	//The test case is to validate type use annotation for class fields.
+	//We check all the qualifiers as we look for a static type. This test checks if we are able to
+	//go beyond 1 level as part of the loop.
+	public void test415308e() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal2 {\n" +
+						"}\n" +
+						"@Target(ElementType.FIELD)\n" +
+						"@interface Legal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class YY {\n" +
+						"		class Z {\n" +
+						"			Z() {}\n" +
+						"		}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"   @Legal @Illegal @Illegal2\n" +
+						"	Y.YY.Z z;\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 21)\n" +
+				"	@Legal @Illegal @Illegal2\n" +
+				"	       ^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n" +
+				"2. ERROR in X.java (at line 21)\n" +
+				"	@Legal @Illegal @Illegal2\n" +
+				"	                ^^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// The test case is to validate type use annotations on return types for methods.
+	public void test415308f() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class Z {\n" +
+						"		Z() {}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"   public @Illegal Y.Z foo() { return null;}\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 13)\n" +
+				"	public @Illegal Y.Z foo() { return null;}\n" +
+				"	       ^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// The test case is a array version of test415308f.
+	public void test415308f2() {
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface Illegal {\n" +
+						"}\n" +
+						"class Y {\n" +
+						"	static class Z {\n" +
+						"		Z() {}\n" +
+						"	}\n" +
+						"}\n" +
+						"class X {\n" +
+						"   public @Illegal Y.Z[] foo() { return null;}\n" +
+						"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 13)\n" +
+				"	public @Illegal Y.Z[] foo() { return null;}\n" +
+				"	       ^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// [1.8][compiler] Illegal type annotations not rejected (https://bugs.eclipse.org/bugs/show_bug.cgi?id=415308)
+	// The test case is used to test enums with type annotations.
+	public void test415308g() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface Illegal {\n" +
+					"}\n" +
+					"class Y {\n" +
+					"	enum A { B }\n" +
+					"}\n" +
+					"class X {\n" +
+					"	@Illegal Y.A foo(@Illegal Y.A a) {\n" +
+					"		return a;\n" +
+					"	}\n" +
+					"}\n"
+				},
+				"----------\n" +
+				"1. ERROR in X.java (at line 11)\n" +
+				"	@Illegal Y.A foo(@Illegal Y.A a) {\n" +
+				"	^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n" +
+				"2. ERROR in X.java (at line 11)\n" +
+				"	@Illegal Y.A foo(@Illegal Y.A a) {\n" +
+				"	                 ^^^^^^^^\n" +
+				"Type annotations are not allowed on type names used to access static members\n" +
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418041, NPE during AST creation.
+	public void test418041() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"import java.util.List;\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface Readonly {\n" +
+					"}\n" +
+					"class UnmodifiableList<T> implements\n" +
+					"@Readonly List<@Readonly T> { }\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.addAll(int, Collection<? extends T>)\n" + 
+				"----------\n" + 
+				"2. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.addAll(Collection<? extends T>)\n" + 
+				"----------\n" + 
+				"3. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.lastIndexOf(Object)\n" + 
+				"----------\n" + 
+				"4. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.subList(int, int)\n" + 
+				"----------\n" + 
+				"5. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.contains(Object)\n" + 
+				"----------\n" + 
+				"6. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.get(int)\n" + 
+				"----------\n" + 
+				"7. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.retainAll(Collection<?>)\n" + 
+				"----------\n" + 
+				"8. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.clear()\n" + 
+				"----------\n" + 
+				"9. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.indexOf(Object)\n" + 
+				"----------\n" + 
+				"10. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.toArray(T[])\n" + 
+				"----------\n" + 
+				"11. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.toArray()\n" + 
+				"----------\n" + 
+				"12. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.isEmpty()\n" + 
+				"----------\n" + 
+				"13. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.listIterator(int)\n" + 
+				"----------\n" + 
+				"14. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.listIterator()\n" + 
+				"----------\n" + 
+				"15. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.add(int, T)\n" + 
+				"----------\n" + 
+				"16. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.add(T)\n" + 
+				"----------\n" + 
+				"17. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.set(int, T)\n" + 
+				"----------\n" + 
+				"18. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.size()\n" + 
+				"----------\n" + 
+				"19. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.containsAll(Collection<?>)\n" + 
+				"----------\n" + 
+				"20. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.remove(int)\n" + 
+				"----------\n" + 
+				"21. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.remove(Object)\n" + 
+				"----------\n" + 
+				"22. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.removeAll(Collection<?>)\n" + 
+				"----------\n" + 
+				"23. ERROR in X.java (at line 7)\n" + 
+				"	class UnmodifiableList<T> implements\n" + 
+				"	      ^^^^^^^^^^^^^^^^\n" + 
+				"The type UnmodifiableList<T> must implement the inherited abstract method List<T>.iterator()\n" + 
+				"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418041, NPE during AST creation.
+	public void test418041a() {
+		this.runNegativeTest(
+				new String[] {
+					"X.java",
+					"public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {\n" +
+					"}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {}\n"
+				},
+				"----------\n" + 
+				"1. ERROR in X.java (at line 1)\n" + 
+				"	public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {\n" + 
+				"	                                          ^\n" +
+				"Y cannot be resolved to a type\n" + 
+				"----------\n" + 
+				"2. WARNING in X.java (at line 1)\n" + 
+				"	public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {\n" + 
+				"	                                                                          ^^^^^^^^^^^^^^^\n" + 
+				"The type parameter Q should not be bounded by the final type Integer. Final types cannot be further extended\n" + 
+				"----------\n");
+	}
+	public void testWildcardCapture() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"import java.util.List;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface NonNull {\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface Nullable {\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		List<@Nullable ? extends X> lx1 = null;\n" +
+				"		List<@NonNull ? extends X> lx2 = null;\n" +
+				"		lx1 = lx2;\n" +
+				"		lx1.add(lx2.get(0));\n" +
+				"		lx1.add(lx1.get(0));\n" +
+				"       getAdd(lx1, lx2);\n" +
+				"	}\n" +
+				"	static <@NonNull P>  void getAdd(List<P> p1, List<P> p2) {\n" +
+				"		p1.add(p2.get(0));\n" +
+				"	}\n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 18)\n" + 
+			"	lx1.add(lx2.get(0));\n" + 
+			"	    ^^^\n" + 
+			"The method add(capture#3-of ? extends X) in the type List<capture#3-of ? extends X> is not applicable for the arguments (capture#4-of ? extends X)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 19)\n" + 
+			"	lx1.add(lx1.get(0));\n" + 
+			"	    ^^^\n" + 
+			"The method add(capture#5-of ? extends X) in the type List<capture#5-of ? extends X> is not applicable for the arguments (capture#6-of ? extends X)\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 20)\n" + 
+			"	getAdd(lx1, lx2);\n" + 
+			"	^^^^^^\n" + 
+			"The method getAdd(List<P>, List<P>) in the type X is not applicable for the arguments (List<capture#7-of ? extends X>, List<capture#8-of ? extends X>)\n" + 
+			"----------\n");		
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=414038, [1.8][compiler] CCE in resolveAnnotations
+	public void testBug414038() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.*;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface NonNull { int[].class value() default 0;}\n" +
+				"public class X extends @NonNull() Object {    \n" +
+				"    public static int i = 0; \n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	@interface NonNull { int[].class value() default 0;}\n" + 
+			"	                          ^^^^^^\n" + 
+			"Syntax error on tokens, delete these tokens\n" + 
+			"----------\n");		
+	}	
+	public void testGenericConstructor() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Annotation;\n" +
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"} \n" +
+				"public class X { \n" +
+				"\n" +
+				"	<P> @T X() {\n" +
+				"	}\n" +
+				"   @T <P> X(X x) {\n" +
+				"   }\n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 9)\n" + 
+			"	<P> @T X() {\n" + 
+			"	    ^\n" + 
+			"Syntax error on token \"@\", delete this token\n" + 
+			"----------\n");		
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419833, [1.8] NPE in CompilationUnitProblemFinder and ASTNode
+	public void test419833() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.Target;\n" +
+				"import java.lang.annotation.ElementType;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"class S {\n" +
+				"}\n" +
+				"interface I {\n" +
+				"}\n" +
+				"public class X extends @T S implements @T  {\n" +
+				"	public int foo() {\n" +
+				"       return 0;\n" +
+				"	}	\n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 10)\n" + 
+			"	public class X extends @T S implements @T  {\n" + 
+			"	                                       ^\n" + 
+			"Syntax error on token \"@\", delete this token\n" + 
+			"----------\n");		
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420038,  [1.8][compiler] Tolerate type annotations on array dimensions of class literals for now for compatibility. 
+	public void test420038() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	public static void main(String[] args) {\n" +
+				"		Class<?> c = int @T [].class; \n" +
+				"	}\n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. WARNING in X.java (at line 8)\n" + 
+			"	Class<?> c = int @T [].class; \n" + 
+			"	                 ^^\n" + 
+			"Syntax error, type annotations are illegal here\n" + 
+			"----------\n");		
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420284, [1.8][compiler] IllegalStateException from TypeSystem.cacheDerivedType 
+	public void test420284() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.io.Serializable;\n" +
+				"import java.util.List;\n" +
+				"public class X {\n" +
+				"    void foo(Object o) {\n" +
+				"        Integer i = (Integer & Serializable) o;\n" +
+				"        List<@NonNull Integer> l;\n" +
+				"    }\n" +
+				"}\n"
+			}, 
+			"----------\n" + 
+			"1. ERROR in X.java (at line 6)\n" + 
+			"	List<@NonNull Integer> l;\n" + 
+			"	      ^^^^^^^\n" + 
+			"NonNull cannot be resolved to a type\n" + 
+			"----------\n");		
+	}	
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=391521, [1.8][compiler] Error highlighting is not accurate for type references with type annotations
+	public void test391521() {
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"class Y {}\n" +
+				"public class X {\n" +
+				"    Y y1 = (@Marker Z) null;\n" +
+				"    Y y2 = new @Marker Z();\n" +
+				"    Y[] y3 = (@Marker Z[]) null;\n" +
+				"    Y[] y4 = new @Marker Z[0];\n" +
+				"    Y[] y5 = (@Marker Y.Z) null;\n" +
+				"    Y[] y6 = new @Marker Y.  Z();\n" +
+				"    Y[] y7 = (@Marker Y.Z[]) null;\n" +
+				"    Y[] y8 = new @Marker Y[0].  Z;\n" +
+				"    Y[] y9 = new @Marker Y.  Z[0];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker{}\n" +
+				"\n"
+			},
+			"----------\n" +
+			"1. ERROR in X.java (at line 3)\n" +
+			"	Y y1 = (@Marker Z) null;\n" +
+			"	       ^^^^^^^^^^^^^^^^\n" +
+			"Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"2. ERROR in X.java (at line 3)\n" +
+			"	Y y1 = (@Marker Z) null;\n" +
+			"	                ^\n" +
+			"Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"3. ERROR in X.java (at line 4)\n" +
+			"	Y y2 = new @Marker Z();\n" +
+			"	                   ^\n" +
+			"Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"4. ERROR in X.java (at line 5)\n" +
+			"	Y[] y3 = (@Marker Z[]) null;\n" +
+			"	         ^^^^^^^^^^^^^^^^^^\n" +
+			"Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"5. ERROR in X.java (at line 5)\n" +
+			"	Y[] y3 = (@Marker Z[]) null;\n" +
+			"	                  ^\n" +
+			"Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"6. ERROR in X.java (at line 6)\n" +
+			"	Y[] y4 = new @Marker Z[0];\n" +
+			"	                     ^\n" +
+			"Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"7. ERROR in X.java (at line 7)\n" +
+			"	Y[] y5 = (@Marker Y.Z) null;\n" +
+			"	                  ^^^\n" +
+			"Y.Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"8. ERROR in X.java (at line 8)\n" +
+			"	Y[] y6 = new @Marker Y.  Z();\n" +
+			"	                     ^^^^^\n" +
+			"Y.Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"9. ERROR in X.java (at line 9)\n" +
+			"	Y[] y7 = (@Marker Y.Z[]) null;\n" +
+			"	                  ^^^\n" +
+			"Y.Z cannot be resolved to a type\n" +
+			"----------\n" +
+			"10. ERROR in X.java (at line 10)\n" +
+			"	Y[] y8 = new @Marker Y[0].  Z;\n" +
+			"	                            ^\n" +
+			"Z cannot be resolved or is not a field\n" +
+			"----------\n" +
+			"11. ERROR in X.java (at line 11)\n" +
+			"	Y[] y9 = new @Marker Y.  Z[0];\n" +
+			"	                     ^^^^^\n" +
+			"Y.Z cannot be resolved to a type\n" +
+			"----------\n");
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=414038, [1.8][compiler] CCE in resolveAnnotations
+	public void test414038() {
+		runNegativeTest(
+			new String[] {
+					"X.java", 
+					"import java.lang.annotation.*;\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface NonNull { int[].class value() default 0;}\n" +
+					"public class X extends @NonNull() Object {    \n" +
+					"    public static int i = 0; \n" +
+					"}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 3)\n" + 
+			"	@interface NonNull { int[].class value() default 0;}\n" + 
+			"	                          ^^^^^^\n" + 
+			"Syntax error on tokens, delete these tokens\n" + 
+			"----------\n",
+			true);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=421791,  [1.8][compiler] TYPE_USE annotations should be allowed on annotation type declarations
+	public void test421791() {
+		runNegativeTest(
+				new String[] {
+						"X.java",
+						"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface T {}\n" +
+						"@T\n" +
+						"@interface T2 {}\n" +
+						"public class X {}\n"
+				},
+				"",
+				true);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=424977,  [1.8][compiler]ArrayIndexIndexOutOfBoundException in annotated wrong<> code
+	public void testBug426977() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+		runNegativeTest(
+			new String[] {
+				"test/X.java",
+				"package test;\n" +
+				"import java.lang.annotation.ElementType;\n" + 
+				"import java.lang.annotation.Target;\n" + 
+				"\n" + 
+				"public class X {\n" + 
+				"    test.@A Outer<>.@A Inner<> i;\n" + 
+				"}\n" +
+				"class Outer<T> {\n" +
+				"    class Inner {}\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@interface A {}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in test\\X.java (at line 6)\n" + 
+			"	test.@A Outer<>.@A Inner<> i;\n" + 
+			"	^^^^^^^^^^^^^\n" + 
+			"Incorrect number of arguments for type Outer<T>; it cannot be parameterized with arguments <>\n" + 
+			"----------\n",
+			null,
+			true,
+			customOptions);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=424977,  [1.8][compiler] ArrayIndexIndexOutOfBoundException in annotated wrong<> code
+	public void testBug426977a() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+		runNegativeTest(
+			new String[] {
+				"test/X.java",
+				"package test;\n" +
+				"import java.lang.annotation.ElementType;\n" + 
+				"import java.lang.annotation.Target;\n" + 
+				"\n" + 
+				"public class X {\n" + 
+				"    test.@A Outer<Object>.@A Inner<> i;\n" + 
+				"}\n" +
+				"class Outer<T> {\n" +
+				"    class Inner {}\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE)\n" + 
+				"@interface A {}\n"
+			},
+			"----------\n" + 
+			"1. ERROR in test\\X.java (at line 6)\n" + 
+			"	test.@A Outer<Object>.@A Inner<> i;\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"The type Outer<Object>.Inner is not generic; it cannot be parameterized with arguments <>\n" + 
+			"----------\n",
+			null,
+			true,
+			customOptions);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425599, [1.8][compiler] ISE when trying to compile qualified and annotated class instance creation
+	public void test425599() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"public class X {\n" +
+				"    Object ax = new @A Outer().new Middle<String>();\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE) @interface A {}\n" +
+				"class Outer {\n" +
+				"    class Middle<E> {}\n" +
+				"}\n"
+			},
+			"",
+			null,
+			true,
+			customOptions);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=427955, [1.8][compiler] NPE in TypeSystem.getUnannotatedType
+	public void test427955() {
+		Map customOptions = getCompilerOptions();
+		customOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+		runNegativeTest(
+			new String[] {
+				"X.java",
+				"/**\n" +
+				" * @param <K> unused\n" +
+				" * @param <V> unused\n" +
+				" */\n" +
+				"public class X {}\n" +
+				"class Outer<K, V> {\n" +
+				"  void method() {\n" +
+				"    //Internal compiler error: java.lang.NullPointerException at\n" +
+				"    // org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76)\n" +
+				"    new Inner<>(null);\n" +
+				"  }\n" +
+				"  final class Inner<K2, V2> {\n" +
+				"    /**\n" +
+				"     * @param next unused \n" +
+				"     */\n" +
+				"    Inner(Inner<K2, V2> next) {}\n" +
+				"  }\n" +
+				"}\n"
+			},
+			"",
+			null,
+			true,
+			customOptions);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419827,  [1.8] Annotation with TYPE_USE as target is not allowed to use container with target TYPE
+	public void test419827a() {
+		runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Repeatable;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"\n" +
+					"@Target({ElementType.TYPE_USE})\n" +
+					"@Repeatable(FooContainer.class)\n" +
+					"@interface Foo {}\n" +
+					"@Target({ElementType.TYPE, ElementType.TYPE_USE})\n" +
+					"@interface FooContainer {\n" +
+					"	Foo[] value();\n" +
+					"}\n" +
+					"public class X{}\n"
+				},
+				"",
+				true);
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419827,  [1.8] Annotation with TYPE_USE as target is not allowed to use container with target TYPE
+	// Although the target of FooContainer is different from that of Foo, Foo container cannot be used in any place where
+	// Foo can't be used.
+	public void test419827b() {
+		runNegativeTest(
+				new String[] {
+					"X.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Repeatable;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"\n" +
+					"@Target({ElementType.TYPE_USE})\n" +
+					"@Repeatable(FooContainer.class)\n" +
+					"@interface Foo {}\n" +
+					"@Target({ElementType.TYPE})\n" +
+					"@interface FooContainer {\n" +
+					"	Foo[] value();\n" +
+					"}\n" +
+					"public class X{}\n"
+				},
+				"",
+				true);
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
index 264abd2..b6df382 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullAnnotationTest.java
@@ -643,7 +643,7 @@ public void test_nonnull_parameter_016() {
 		this.LIBS,
 		true /* shouldFlush*/);
 }
-// Bug367203 - [compiler][null] detect assigning null to nonnull argument
+// Bug 367203 - [compiler][null] detect assigning null to nonnull argument
 public void test_nonnull_argument_001() {
 	runNegativeTestWithLibs(
 			new String[] {
@@ -670,7 +670,7 @@ public void test_nonnull_argument_001() {
 			"Null type mismatch: required \'@NonNull Object\' but the provided value is null\n" + 
 			"----------\n");
 }
-// Bug367203 - [compiler][null] detect assigning null to nonnull argument
+// Bug 367203 - [compiler][null] detect assigning null to nonnull argument
 public void test_nonnull_argument_002() {
 	runNegativeTestWithLibs(
 			new String[] {
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
index f3aee1e..859331b 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
@@ -32,7 +32,7 @@
  *							bug 400761 - [compiler][null] null may be return as boolean without a diagnostic
  *							bug 402993 - [null] Follow up of bug 401088: Missing warning about redundant null check
  *							bug 403147 - [compiler][null] FUP of bug 400761: consolidate interaction between unboxing, NPE, and deferred checking
- *							bug 384380 - False positive on a  Potential null pointer access  after a continue
+ *							bug 384380 - False positive on a "Potential null pointer access" after a continue
  *							bug 406384 - Internal error with I20130413
  *							Bug 364326 - [compiler][null] NullPointerException is not found by compiler. FindBugs finds that one
  *******************************************************************************/
@@ -16036,7 +16036,7 @@ public void testBug360328d() {
 		"",/* expected error */
 	    JavacTestOptions.Excuse.EclipseWarningConfiguredAsError);
 }
-// Bug 384380 - False positive on a  Potential null pointer access  after a continue
+// Bug 384380 - False positive on a "Potential null pointer access" after a continue
 // original test case
 public void testBug384380() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
@@ -16073,7 +16073,7 @@ public void testBug384380() {
 			"");
 	}
 }
-// Bug 384380 - False positive on a  Potential null pointer access  after a continue
+// Bug 384380 - False positive on a "Potential null pointer access" after a continue
 // variant with a finally block
 public void testBug384380_a() {
 	if (this.complianceLevel >= ClassFileConstants.JDK1_5) {
diff --git a/org.eclipse.jdt.core.tests.model/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.core.tests.model/.settings/org.eclipse.core.resources.prefs
index edee3a4..ccf624c 100644
--- a/org.eclipse.jdt.core.tests.model/.settings/org.eclipse.core.resources.prefs
+++ b/org.eclipse.jdt.core.tests.model/.settings/org.eclipse.core.resources.prefs
@@ -1,5 +1,3 @@
-eclipse.preferences.version=1
-encoding//workspace/AttachedJavadocProject/UTF8doc=UTF-8
-encoding//workspace/AttachedJavadocProject/UTF8doc/p/TestBug394382.txt=UTF-8
-encoding//workspace/AttachedJavadocProject/UTF8doc2=UTF-8
-encoding//workspace/Encoding/src/testUTF8/Test.java=UTF-8
+eclipse.preferences.version=1
+encoding//workspace/Encoding/src/testShiftJIS/A.java=Shift-JIS
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
index 6a0ed06..8dcac37 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/TypeBindingTests308.java
@@ -1,2571 +1,2571 @@
-/*******************************************************************************
- * Copyright (c) 2013, 2014 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.tests.dom;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-
-import junit.framework.Test;
-
-import org.eclipse.core.runtime.CoreException;
-import org.eclipse.jdt.core.ICompilationUnit;
-import org.eclipse.jdt.core.IJavaProject;
-import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.core.dom.AST;
-import org.eclipse.jdt.core.dom.ASTNode;
-import org.eclipse.jdt.core.dom.ArrayCreation;
-import org.eclipse.jdt.core.dom.ArrayType;
-import org.eclipse.jdt.core.dom.Assignment;
-import org.eclipse.jdt.core.dom.Block;
-import org.eclipse.jdt.core.dom.CastExpression;
-import org.eclipse.jdt.core.dom.CatchClause;
-import org.eclipse.jdt.core.dom.ClassInstanceCreation;
-import org.eclipse.jdt.core.dom.CompilationUnit;
-import org.eclipse.jdt.core.dom.CreationReference;
-import org.eclipse.jdt.core.dom.EnhancedForStatement;
-import org.eclipse.jdt.core.dom.Expression;
-import org.eclipse.jdt.core.dom.ExpressionStatement;
-import org.eclipse.jdt.core.dom.FieldDeclaration;
-import org.eclipse.jdt.core.dom.IAnnotationBinding;
-import org.eclipse.jdt.core.dom.IMethodBinding;
-import org.eclipse.jdt.core.dom.ITypeBinding;
-import org.eclipse.jdt.core.dom.IVariableBinding;
-import org.eclipse.jdt.core.dom.IfStatement;
-import org.eclipse.jdt.core.dom.InstanceofExpression;
-import org.eclipse.jdt.core.dom.MarkerAnnotation;
-import org.eclipse.jdt.core.dom.MethodDeclaration;
-import org.eclipse.jdt.core.dom.MethodInvocation;
-import org.eclipse.jdt.core.dom.ParameterizedType;
-import org.eclipse.jdt.core.dom.ParenthesizedExpression;
-import org.eclipse.jdt.core.dom.PrefixExpression;
-import org.eclipse.jdt.core.dom.QualifiedType;
-import org.eclipse.jdt.core.dom.ReturnStatement;
-import org.eclipse.jdt.core.dom.SimpleName;
-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
-import org.eclipse.jdt.core.dom.ThisExpression;
-import org.eclipse.jdt.core.dom.TryStatement;
-import org.eclipse.jdt.core.dom.Type;
-import org.eclipse.jdt.core.dom.TypeDeclaration;
-import org.eclipse.jdt.core.dom.TypeMethodReference;
-import org.eclipse.jdt.core.dom.TypeParameter;
-import org.eclipse.jdt.core.dom.UnionType;
-import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
-import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
-import org.eclipse.jdt.core.dom.WildcardType;
-import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
-
-public class TypeBindingTests308 extends ConverterTestSetup {
-
-	ICompilationUnit workingCopy;
-
-	public static Test suite() {
-		return buildModelTestSuite(TypeBindingTests308.class);
-	}
-	public void setUpSuite() throws Exception {
-		super.setUpSuite();
-		this.ast = AST.newAST(AST.JLS8);
-	}
-	public TypeBindingTests308(String testName){
-		super(testName);
-	}
-	static {
-//		TESTS_NUMBERS = new int[] { };
-//		TESTS_RANGE = new int[] { };
-//		TESTS_NAMES = new String[] {"test027"};
-	}
-
-	private void verifyAnnotationOnType(Type type, String[] annots) {
-		verifyAnnotationsOnBinding(type.resolveBinding(), annots);
-	}
-
-	private void verifyAnnotationsOnBinding(ITypeBinding binding, String[] annots) {
-		IAnnotationBinding[] annotations = binding.getTypeAnnotations();
-		assertNotNull("Should not be null", annotations);
-		int length = annots.length;
-		assertEquals("Incorrect type use annotations", length, annotations.length);
-		for (int i = 0; i < length; i++) {
-			assertEquals("Incorrect annotation", annots[i], (annotations[i] == null) ? null : annotations[i].toString());
-		}
-	}
-
-	private void verifyAnnotationsOnBinding(IVariableBinding binding, String[] annots) {
-		IAnnotationBinding[] annotations = binding.getAnnotations();
-		assertNotNull("Should not be null", annotations);
-		int length = annots.length;
-		assertEquals("Incorrect annotations", length, annotations.length);
-		for (int i = 0; i < length; i++) {
-			assertEquals("Incorrect annotation", annots[i], (annotations[i] == null) ? null : annotations[i].toString());
-		}
-	}
-	
-	public void test000() throws Exception {
-		String contents = 
-					"public class X extends @Marker @SingleMember(0) @Normal(value = 0) Object {\n" +
-					"}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Marker {}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface SingleMember { int value() default 0;}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface Normal { int value() default 0;}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 4, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		Type type = typeDecl.getSuperclassType();
-		assertNotNull("Super class should not be null", type);
-		
-		verifyAnnotationOnType(type, new String[]{"@Marker()", "@SingleMember(value = 0)", "@Normal(value = 0)"});
-	}
-	public void test001() throws Exception {
-		String contents = 
-				"public class X {\n" +
-						"    @Marker int x;\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect field", 1, fields.length);
-		FieldDeclaration field = fields[0];
-		verifyAnnotationOnType(field.getType(), new String[]{"@Marker()"});
-	}
-	public void test002() throws Exception {
-		String contents = 
-						"public class X {\n" +
-						"    @Marker <@Marker2 T> int x() { return 10; };\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
-						"@interface Marker2{}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List params = method.typeParameters();
-		TypeParameter param = (TypeParameter) params.get(0);
-		ITypeBinding binding = param.resolveBinding();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-		verifyAnnotationOnType(method.getReturnType2(), new String[]{"@Marker()"});
-	}
-	public void test003() throws Exception {
-		String contents = 
-						"public class X {\n" +
-						"    int x(@Marker int p) { return 10; };\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List params = method.parameters();
-		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
-		ITypeBinding binding = param.resolveBinding().getType();
-		
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-		verifyAnnotationOnType(param.getType(), new String[]{"@Marker()"});
-	}
-	public void test004() throws Exception {
-		String contents = 
-				"public class X {\n" +
-						"    int x(@Marker int ... p) { return 10; };\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List params = method.parameters();
-		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
-		verifyAnnotationOnType(param.getType(), new String[]{"@Marker()"});
-	}
-
-	public void test005() throws Exception {
-			String contents = 
-				"public class X {\n" +
-						"    int x(@Marker int @Marker2 [] @Marker3 ... p) { return 10; };\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker2 {}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker3 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 4, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List params = method.parameters();
-		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
-		ArrayType type = (ArrayType) param.getType();
-		ITypeBinding binding = type.resolveBinding();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-		verifyAnnotationsOnBinding(param.resolveBinding().getType(), new String[]{"@Marker2()"});
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-	}
-	public void test006() throws Exception {
-		String contents = 
-						"public class X {\n" +
-						"    int x() {\n" +
-						"        try {\n" +
-						"        } catch (@Marker NullPointerException | @Marker2 ArrayIndexOutOfBoundsException e) {\n" +
-						"        }\n" +
-						"        return 10;\n" +
-						"    }\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		TryStatement trySt = (TryStatement) statements.get(0);
-		CatchClause catchCl = (CatchClause) trySt.catchClauses().get(0);
-		UnionType union = (UnionType) catchCl.getException().getType();
-		types = union.types();
-		assertEquals("Incorrect union types", 2, types.size());
-		Type type = (Type) types.get(0);
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		
-		type = (Type) types.get(1);
-		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
-	}	
-	public void test007() throws Exception {
-		String contents = 
-				"package java.lang;\n" +
-				"public class X {\n" +
-				"    public void x() throws Exception {\n" +
-				"        try (@Marker LocalStream p = null; final @Marker2 LocalStream q = null; @Marker3 final LocalStream r = null) {}\n" +
-				"    }\n" +
-				"}\n" +
-				"class LocalStream implements AutoCloseable {\n" +
-				"    public void close() throws Exception {}\n" +
-				"}\n" +
-				"interface AutoCloseable {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker3 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/java/lang/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 6, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		TryStatement trySt = (TryStatement) statements.get(0);
-		List resources = trySt.resources();
-		assertEquals("Incorrect no of resources", 3, resources.size());
-		VariableDeclarationExpression resource = (VariableDeclarationExpression) resources.get(0);
-		Type type = resource.getType();
-		assertNotNull("Resource type should not be null", type);
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		
-		resource = (VariableDeclarationExpression) resources.get(1);
-		type = resource.getType();
-		assertNotNull("Resource type should not be null", type);
-		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
-		
-		resource = (VariableDeclarationExpression) resources.get(2);
-		type = resource.getType();
-		assertNotNull("Resource type should not be null", type);
-		verifyAnnotationOnType(type, new String[]{"@Marker3()"});
-	}
-	public void test008() throws Exception {
-		String contents = 
-				"public class X {\n" +
-						"    int x() {\n" +
-						"        for (@Marker int i: new int[3]) {}\n" +
-						"        for (final @Marker int i: new int[3]) {}\n" +
-						"        for (@Marker final int i: new int[3]) {}\n" +
-						"        return 10;\n" +
-						"    }\n" +
-						"}\n" +
-						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-						"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		EnhancedForStatement forStmt = (EnhancedForStatement) statements.get(0);
-		SingleVariableDeclaration param = forStmt.getParameter();
-		Type type = param.getType();
-		assertNotNull("Resource type should not be null", type);
-		ITypeBinding binding = param.resolveBinding().getType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-		binding = type.resolveBinding();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-	}	
-	public void test009() throws Exception {
-		String contents = 
-				"interface I {\n" +
-				"    Object copy(int [] ia);\n" +
-				"}\n" +
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        I i = @Marker int @Marker2 []::clone;\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 4, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
-		TypeMethodReference lambda = (TypeMethodReference) fragment.getInitializer();
-		ArrayType type = (ArrayType) lambda.getType();
-
-		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
-		ITypeBinding binding = type.resolveBinding();
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-	}
-	public void test010() throws Exception {
-		String contents = 
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        int i [] = new @Marker int @Marker2 [4];\n" +
-				"        int j [] = new @Marker2 int @Marker [] { 10 };\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
-		ArrayCreation arrayCr = (ArrayCreation) fragment.getInitializer();
-
-		ArrayType type = arrayCr.getType();
-		ITypeBinding binding = type.resolveBinding();
-		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-
-		stmt = (VariableDeclarationStatement) statements.get(1);
-		fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
-		arrayCr = (ArrayCreation) fragment.getInitializer();
-		type = arrayCr.getType();
-		
-		binding = type.resolveBinding();
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-	}
-	public void test011() throws Exception {
-		String contents = 
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        int i = (@Marker int) 0;\n" +
-				"        int j [] = (@Marker int @Marker2 []) null;\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
-		CastExpression castExp = (CastExpression) fragment.getInitializer();
-		Type type = castExp.getType();
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		
-		stmt = (VariableDeclarationStatement) statements.get(1);
-		fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
-		castExp = (CastExpression) fragment.getInitializer();
-		ArrayType arrayType = (ArrayType) castExp.getType();
-		
-		ITypeBinding binding = arrayType.resolveBinding();
-		verifyAnnotationOnType(arrayType, new String[]{"@Marker2()"});
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-	}
-	public void test012() throws Exception {
-		String contents = 
-				"public class X  {\n" +
-				"    public static void main(String args) {\n" +
-				"        if (args instanceof @Marker String) {\n" +
-				"        }\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect method", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		List statements = method.getBody().statements();
-		IfStatement ifStmt = (IfStatement) statements.get(0);
-		InstanceofExpression instanceOf = (InstanceofExpression) ifStmt.getExpression();
-		Type type = instanceOf.getRightOperand();
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-	}
-	public void test013() throws Exception {
-			String contents = 
-				"public class X extends Y<@Marker(10) Integer, String> {}\n" +
-				"class Y<T, V> {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {int value();}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		ParameterizedType superClass = (ParameterizedType) typeDecl.getSuperclassType();
-		List arguments = superClass.typeArguments();
-		assertEquals("Incorrect no of type arguments", 2, arguments.size());
-		Type type = (Type) arguments.get(0);
-		
-		verifyAnnotationOnType(type, new String[]{"@Marker(value = 10)"});
-	}
-	public void test014() throws Exception {
-		String contents = 
-				"public class X<T extends Object & Comparable<? super @Marker String>> {}\n" +
-				"class Y<T> {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		List typeParams = typeDecl.typeParameters();
-
-		TypeParameter typeParam = (TypeParameter) typeParams.get(0);
-		List bounds = typeParam.typeBounds();
-		assertEquals("Incorrect no of type bounds", 2, bounds.size());
-		ParameterizedType type = (ParameterizedType) bounds.get(1);
-		typeParams = type.typeArguments();
-		assertEquals("Incorrect type params", 1, typeParams.size());
-		WildcardType wildcard = (WildcardType)typeParams.get(0);
-		Type bound = wildcard.getBound();
-		assertNotNull("Bound should not be null", bound);
-		verifyAnnotationOnType(bound, new String[]{"@Marker()"});
-	}
-	public void test015() throws Exception {
-		String contents = 
-				"public class X {\n" +
-				"	void foo(Map<@Marker ? super @Marker2 Object, @Marker3 ? extends @Marker4 String> m){}\n" +
-				"   void goo(Map<@Marker4 ? extends @Marker3 Object, @Marker2 ? super @Marker String> m){}\n" +
-				"}\n" +
-				"class Map<K, V>{}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker3 {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker4 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 6, types.size());
-		
-		MethodDeclaration[] methods = ((TypeDeclaration) types.get(0)).getMethods();
-		assertEquals("Incorrect no of metods", 2, methods.length);
-		MethodDeclaration method = methods[0];
-		SingleVariableDeclaration arg = (SingleVariableDeclaration) method.parameters().get(0);
-		
-		
-		List typeArgs = ((ParameterizedType) arg.getType()).typeArguments();
-		
-		WildcardType wildcard = (WildcardType) typeArgs.get(0);
-		verifyAnnotationOnType(wildcard, new String[]{"@Marker()"});
-		Type type = wildcard.getBound();
-		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
-
-		wildcard = (WildcardType) typeArgs.get(1);
-		verifyAnnotationOnType(wildcard, new String[]{"@Marker3()"});
-		type = wildcard.getBound();
-		verifyAnnotationOnType(type, new String[]{"@Marker4()"});
-		
-		method = methods[1];
-		arg = (SingleVariableDeclaration) method.parameters().get(0);
-		typeArgs = ((ParameterizedType) arg.getType()).typeArguments();
-
-		wildcard = (WildcardType) typeArgs.get(0);
-		verifyAnnotationOnType(wildcard, new String[]{"@Marker4()"});
-		type = wildcard.getBound();
-		verifyAnnotationOnType(type, new String[]{"@Marker3()"});
-
-		wildcard = (WildcardType) typeArgs.get(1);
-		verifyAnnotationOnType(wildcard, new String[]{"@Marker2()"});
-		type = wildcard.getBound();
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-	}
-	public void test016() throws Exception {
-		String contents = 
-				"public class X<E> {\n" +
-				"  class Y {\n" +
-				"    E e;\n" +
-				"    E getOtherElement(Object other) {\n" +
-				"      if (!(other instanceof @Marker X<?>.Y)) {};\n" +
-				"      return null;\n" +
-				"    }\n" +
-				"  }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		typeDecl = typeDecl.getTypes()[0];
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		IfStatement ifStmt = (IfStatement) method.getBody().statements().get(0);
-		PrefixExpression prefix = (PrefixExpression ) ifStmt.getExpression();
-		ParenthesizedExpression operand = (ParenthesizedExpression) prefix.getOperand();
-		InstanceofExpression expression = (InstanceofExpression) operand.getExpression();
-		QualifiedType type = (QualifiedType) expression.getRightOperand();
-		verifyAnnotationOnType(type, new String[]{});
-		verifyAnnotationOnType(type.getQualifier(), new String[]{"@Marker()"});
-	}
-	public void test017() throws Exception {
-		String contents = 
-				"public class X<P, C> {\n" +
-				"  public X() {\n" +
-				"    if (!(this instanceof @Marker X)) {}\n" +
-				"  }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		IfStatement ifStmt = (IfStatement) method.getBody().statements().get(0);
-		PrefixExpression prefix = (PrefixExpression ) ifStmt.getExpression();
-		ParenthesizedExpression operand = (ParenthesizedExpression) prefix.getOperand();
-		InstanceofExpression expression = (InstanceofExpression) operand.getExpression();
-		verifyAnnotationOnType(expression.getRightOperand(), new String[]{"@Marker()"});
-	}
-	public void test018() throws Exception {
-		String contents = 
-				"interface I {\n" +
-				"    void foo(Y<String>.Z z, int x);\n" +
-				"}\n" +
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        I i = Y<String>.@Marker Z::foo;\n" +
-				"        i.foo(new Y<String>().new Z(), 10); \n" +
-				"    }\n" +
-				"}\n" +
-				"class Y<T> {\n" +
-				"    class Z {\n" +
-				"        void foo(int x) {\n" +
-				"        }\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 4, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		VariableDeclarationStatement statement = (VariableDeclarationStatement) method.getBody().statements().get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		TypeMethodReference initializer = (TypeMethodReference) fragment.getInitializer();
-		Type type = initializer.getType();
-		assertTrue(type.isQualifiedType());
-		QualifiedType qualifiedType = (QualifiedType) type;
-		checkSourceRange(qualifiedType.getName(), "Z", contents);
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		assertEquals("Should be a qualified type", ASTNode.QUALIFIED_TYPE, type.getNodeType());
-		verifyAnnotationOnType(((QualifiedType) type).getQualifier() , new String[]{});
-	}
-	public void test019() throws Exception {
-		String contents = 
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        X [] x = new @Marker X @Marker2 [5];\n" +
-				"        X [] x2 = new @Marker2 X @Marker [] { null };\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		List statements = method.getBody().statements();
-		assertEquals("Incorrect no of statements", 2, statements.size());
-		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		ArrayCreation initializer = (ArrayCreation) fragment.getInitializer();
-		ArrayType arrayType = initializer.getType();
-		ITypeBinding binding = arrayType.resolveBinding();
-		
-		verifyAnnotationOnType(arrayType, new String[]{"@Marker2()"});
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-		
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-
-		statement = (VariableDeclarationStatement) statements.get(1);
-		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		initializer = (ArrayCreation) fragment.getInitializer();
-		arrayType = initializer.getType();
-		binding = arrayType.resolveBinding();
-		verifyAnnotationOnType(arrayType, new String[]{"@Marker()"});
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
-		
-		binding = binding.getComponentType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
-	}
-	public void test020() throws Exception {
-		String contents = 
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        Map.Entry<String, String> [] e = (Map.@Marker Entry<String, String> []) null;\n" +
-				"    }\n" +
-				"}\n" +
-				"class Map<K, V> {\n" +
-				"	interface Entry<K, V> {}\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		List statements = method.getBody().statements();
-		assertEquals("Incorrect no of statements", 1, statements.size());
-		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		CastExpression castExp = (CastExpression) fragment.getInitializer();
-		ArrayType arrayType = (ArrayType) castExp.getType();
-		verifyAnnotationOnType(arrayType, new String[]{});
-		ParameterizedType type = (ParameterizedType) arrayType.getElementType();
-		verifyAnnotationOnType(type.getType(), new String[]{"@Marker()"});
-	}
-	public void test021() throws Exception {
-		String contents = 
-				"import java.io.Serializable;\n" +
-				"import java.util.List;\n" +
-				"public class X<T extends Comparable<T> & Serializable> {\n" +
-				"	void foo(List<? extends @Marker @Marker2 Comparable<T>> p) {} \n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		SingleVariableDeclaration param = (SingleVariableDeclaration) method.parameters().get(0);
-		Type type = param.getType();
-		assertEquals("Should be a parameterized type", ASTNode.PARAMETERIZED_TYPE, type.getNodeType());
-		List typeArgs = ((ParameterizedType) type).typeArguments();
-		assertEquals("Incorrect type args", 1, typeArgs.size());
-		WildcardType wildcard = (WildcardType) typeArgs.get(0);
-		ParameterizedType bound = (ParameterizedType) wildcard.getBound();
-		verifyAnnotationOnType(bound, new String[]{"@Marker()", "@Marker2()"});
-	}
-	public void test022() throws Exception {
-		String contents = 
-				"public class X {\n" +
-				"    X x = new @Marker X();\n" +
-				"    X y = new <String> @Marker X();\n" +	
-				"	<T> X(){}\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 2, fields.length);
-		FieldDeclaration field = fields[0];
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
-		ClassInstanceCreation creation = (ClassInstanceCreation) fragment.getInitializer();
-		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
-		
-		field = fields[1];
-		fragment = (VariableDeclarationFragment) field.fragments().get(0);
-		creation = (ClassInstanceCreation) fragment.getInitializer();
-		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
-	}
-	public void test023() throws Exception {
-		String contents = 
-				"public class X {\n" +
-				"    class Y {\n" +
-				"	    <T> Y(){}\n" +
-				"    }\n" +
-				"    Y y1 = new @Marker X().new @Marker2 Y();\n" +
-				"    Y y2 = new @Marker2 X().new <String> @Marker Y();\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 2, fields.length);
-		FieldDeclaration field = fields[0];
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
-		ClassInstanceCreation creation = (ClassInstanceCreation) fragment.getInitializer();
-		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker2()"});
-		creation = (ClassInstanceCreation) creation.getExpression();
-		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
-		
-		field = fields[1];
-		fragment = (VariableDeclarationFragment) field.fragments().get(0);
-		creation = (ClassInstanceCreation) fragment.getInitializer();
-		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
-		creation = (ClassInstanceCreation) creation.getExpression();
-		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker2()"});
-	}
-	public void test024() throws Exception {
-		String contents = 
-				"public class X {\n" +
-				"    void foo() throws @Marker NullPointerException, @Marker2 ArrayIndexOutOfBoundsException {}\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		List thrownTypes = method.thrownExceptionTypes();
-		assertEquals("Incorrect no of thrown exceptions", 2, thrownTypes.size());
-		Type type = (Type) thrownTypes.get(0);
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		type = (Type) thrownTypes.get(1);
-		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
-	}
-	public void test025() throws Exception {
-		String contents = 
-				"interface I {}\n" +
-				"interface J {}\n" +
-				"interface K extends @Marker I, @Marker2 J {}\n" +
-				"interface L {}\n" +
-				"public class X implements @Marker2 K, @Marker L {\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 7, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
-		List interfaces = typeDecl.superInterfaceTypes();
-		assertEquals("Incorrect no of super interfaces", 2, interfaces.size());
-		verifyAnnotationOnType((Type) interfaces.get(0), new String[]{"@Marker()"});
-		verifyAnnotationOnType((Type) interfaces.get(1), new String[]{"@Marker2()"});
-		
-		typeDecl = (TypeDeclaration) types.get(4);
-		interfaces = typeDecl.superInterfaceTypes();
-		assertEquals("Incorrect no of super interfaces", 2, interfaces.size());
-		verifyAnnotationOnType((Type) interfaces.get(0), new String[]{"@Marker2()"});
-		verifyAnnotationOnType((Type) interfaces.get(1), new String[]{"@Marker()"});
-	}
-	public void test026() throws Exception {
-		String contents = 
-				"interface I {\n" +
-				"    void foo(int x);\n" +
-				"}\n" +
-				"public class X  {\n" +
-				"    public static void main(String [] args) {\n" +
-				"        I i = A.Y.@Marker Z ::foo;\n" +
-				"        i.foo(10); \n" +
-				"    }\n" +
-				"}\n" +
-				"class A {\n" +
-				"  static class Y {\n" +
-				"    static class Z {\n" +
-				"        public static void foo(int x) {\n" +
-				"	        System.out.println(x);\n" +
-				"        }\n" +
-				"    }\n" +
-				"  }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 4, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		List statements = method.getBody().statements();
-		
-		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
-		TypeMethodReference lambda = (TypeMethodReference) fragment.getInitializer();
-		Type type = lambda.getType();
-
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-	}
-	public void test027() throws Exception {
-		String contents = 
-				"interface I {\n" +
-				"    Y foo(int x);\n" +
-				"}\n" +
-				"public class X  {\n" +
-				"    class Z extends Y {\n" +
-				"        public Z(int x) {\n" +
-				"            super(x);\n" +
-				"        }\n" +
-				"    }\n" +
-				"    public static void main(String [] args) {\n" +
-				"        I i = @Marker W<@Marker2 Integer>::<@Marker3 String> new;\n" +
-				"    }\n" +
-				"}\n" +
-				"class W<T> extends Y {\n" +
-				"    public <C> W(T x) {\n" +
-				"        super(0);\n" +
-				"    }\n" +
-				"}\n" +
-				"class Y {\n" +
-				"    public Y(int x) {\n" +
-				"    }\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker2 {}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker3 {}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 7, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		List statements = method.getBody().statements();
-		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		CreationReference lambda = (CreationReference) fragment.getInitializer();
-		Type type = lambda.getType();
-		verifyAnnotationOnType(type, new String[]{"@Marker()"});
-		ParameterizedType paramType = (ParameterizedType) type;
-		verifyAnnotationOnType((Type) paramType.typeArguments().get(0), new String[]{"@Marker2()"});
-		List typeArgs = lambda.typeArguments();
-		verifyAnnotationOnType((Type) typeArgs.get(0), new String[]{"@Marker3()"});
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418096
-	public void test028() throws Exception {
-		String contents = 
-				"public class X {\n" +
-				"    @TypeUseAnnotation(\"a\") String @TypeUseAnnotation(\"a1\") [] @TypeUseAnnotation(\"a2\") [] _field2 @TypeUseAnnotation(\"a3\") [], _field3 @TypeUseAnnotation(\"a4\") [][] = null;\n" +
-				"}" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface TypeUseAnnotation {\n" +
-				"	String value() default \"\";\n" +
-				"}\n";
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 1, fields.length);
-		FieldDeclaration field = fields[0];
-		List fragments = field.fragments();
-		assertEquals("Incorrect no of fragments", 2, fragments.size());
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
-		ITypeBinding binding = fragment.resolveBinding().getType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@TypeUseAnnotation(value = a3)"});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a1)"});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a2)"});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a)"});
-		fragment = (VariableDeclarationFragment) fragments.get(1);
-		binding = fragment.resolveBinding().getType();
-		verifyAnnotationsOnBinding(binding, new String[]{"@TypeUseAnnotation(value = a4)"});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a1)"});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a2)"});
-		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a)"});
-	}
-	
-	public void testAnnotatedBinaryType() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer  {\n" +
-				"	class Middle {\n" +
-				"		class Inner {\n" +
-				"		}\n" +
-				"	}\n" +
-				"	public @Marker(\"Outer\") Outer.@Marker (\"Middle\") Middle.@Marker(\"Inner\") Inner omi;\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {\n" +
-				"	String value() default \"GOK\";\n" +
-				"}\n"
-			};
-		
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer o) {\n" +
-					"        o.omi = null;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@Marker((String)\"Outer\") Outer.@Marker((String)\"Middle\") Middle.@Marker((String)\"Inner\") Inner", type.toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testAnnotatedBinaryType2() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer  {\n" +
-				"	class Middle {\n" +
-				"		class Inner {\n" +
-				"		}\n" +
-				"	}\n" +
-				"	public @Marker(\"Outer\") Outer.@Marker (\"Middle\") Middle.@Marker(\"Inner\") Inner @Marker(\"Prefix []\") [] omi @Marker(\"Extended []\") [];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface Marker {\n" +
-				"	String value() default \"GOK\";\n" +
-				"}\n"
-			};
-		
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer o) {\n" +
-					"        o.omi = null;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@Marker((String)\"Outer\") Outer.@Marker((String)\"Middle\") Middle.@Marker((String)\"Inner\") Inner @Marker((String)\"Extended []\") [] @Marker((String)\"Prefix []\") []", type.toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testAnnotatedBinaryType3() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer<K>  {\n" +
-				"	class Inner<P> {\n" +
-				"	}\n" +
-				"	public @T(1) Outer<@T(2) String>.@T(3) Inner<@T(4) Integer> @T(5) [] omi @T(6) [];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value();\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer<String> o) {\n" +
-					"        o.omi = null;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@T((int)1) Outer<@T((int)2) String>.@T((int)3) Inner<@T((int)4) Integer> @T((int)6) [] @T((int)5) []", type.toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	
-	public void testAnnotatedBinaryType4() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer<K>  {\n" +
-				"	class Inner<P> {\n" +
-				"	}\n" +
-				"	@T(1) K @T(2) [] f @T(3) [];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value();\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer<String> o) {\n" +
-					"        o.f = null;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@T((int)1) String @T((int)3) [] @T((int)2) []", type.toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testAnnotatedBinaryType5() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer<K>  {\n" +
-				"	class Inner<P> {\n" +
-				"	}\n" +
-				"	@T(1) Outer<@T(2) ? extends @T(3) String>.@T(4) Inner<@T(5) ? super @T(6) Integer> @T(7) [] f @T(8) [];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value();\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer<String> o) {\n" +
-					"        o.f = null;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@T((int)1) Outer<@T((int)2) ? extends @T((int)3) String>.@T((int)4) Inner<@T((int)5) ? super @T((int)6) Integer> @T((int)8) [] @T((int)7) []", type.toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testAnnotatedBinaryType6() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer<K>  {\n" +
-				"	class Inner<P> {\n" +
-				"	}\n" +
-				"	@T(1) Outer.@T(2) Inner @T(3) [] f @T(4) [];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value();\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer<String> o) {\n" +
-					"        o.f = null;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@T((int)1) Outer#RAW.@T((int)2) Inner#RAW @T((int)4) [] @T((int)3) []", type.toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testIntersectionCastType() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.ElementType;\n" +
-						"import java.lang.annotation.Target;\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface T1 {\n" +
-						"}\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface T2 {\n" +
-						"}\n" +
-						"@Target(ElementType.TYPE_USE)\n" +
-						"@interface T3 {\n" +
-						"}\n" +
-						"public class X {\n" +
-						"	Object o = (@T1 Object & @T2 Runnable & java.io.@T3 Serializable) null;\n" +
-						"	Object p = (@T1 Object & @T2 Runnable & java.io.@T3 Serializable) null;\n" +
-						"}\n";
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 4, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(3);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 2, fields.length);
-		FieldDeclaration field = fields[0];
-		List fragments = field.fragments();
-		assertEquals("Incorrect no of fragments", 1, fragments.size());
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
-		CastExpression cast = (CastExpression) fragment.getInitializer();
-		Type castType = cast.getType();
-		ITypeBinding binding1 = castType.resolveBinding();
-		assertEquals("Wrong annotations", "@T1 Object & @T2 Runnable & @T3 Serializable", binding1.toString());
-		
-		field = fields[1];
-		fragments = field.fragments();
-		assertEquals("Incorrect no of fragments", 1, fragments.size());
-		fragment = (VariableDeclarationFragment) fragments.get(0);
-		cast = (CastExpression) fragment.getInitializer();
-		castType = cast.getType();
-		ITypeBinding binding2 = castType.resolveBinding();
-		assertEquals("Wrong annotations", "@T1 Object & @T2 Runnable & @T3 Serializable", binding2.toString());
-		assertSame("Should be equal", binding1, binding2);
-	}
-	public void testMemberType() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer  {\n" +
-				"	class Inner {\n" +
-				"	}\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(@T Outer o) {\n" +
-					"    }\n" +
-					"}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface T {\n" +
-					"}\n";
-					
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 2, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			List parameters = method.parameters();
-			SingleVariableDeclaration parameter = (SingleVariableDeclaration) parameters.get(0);
-			ITypeBinding binding = parameter.resolveBinding().getType();
-			assertEquals("@T Outer", binding.toString());
-			ITypeBinding [] memberTypes = binding.getDeclaredTypes();
-			assertEquals("Incorrect no of types", 1, memberTypes.length);
-			assertEquals("Incorrect no of types", "@T Outer.Inner", memberTypes[0].toString());
-			assertEquals("Incorrect no of types", "@T Outer", memberTypes[0].getDeclaringClass().toString());
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testMemberType2() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer  {\n" +
-				"    @T Outer f;\n"+
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Outer o) {\n" +
-					"		o.f = null;\n" +
-					"    }\n" +
-					"}\n";
-					
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			assertEquals("Wrong type", "@T Outer", type.toString());
-			IVariableBinding[] declaredFields = type.getDeclaredFields();
-			assertEquals("Wrong type", 1, declaredFields.length);
-			assertEquals("Wrong type", "@T Outer", declaredFields[0].getType().toString());
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testBinarySuperInterfaces() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Y.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T1 {\n" +
-				"}\n" +
-				"public abstract class Y implements Comparable<@T1 Y>{  \n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"    void foo(Y y) {\n" +
-					"    }\n" +
-					"}\n";
-					
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			List parameters = method.parameters();
-			SingleVariableDeclaration parameter = (SingleVariableDeclaration) parameters.get(0);
-			ITypeBinding binding = parameter.resolveBinding().getType();
-			ITypeBinding binding2 = binding.getInterfaces()[0].getTypeArguments()[0];
-			assertEquals("Wrong type", "@T1 Y", binding2.toString());
-			assertEquals("Wrong type", "Comparable<@T1 Y>", binding2.getInterfaces()[0].toString());		
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testMemberTypeSource() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"    class Y {}\n" +
-				"    @T X.Y xy;\n" +
-				"}\n";
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 1, fields.length);
-		FieldDeclaration field = fields[0];
-		ITypeBinding binding = field.getType().resolveBinding();
-		assertEquals("Wrong Type", "@T X", (binding = binding.getDeclaringClass()).toString());
-		assertEquals("Wrong Type", "@T X.Y", (binding = binding.getDeclaredTypes()[0]).toString());
-	}
-	public void testAnnotatedTypeIdentity() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"import java.util.List;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"    @T List<@T String> ls = (@T List<@T String>) null;\n" +
-				"}\n";
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 1, fields.length);
-		FieldDeclaration field = fields[0];
-		ITypeBinding binding = field.getType().resolveBinding();
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
-		CastExpression cast = (CastExpression) fragment.getInitializer();
-		ITypeBinding binding2 = cast.resolveTypeBinding();
-		assertEquals("Wrong Type", "@T List<@T String>", binding.toString());
-		assertSame("not Equal", binding, binding2);
-	}
-	public void testAnnotatedTypeIdentity2() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"public class Outer  {\n" +
-				"	Outer @T [] f @T [];\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value() default 10;\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"public class X {\n" +
-					"	 Outer @T [] f @T [];\n" +
-					"    void foo(Outer o) {\n" +
-					"        o.f = this.f;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			Expression right = assignment.getRightHandSide();
-			ITypeBinding type2 = right.resolveTypeBinding();
-			assertEquals("Wrong type", "Outer @T [] @T []", type.toString());
-			assertSame ("Should be same", type, type2);
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testAnnotatedTypeIdentity3() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Outer.java",
-				"import java.util.List;\n" +
-				"public class Outer  {\n" +
-				"	@T List<@T String> ls;\n" +
-				"}\n" +
-				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value() default 10;\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"import java.util.List;\n" +
-					"public class X {\n" +
-					"	@T List<@T String> ls;\n" +
-					"    void foo(Outer o) {\n" +
-					"        o.ls = this.ls;\n" +
-					"    }\n" +
-					"}";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			
-			MethodDeclaration[] methods = typeDecl.getMethods();
-			assertEquals("Incorrect no of methods", 1, methods.length);
-			MethodDeclaration method = methods[0];
-			Block body = method.getBody();
-			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
-			Assignment assignment = (Assignment) stmt.getExpression();
-			Expression left = assignment.getLeftHandSide();
-			ITypeBinding type = left.resolveTypeBinding();
-			Expression right = assignment.getRightHandSide();
-			ITypeBinding type2 = right.resolveTypeBinding();
-			assertEquals("Wrong type", "@T List<@T String>", type.toString());
-			assertSame ("Should be same", type, type2);
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	public void testHybridAnnotations() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@interface A {\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface AUse {\n" +
-				"}\n" +
-				"@Target({ElementType.TYPE_USE, ElementType.PARAMETER})\n" +
-				"@interface AUseParameter {\n" +
-				"}\n" +
-				"@Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n" +
-				"@interface AUseLocal {\n" +
-				"}\n" +
-				"@Target({ElementType.PARAMETER})\n" +
-				"@interface AParameter {\n" +
-				"}\n" +
-				"public class X {    \n" +
-				"	void foo(@A @AUse @AUseParameter @AUseLocal @AParameter X x) {\n" +
-				"	}\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 6, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(5);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect no of methods", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		SingleVariableDeclaration parameter = (SingleVariableDeclaration) method.parameters().get(0);
-		IVariableBinding parameterBinding = parameter.resolveBinding();
-		verifyAnnotationsOnBinding(parameterBinding, new String [] { "@A()", "@AUseParameter()", "@AParameter()" });
-		ITypeBinding type = parameterBinding.getType();
-		verifyAnnotationsOnBinding(type, new String [] { "@AUse()", "@AUseParameter()", "@AUseLocal()" });
-	}
-	public void testGenericMethod() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.Annotation;\n" +
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"}\n" +
-				"public class X { \n" +
-				"	<N extends Annotation> @T String f(N a) {\n" +
-				"		return null;\n" +
-				"	}\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect no of methods", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		Type returnType = method.getReturnType2();
-		ITypeBinding type = returnType.resolveBinding();
-		verifyAnnotationsOnBinding(type, new String [] { "@T()" });
-	}
-	public void testHybridAnnotations2() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.Target;\n" +
-				"import java.lang.annotation.ElementType;\n" +
-				"@Target({ ElementType.TYPE_USE, ElementType.METHOD })\n" +
-				"@interface SillyAnnotation {  }\n" +
-				"public class X {\n" +
-				"    @SillyAnnotation\n" +
-				"    X(@SillyAnnotation int x) {\n" +
-				"    }\n" +
-				"    @SillyAnnotation\n" +
-				"    void foo(@SillyAnnotation int x) {\n" +
-				"    }\n" +
-				"    @SillyAnnotation\n" +
-				"    String goo(@SillyAnnotation int x) {\n" +
-				"	return null;\n" +
-				"    }\n" +
-				"    @SillyAnnotation\n" +
-				"    X field;\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect no of methods", 3, methods.length);
-		
-		MethodDeclaration method = methods[0];
-		List modifiers = method.modifiers();
-		int size = modifiers.size();
-		assertTrue("Should be just 1", size == 1);
-		MarkerAnnotation annotation = (MarkerAnnotation) modifiers.get(0);
-		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
-		SingleVariableDeclaration parameter = (SingleVariableDeclaration) method.parameters().get(0);
-	    IAnnotationBinding [] annotations = parameter.resolveBinding().getAnnotations();
-		assertTrue("should be 0", annotations == null || annotations.length == 0);
-		IAnnotationBinding [] typeAnnotations = parameter.getType().resolveBinding().getTypeAnnotations();
-		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
-		
-		method = methods[1];
-		modifiers = method.modifiers();
-		size = modifiers.size();
-		assertTrue("Should be just 1", size == 1);
-		annotation = (MarkerAnnotation) modifiers.get(0);
-		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
-		typeAnnotations = method.getReturnType2().resolveBinding().getTypeAnnotations();
-		assertTrue("Should be just 0", typeAnnotations.length == 0);
-		parameter = (SingleVariableDeclaration) method.parameters().get(0);
-	    annotations = parameter.resolveBinding().getAnnotations();
-		assertTrue("should be 0", annotations == null || annotations.length == 0);
-		typeAnnotations = parameter.getType().resolveBinding().getTypeAnnotations();
-		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
-		
-		method = methods[2];
-		modifiers = method.modifiers();
-		size = modifiers.size();
-		assertTrue("Should be just 1", size == 1);
-		annotation = (MarkerAnnotation) modifiers.get(0);
-		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
-		typeAnnotations = method.getReturnType2().resolveBinding().getTypeAnnotations();
-		assertTrue("Should be just 1", typeAnnotations.length == 1);
-		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
-		parameter = (SingleVariableDeclaration) method.parameters().get(0);
-	    annotations = parameter.resolveBinding().getAnnotations();
-		assertTrue("should be 0", annotations == null || annotations.length == 0);
-		typeAnnotations = parameter.getType().resolveBinding().getTypeAnnotations();
-		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
-		
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of fields", 1, fields.length);
-		
-		FieldDeclaration field = fields[0];
-		modifiers = field.modifiers();
-		size = modifiers.size();
-		assertTrue("Should be just 1", size == 1);
-		annotation = (MarkerAnnotation) modifiers.get(0);
-		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
-		annotations = fragment.resolveBinding().getAnnotations();
-		assertTrue("Incorrect annotation", annotations == null || annotations.length == 0);
-		
-		typeAnnotations = field.getType().resolveBinding().getTypeAnnotations();
-		assertTrue("Should be just 1", typeAnnotations.length == 1);
-		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419918, [1.8][compiler] Annotations are not restored from class files in a few situations.
-	public void testBinaryWithoutGenericSignature() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Superclass.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value() default 0;\n" +
-				"}\n" +
-				"@T(1)\n" +
-				"public abstract class Superclass extends @T(2) Object implements @T(3) Runnable {\n" +
-				"	Object @T(4) [] field;\n" +
-				"	@T(5)\n" +
-				"	public String run(@T(6) Superclass this, Object @T(7) [] that) throws @T(8) NullPointerException {\n" +
-				"		return null;\n" +
-				"	}\n" +
-				"   @T(9)\n" +
-				"   Superclass () {}\n" +
-				"   @T(10)\n" +
-				"   class Inner {}\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"@T(21)\n" +
-					"public abstract class X extends @T(22) Superclass implements @T(23) Runnable {\n" +
-					"	Object @T(24) [] field;\n" +
-					"	@T(25)\n" +
-					"	public String run(@T(26) X this, Object @T(27) [] that) throws @T(28) NullPointerException {\n" +
-					"		return null;\n" +
-					"	}\n" +
-					"   @T(29)\n" +
-					"   X() {\n" +
-		            "   }" +
-					"   @T(30)\n" +
-					"   class Inner {\n" +
-					"   }\n" +
-					"}\n";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			ITypeBinding typeBinding = typeDecl.resolveBinding();
-			IAnnotationBinding[] annotations = typeBinding.getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 21)", annotations[0].toString());
-			annotations = typeBinding.getSuperclass().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 22)", annotations[0].toString());
-			annotations = typeBinding.getInterfaces()[0].getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 23)", annotations[0].toString());
-			
-			annotations = typeDecl.getFields()[0].getType().resolveBinding().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 24)", annotations[0].toString());
-			
-			annotations = typeDecl.getMethods()[0].getReturnType2().resolveBinding().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 25)", annotations[0].toString());
-			
-			annotations = typeDecl.getMethods()[0].getReceiverType().resolveBinding().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 26)", annotations[0].toString());
-			
-			annotations = ((SingleVariableDeclaration) (typeDecl.getMethods()[0].parameters().get(0))).getType().resolveBinding().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 27)", annotations[0].toString());
-			
-			annotations = ((Type) typeDecl.getMethods()[0].thrownExceptionTypes().get(0)).resolveBinding().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 28)", annotations[0].toString());
-			
-			annotations = typeDecl.getMethods()[1].resolveBinding().getAnnotations();
-			assertTrue("Should be 0", annotations.length == 0);
-			
-			annotations = typeDecl.getTypes()[0].resolveBinding().getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 30)", annotations[0].toString());
-			
-			
-			// Check the same set of things for the binary type.
-			annotations = typeBinding.getSuperclass().getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 1)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getSuperclass().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 2)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getInterfaces()[0].getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 3)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getDeclaredFields()[0].getType().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 4)", annotations[0].toString());
-			
-			// Skip past the constructor at [0]
-			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getReturnType().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 5)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getDeclaredReceiverType().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 6)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getParameterTypes()[0].getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 7)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getExceptionTypes()[0].getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 8)", annotations[0].toString());
-			
-			annotations = typeBinding.getSuperclass().getDeclaredMethods()[0].getAnnotations();
-			assertTrue("Should be 0", annotations.length == 0);
-			
-			annotations = typeBinding.getSuperclass().getDeclaredTypes()[0].getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 10)", annotations[0].toString());
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	// Variants where superclass in binary is an annotated inner/nested class
-	public void testBinaryWithoutGenericSignature_b() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"Superclass.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value() default 0;\n" +
-				"}\n" +
-				"@T(1)\n" +
-				"public abstract class Superclass extends @T(2) Object implements @T(3) Runnable {\n" +
-				"   @T(9)\n" +
-				"   Superclass () {}\n" +
-				"   @T(10)\n" +
-				"   class Inner {}\n" +
-				"   @T(11)\n" +
-				"   class SubInner extends @T(12) Inner {}\n" +
-				"   @T(13)\n" +
-				"   static class Nested {}\n" +
-				"   @T(14)\n" +
-				"   static class SubNested extends @T(15) Nested {}\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"@T(21)\n" +
-					"public abstract class X extends @T(22) Superclass implements @T(23) Runnable {\n" +
-					"}\n";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 0);
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			ITypeBinding typeBinding = typeDecl.resolveBinding();
-			IAnnotationBinding[] annotations = typeBinding.getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 21)", annotations[0].toString());
-			
-			ITypeBinding superclass = typeBinding.getSuperclass();
-			ITypeBinding[] inners = superclass.getDeclaredTypes();
-			assertTrue("Should be 2", inners.length == 4);
-			
-			ITypeBinding subInner = inners[2];
-			assertEquals("Type name mismatch", "SubInner", subInner.getName());
-			annotations = subInner.getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 11)", annotations[0].toString());
-			
-			annotations = subInner.getSuperclass().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 12)", annotations[0].toString());
-			
-			ITypeBinding subNested = inners[3];
-			annotations = subNested.getAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 14)", annotations[0].toString());
-			
-			annotations = subNested.getSuperclass().getTypeAnnotations();
-			assertTrue("Should be 1", annotations.length == 1);
-			assertEquals("Annotation mismatch", "@T(value = 15)", annotations[0].toString());			
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419918, [1.8][compiler] Annotations are not restored from class files in a few situations.
-	public void testBinaryAnnotationType() throws CoreException, IOException {
-		String jarName = "TypeBindingTests308.jar";
-		String srcName = "TypeBindingTests308_src.zip";
-		final IJavaProject javaProject = getJavaProject("Converter18");
-		try {
-			String[] pathAndContents = new String[] {
-				"T.java",
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Deprecated\n" +		
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface T {\n" +
-				"	int value() default 0;\n" +
-				"}\n"
-			};
-			
-			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
-			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
-			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
-			
-			String contents = 
-					"@T\n" +
-					"public class X {\n" +
-					"}\n";
-			
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy, false);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			CompilationUnit compilationUnit = (CompilationUnit) node;
-			assertProblemsSize(compilationUnit, 1, "The type T is deprecated");
-			List types = compilationUnit.types();
-			assertEquals("Incorrect no of types", 1, types.size());
-			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-			ITypeBinding typeBinding = typeDecl.resolveBinding();
-			IAnnotationBinding[] annotations = typeBinding.getAnnotations()[0].getAnnotationType().getAnnotations();
-			assertTrue("Should be 2", annotations.length == 2);
-			assertEquals("Annotation mismatch", "@Target(value = {public static final java.lang.annotation.ElementType TYPE_USE})", annotations[0].toString());
-			assertEquals("Annotation mismatch", "@Deprecated()", annotations[1].toString());
-		} finally {
-			removeLibrary(javaProject, jarName, srcName);
-		}
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420320, [1.8] Bad AST recovery with type annotation and a syntax error in secondary type
-	public void testAnnotationRecovery() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"import java.util.List;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface NonNull {\n" +
-				"}\n" +
-				"public class X {\n" +
-				"	List<@NonNull String> list2;\n" +
-				"}\n" +
-				"class Y {\n" +
-				"    void bar()\n" +
-				"    void foo() { }\n" +
-				"}\n";
-		
-		String expected =
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"import java.util.List;\n" +
-				"@Target(ElementType.TYPE_USE) @interface NonNull {}\n" +
-				"public class X {\n" +
-				"  List<@NonNull String> list2;\n" +
-				"}\n" +
-				"class Y {\n" +
-				"  void bar(){\n" +
-				"  }\n" +
-				"  void foo(){\n" +
-				"  }\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy, false, true);
-		assertEquals("AST mismatch", expected, node.toString());
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=427337
-	public void testBug427337() throws CoreException, IOException {
-		String contents = 
-				"public class X implements I {\n" +
-				"}\n";
-
-		createFile("/Converter18/src/NonNull.java", 
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface NonNull {}");
-		createFile("/Converter18/src/I.java",
-				"import java.util.List;\n" +
-				"interface I { \n" +
-				"	String bar2(@NonNull String s, @NonNull List<@NonNull String> l2);\n" +
-				"}");
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy, false, true);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		TypeDeclaration type = (TypeDeclaration) ((CompilationUnit) node).types().get(0);
-		ITypeBinding binding = type.resolveBinding();
-		ITypeBinding superInterface = binding.getInterfaces()[0];
-		IMethodBinding method = superInterface.getDeclaredMethods()[0];
-		binding = method.getParameterTypes()[0];
-		assertEquals("Incorrect type binding", "@NonNull String", binding.toString());
-		binding = method.getParameterTypes()[1];
-		assertEquals("Incorrect type binding", "@NonNull List<@NonNull String>", binding.toString());
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=426515
-	public void testBug426515() throws CoreException {
-		try {
-			String contents =
-					"public class X {\n" +
-					"	void foo() {\n" +
-					"		Outer.getInner();\n" +
-					"	}\n" +
-					"}\n";
-
-			createFile("/Converter18/src/A.java",
-					"import java.lang.annotation.ElementType;\n" +
-					"import java.lang.annotation.Target;\n" +
-					"@Target(ElementType.TYPE_USE)\n" +
-					"@interface A { int value() default 0; \n }");
-			createFile("/Converter18/src/Outer.java",
-					"class Outer<T> { \n" +
-					"	public class Inner<I> {}\n" +
-					"	public static @A(1) Outer<java.lang.@A(2) String>.@A(3) Inner<java.lang.@A(4) Object> getInner() { \n" +
-					"		return null;\n" +
-					"	}\n" +
-					"}");
-
-			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-			ASTNode node = buildAST(contents, this.workingCopy, false, true);
-			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-			TypeDeclaration type = (TypeDeclaration) ((CompilationUnit) node).types().get(0);
-			MethodDeclaration method = type.getMethods()[0];
-			ExpressionStatement statement = (ExpressionStatement) method.getBody().statements().get(0);
-			MethodInvocation methodCal = (MethodInvocation) statement.getExpression();
-			ITypeBinding binding = methodCal.resolveTypeBinding();
-			assertEquals("Incorrect type binding", "@A((int)1) Outer<@A((int)2) String>.@A((int)3) Inner<@A((int)4) Object>", binding.toString());
-		} finally {
-			deleteFile("/Converter18/src/A.java");
-			deleteFile("/Converter18/src/Outer.java");
-		}
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425599, [1.8][compiler] ISE when trying to compile qualified and annotated class instance creation 
-	public void test425599() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.ElementType;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"public class X {\n" +
-				"    Object ax = new @A(1) Outer().new @A(2) Middle<@A(3) String>();\n" +
-				"}\n" +
-				"@Target(ElementType.TYPE_USE) @interface A { int value(); }\n" +
-				"class Outer {\n" +
-				"    class Middle<E> {}\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 3, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		FieldDeclaration[] fields = typeDecl.getFields();
-		assertEquals("Incorrect no of methods", 1, fields.length);
-		FieldDeclaration field = fields[0];
-		assertEquals("Object ax=new @A(1) Outer().new @A(2) Middle<@A(3) String>();\n", field.toString());
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425216, Bug 425216 - [1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated
-	public void test425216() throws CoreException, IOException {
-		String contents = 
-				"import static java.lang.annotation.ElementType.TYPE_USE;\n" +
-				"import java.lang.annotation.Target;\n" +
-				"@Target(TYPE_USE)\n" +
-				"@interface NonNull {}\n" +
-				"public class X {\n" +
-				"   X foo(@NonNull X this) {\n" +
-				"	   return this;\n" +
-				"   }\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration[] methods = typeDecl.getMethods();
-		assertEquals("Incorrect no of methods", 1, methods.length);
-		MethodDeclaration method = methods[0];
-		ReturnStatement statement = (ReturnStatement) method.getBody().statements().get(0);
-		ThisExpression expression = (ThisExpression) statement.getExpression();
-		ITypeBinding type = expression.resolveTypeBinding();
-		assertEquals("@NonNull X", type.toString());
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425216, Bug 425216 - [1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated
-	public void test425216a() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.*;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface A {\n" +
-				"    int value() default 0;\n" +
-				"}\n" +
-				"public class Outer {\n" +
-				"    class Middle {\n" +
-				"    	class Inner {\n" +
-				"    		public @A(1) Inner(@A(2) Outer.@A(3) Middle Middle.this) {\n" +
-				"    			Outer r1 = Outer.this;\n" +
-				"    			Outer.Middle middle = Outer.Middle.this;\n" +
-				"    			Inner i = this;\n" +
-				"    		}\n" +
-				"    	}\n" +
-				"    }\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/Outer.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration method= typeDecl.getTypes()[0].getTypes()[0].getMethods()[0];
-		ITypeBinding receiverType = method.getReceiverType().resolveBinding();
-		assertEquals("@A((int)2) Outer.@A((int)3) Middle", receiverType.toString());
-		ITypeBinding declaringClass = receiverType.getDeclaringClass();
-		assertEquals("@A((int)2) Outer", declaringClass.toString());
-		final List statements = method.getBody().statements();
-		VariableDeclarationStatement statement = ((VariableDeclarationStatement) statements.get(0));
-		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		ITypeBinding type = fragment.getInitializer().resolveTypeBinding();
-		assertEquals("@A((int)2) Outer", type.toString());
-		statement = ((VariableDeclarationStatement) statements.get(1));
-		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		type = fragment.getInitializer().resolveTypeBinding();
-		assertEquals("@A((int)2) Outer.@A((int)3) Middle", type.toString());
-		assertEquals("@A((int)2) Outer", type.getDeclaringClass().toString());
-		statement = ((VariableDeclarationStatement) statements.get(2));
-		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
-		type = fragment.getInitializer().resolveTypeBinding();
-		assertTrue(type.getTypeAnnotations().length == 0);
-		assertTrue(type.getName().equals("Inner"));
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425216, Bug 425216 - [1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated
-	public void test425216b() throws CoreException, IOException {
-		String contents = 
-				"import java.lang.annotation.*;\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface A {\n" +
-				"    int value() default 0;\n" +
-				"}\n" +
-				"public class Outer {\n" +
-				"    class Middle {\n" +
-				"    	class Inner {\n" +
-				"    		public @A(1) Inner(@A(2) Outer.@A(3) Middle Middle.this) {\n" +
-				"    		}\n" +
-				"    	}\n" +
-				"    }\n" +
-				"}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/Outer.java", true);
-		ASTNode node = buildAST(contents, this.workingCopy);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		assertEquals("Incorrect no of types", 2, types.size());
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
-		MethodDeclaration method= typeDecl.getTypes()[0].getTypes()[0].getMethods()[0];
-		SimpleName receiverQualifier = method.getReceiverQualifier();
-		ITypeBinding type = receiverQualifier.resolveTypeBinding();
-		assertEquals("@A((int)2) Outer.@A((int)3) Middle", type.toString());
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=427320
-	public void testBug427320() throws Exception {
-		try {
-			String contents = 
-					"public class X {\n" +
-					"	@A @B @C X() {}\n" +
-					"	@A @B @C String foo() {\nreturn null;\n}\n" +
-					"}\n" +
-					"@java.lang.annotation.Target ({java.lang.annotation.ElementType.CONSTRUCTOR, "
-													+ "java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.TYPE_USE})\n" +
-					"@interface A {}\n" +
-					"@java.lang.annotation.Target ({java.lang.annotation.ElementType.CONSTRUCTOR, "
-													+ "java.lang.annotation.ElementType.METHOD})\n" +
-					"@interface B {}\n" +
-					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
-					"@interface C {}\n";
-		
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy, false);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-		List types = compilationUnit.types();
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		assertTrue("Should be a constructor", method.isConstructor());
-		IMethodBinding methodBinding = method.resolveBinding();
-		IAnnotationBinding[] annots = methodBinding.getAnnotations();
-		assertEquals("Incorrect no of annotations", 2, annots.length);
-		assertEquals("Incorrect annotations attached","@A()", annots[0].toString());
-		assertEquals("Incorrect annotations attached","@B()", annots[1].toString());
-		ITypeBinding binding = methodBinding.getReturnType();
-		annots = binding.getTypeAnnotations();
-		assertEquals("Incorrect no of annotations", 0, annots.length);
-		
-		method = typeDecl.getMethods()[1];
-		methodBinding = method.resolveBinding();
-		annots = methodBinding.getAnnotations();
-		assertEquals("Incorrect no of annotations", 2, annots.length);
-		assertEquals("Incorrect annotations attached","@A()", annots[0].toString());
-		assertEquals("Incorrect annotations attached","@B()", annots[1].toString());
-		binding = methodBinding.getReturnType();
-		annots = binding.getTypeAnnotations();
-		assertEquals("Incorrect no of annotations", 2, annots.length);
-		assertEquals("Incorrect annotations attached","@A @C String", binding.toString());
-		} finally {
-			deleteFile("/Converter18/src/X.java");
-		}
-	}
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=431810
-	public void testBug431810() throws Exception {
-		try {
-			String contents =
-				"import java.lang.annotation.ElementType; \n" +
-				"import java.lang.annotation.Target; \n" +
-				"@interface A {}\n" +
-				"@Target(ElementType.TYPE_USE)\n" +
-				"@interface B {} \n" +
-				"class X {\n" +
-				"	@A \n" +
-				"	X() {}\n" +
-				"	@B \n" +
-				"	X(int x) {}\n" +
-				"}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy, false);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-		assertProblemsSize(compilationUnit, 0);
-
-		List types = compilationUnit.types();
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
-
-		// X()
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		assertTrue("Should be a constructor", method.isConstructor());
-		IMethodBinding methodBinding = method.resolveBinding();
-		IAnnotationBinding[] annots = methodBinding.getAnnotations();
-
-		assertEquals("Incorrect no of annotations", 1, annots.length);
-		assertEquals("Incorrect annotations attached","@A()", annots[0].toString());
-
-		// X(int)
-		method = typeDecl.getMethods()[1];
-		assertTrue("Should be a constructor", method.isConstructor());
-		methodBinding = method.resolveBinding();
-		annots = methodBinding.getAnnotations();
-
-		assertEquals("Incorrect no of annotations", 0, annots.length);
-		} finally {
-			deleteFile("/Converter18/src/X.java");
-		}
-	}
-
-	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=431810
-	// Incorrect use of annotations on constructors
-	public void testBug431810a() throws Exception {
-		try {
-			String contents =
-				"import java.lang.annotation.ElementType; \n" +
-				"import java.lang.annotation.Target; \n" +
-				"@Target({}) \n" +
-				"@interface A {} \n" +
-				"@Target(ElementType.TYPE)\n" +
-				"@interface B {} \n" +
-				"class X {\n" +
-				"	@A \n" +
-				"	X() {}\n" +
-				"	@B \n" +
-				"	X(int x) {}\n" +
-				"}\n";
-
-		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
-		ASTNode node = buildAST(contents, this.workingCopy, false);
-		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
-		CompilationUnit compilationUnit = (CompilationUnit) node;
-
-		List types = compilationUnit.types();
-		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
-
-		// X()
-		MethodDeclaration method = typeDecl.getMethods()[0];
-		assertTrue("Should be a constructor", method.isConstructor());
-		IMethodBinding methodBinding = method.resolveBinding();
-		IAnnotationBinding[] annots = methodBinding.getAnnotations();
-		assertEquals("Incorrect no of annotations", 0, annots.length);
-
-		// X(int)
-		method = typeDecl.getMethods()[1];
-		assertTrue("Should be a constructor", method.isConstructor());
-		methodBinding = method.resolveBinding();
-		annots = methodBinding.getAnnotations();
-		assertEquals("Incorrect no of annotations", 0, annots.length);
-		} finally {
-			deleteFile("/Converter18/src/X.java");
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright (c) 2013, 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests.dom;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+
+import junit.framework.Test;
+
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.dom.AST;
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.ArrayType;
+import org.eclipse.jdt.core.dom.Assignment;
+import org.eclipse.jdt.core.dom.Block;
+import org.eclipse.jdt.core.dom.CastExpression;
+import org.eclipse.jdt.core.dom.CatchClause;
+import org.eclipse.jdt.core.dom.ClassInstanceCreation;
+import org.eclipse.jdt.core.dom.CompilationUnit;
+import org.eclipse.jdt.core.dom.CreationReference;
+import org.eclipse.jdt.core.dom.EnhancedForStatement;
+import org.eclipse.jdt.core.dom.Expression;
+import org.eclipse.jdt.core.dom.ExpressionStatement;
+import org.eclipse.jdt.core.dom.FieldDeclaration;
+import org.eclipse.jdt.core.dom.IAnnotationBinding;
+import org.eclipse.jdt.core.dom.IMethodBinding;
+import org.eclipse.jdt.core.dom.ITypeBinding;
+import org.eclipse.jdt.core.dom.IVariableBinding;
+import org.eclipse.jdt.core.dom.IfStatement;
+import org.eclipse.jdt.core.dom.InstanceofExpression;
+import org.eclipse.jdt.core.dom.MarkerAnnotation;
+import org.eclipse.jdt.core.dom.MethodDeclaration;
+import org.eclipse.jdt.core.dom.MethodInvocation;
+import org.eclipse.jdt.core.dom.ParameterizedType;
+import org.eclipse.jdt.core.dom.ParenthesizedExpression;
+import org.eclipse.jdt.core.dom.PrefixExpression;
+import org.eclipse.jdt.core.dom.QualifiedType;
+import org.eclipse.jdt.core.dom.ReturnStatement;
+import org.eclipse.jdt.core.dom.SimpleName;
+import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
+import org.eclipse.jdt.core.dom.ThisExpression;
+import org.eclipse.jdt.core.dom.TryStatement;
+import org.eclipse.jdt.core.dom.Type;
+import org.eclipse.jdt.core.dom.TypeDeclaration;
+import org.eclipse.jdt.core.dom.TypeMethodReference;
+import org.eclipse.jdt.core.dom.TypeParameter;
+import org.eclipse.jdt.core.dom.UnionType;
+import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
+import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
+import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
+import org.eclipse.jdt.core.dom.WildcardType;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+
+public class TypeBindingTests308 extends ConverterTestSetup {
+
+	ICompilationUnit workingCopy;
+
+	public static Test suite() {
+		return buildModelTestSuite(TypeBindingTests308.class);
+	}
+	public void setUpSuite() throws Exception {
+		super.setUpSuite();
+		this.ast = AST.newAST(AST.JLS8);
+	}
+	public TypeBindingTests308(String testName){
+		super(testName);
+	}
+	static {
+//		TESTS_NUMBERS = new int[] { };
+//		TESTS_RANGE = new int[] { };
+//		TESTS_NAMES = new String[] {"test027"};
+	}
+
+	private void verifyAnnotationOnType(Type type, String[] annots) {
+		verifyAnnotationsOnBinding(type.resolveBinding(), annots);
+	}
+
+	private void verifyAnnotationsOnBinding(ITypeBinding binding, String[] annots) {
+		IAnnotationBinding[] annotations = binding.getTypeAnnotations();
+		assertNotNull("Should not be null", annotations);
+		int length = annots.length;
+		assertEquals("Incorrect type use annotations", length, annotations.length);
+		for (int i = 0; i < length; i++) {
+			assertEquals("Incorrect annotation", annots[i], (annotations[i] == null) ? null : annotations[i].toString());
+		}
+	}
+
+	private void verifyAnnotationsOnBinding(IVariableBinding binding, String[] annots) {
+		IAnnotationBinding[] annotations = binding.getAnnotations();
+		assertNotNull("Should not be null", annotations);
+		int length = annots.length;
+		assertEquals("Incorrect annotations", length, annotations.length);
+		for (int i = 0; i < length; i++) {
+			assertEquals("Incorrect annotation", annots[i], (annotations[i] == null) ? null : annotations[i].toString());
+		}
+	}
+	
+	public void test000() throws Exception {
+		String contents = 
+					"public class X extends @Marker @SingleMember(0) @Normal(value = 0) Object {\n" +
+					"}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Marker {}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface SingleMember { int value() default 0;}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface Normal { int value() default 0;}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		Type type = typeDecl.getSuperclassType();
+		assertNotNull("Super class should not be null", type);
+		
+		verifyAnnotationOnType(type, new String[]{"@Marker()", "@SingleMember(value = 0)", "@Normal(value = 0)"});
+	}
+	public void test001() throws Exception {
+		String contents = 
+				"public class X {\n" +
+						"    @Marker int x;\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect field", 1, fields.length);
+		FieldDeclaration field = fields[0];
+		verifyAnnotationOnType(field.getType(), new String[]{"@Marker()"});
+	}
+	public void test002() throws Exception {
+		String contents = 
+						"public class X {\n" +
+						"    @Marker <@Marker2 T> int x() { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_PARAMETER)\n" +
+						"@interface Marker2{}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.typeParameters();
+		TypeParameter param = (TypeParameter) params.get(0);
+		ITypeBinding binding = param.resolveBinding();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		verifyAnnotationOnType(method.getReturnType2(), new String[]{"@Marker()"});
+	}
+	public void test003() throws Exception {
+		String contents = 
+						"public class X {\n" +
+						"    int x(@Marker int p) { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		ITypeBinding binding = param.resolveBinding().getType();
+		
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		verifyAnnotationOnType(param.getType(), new String[]{"@Marker()"});
+	}
+	public void test004() throws Exception {
+		String contents = 
+				"public class X {\n" +
+						"    int x(@Marker int ... p) { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		verifyAnnotationOnType(param.getType(), new String[]{"@Marker()"});
+	}
+
+	public void test005() throws Exception {
+			String contents = 
+				"public class X {\n" +
+						"    int x(@Marker int @Marker2 [] @Marker3 ... p) { return 10; };\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker2 {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker3 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List params = method.parameters();
+		SingleVariableDeclaration param = (SingleVariableDeclaration) params.get(0);
+		ArrayType type = (ArrayType) param.getType();
+		ITypeBinding binding = type.resolveBinding();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(param.resolveBinding().getType(), new String[]{"@Marker2()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}
+	public void test006() throws Exception {
+		String contents = 
+						"public class X {\n" +
+						"    int x() {\n" +
+						"        try {\n" +
+						"        } catch (@Marker NullPointerException | @Marker2 ArrayIndexOutOfBoundsException e) {\n" +
+						"        }\n" +
+						"        return 10;\n" +
+						"    }\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		TryStatement trySt = (TryStatement) statements.get(0);
+		CatchClause catchCl = (CatchClause) trySt.catchClauses().get(0);
+		UnionType union = (UnionType) catchCl.getException().getType();
+		types = union.types();
+		assertEquals("Incorrect union types", 2, types.size());
+		Type type = (Type) types.get(0);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		
+		type = (Type) types.get(1);
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+	}	
+	public void test007() throws Exception {
+		String contents = 
+				"package java.lang;\n" +
+				"public class X {\n" +
+				"    public void x() throws Exception {\n" +
+				"        try (@Marker LocalStream p = null; final @Marker2 LocalStream q = null; @Marker3 final LocalStream r = null) {}\n" +
+				"    }\n" +
+				"}\n" +
+				"class LocalStream implements AutoCloseable {\n" +
+				"    public void close() throws Exception {}\n" +
+				"}\n" +
+				"interface AutoCloseable {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/java/lang/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 6, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		TryStatement trySt = (TryStatement) statements.get(0);
+		List resources = trySt.resources();
+		assertEquals("Incorrect no of resources", 3, resources.size());
+		VariableDeclarationExpression resource = (VariableDeclarationExpression) resources.get(0);
+		Type type = resource.getType();
+		assertNotNull("Resource type should not be null", type);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		
+		resource = (VariableDeclarationExpression) resources.get(1);
+		type = resource.getType();
+		assertNotNull("Resource type should not be null", type);
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+		
+		resource = (VariableDeclarationExpression) resources.get(2);
+		type = resource.getType();
+		assertNotNull("Resource type should not be null", type);
+		verifyAnnotationOnType(type, new String[]{"@Marker3()"});
+	}
+	public void test008() throws Exception {
+		String contents = 
+				"public class X {\n" +
+						"    int x() {\n" +
+						"        for (@Marker int i: new int[3]) {}\n" +
+						"        for (final @Marker int i: new int[3]) {}\n" +
+						"        for (@Marker final int i: new int[3]) {}\n" +
+						"        return 10;\n" +
+						"    }\n" +
+						"}\n" +
+						"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+						"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		EnhancedForStatement forStmt = (EnhancedForStatement) statements.get(0);
+		SingleVariableDeclaration param = forStmt.getParameter();
+		Type type = param.getType();
+		assertNotNull("Resource type should not be null", type);
+		ITypeBinding binding = param.resolveBinding().getType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		binding = type.resolveBinding();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}	
+	public void test009() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    Object copy(int [] ia);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = @Marker int @Marker2 []::clone;\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		TypeMethodReference lambda = (TypeMethodReference) fragment.getInitializer();
+		ArrayType type = (ArrayType) lambda.getType();
+
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+		ITypeBinding binding = type.resolveBinding();
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}
+	public void test010() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        int i [] = new @Marker int @Marker2 [4];\n" +
+				"        int j [] = new @Marker2 int @Marker [] { 10 };\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		ArrayCreation arrayCr = (ArrayCreation) fragment.getInitializer();
+
+		ArrayType type = arrayCr.getType();
+		ITypeBinding binding = type.resolveBinding();
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+
+		stmt = (VariableDeclarationStatement) statements.get(1);
+		fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		arrayCr = (ArrayCreation) fragment.getInitializer();
+		type = arrayCr.getType();
+		
+		binding = type.resolveBinding();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+	}
+	public void test011() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        int i = (@Marker int) 0;\n" +
+				"        int j [] = (@Marker int @Marker2 []) null;\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		CastExpression castExp = (CastExpression) fragment.getInitializer();
+		Type type = castExp.getType();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		
+		stmt = (VariableDeclarationStatement) statements.get(1);
+		fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		castExp = (CastExpression) fragment.getInitializer();
+		ArrayType arrayType = (ArrayType) castExp.getType();
+		
+		ITypeBinding binding = arrayType.resolveBinding();
+		verifyAnnotationOnType(arrayType, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+	}
+	public void test012() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String args) {\n" +
+				"        if (args instanceof @Marker String) {\n" +
+				"        }\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect method", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		List statements = method.getBody().statements();
+		IfStatement ifStmt = (IfStatement) statements.get(0);
+		InstanceofExpression instanceOf = (InstanceofExpression) ifStmt.getExpression();
+		Type type = instanceOf.getRightOperand();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+	}
+	public void test013() throws Exception {
+			String contents = 
+				"public class X extends Y<@Marker(10) Integer, String> {}\n" +
+				"class Y<T, V> {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {int value();}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		ParameterizedType superClass = (ParameterizedType) typeDecl.getSuperclassType();
+		List arguments = superClass.typeArguments();
+		assertEquals("Incorrect no of type arguments", 2, arguments.size());
+		Type type = (Type) arguments.get(0);
+		
+		verifyAnnotationOnType(type, new String[]{"@Marker(value = 10)"});
+	}
+	public void test014() throws Exception {
+		String contents = 
+				"public class X<T extends Object & Comparable<? super @Marker String>> {}\n" +
+				"class Y<T> {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		List typeParams = typeDecl.typeParameters();
+
+		TypeParameter typeParam = (TypeParameter) typeParams.get(0);
+		List bounds = typeParam.typeBounds();
+		assertEquals("Incorrect no of type bounds", 2, bounds.size());
+		ParameterizedType type = (ParameterizedType) bounds.get(1);
+		typeParams = type.typeArguments();
+		assertEquals("Incorrect type params", 1, typeParams.size());
+		WildcardType wildcard = (WildcardType)typeParams.get(0);
+		Type bound = wildcard.getBound();
+		assertNotNull("Bound should not be null", bound);
+		verifyAnnotationOnType(bound, new String[]{"@Marker()"});
+	}
+	public void test015() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"	void foo(Map<@Marker ? super @Marker2 Object, @Marker3 ? extends @Marker4 String> m){}\n" +
+				"   void goo(Map<@Marker4 ? extends @Marker3 Object, @Marker2 ? super @Marker String> m){}\n" +
+				"}\n" +
+				"class Map<K, V>{}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker4 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 6, types.size());
+		
+		MethodDeclaration[] methods = ((TypeDeclaration) types.get(0)).getMethods();
+		assertEquals("Incorrect no of metods", 2, methods.length);
+		MethodDeclaration method = methods[0];
+		SingleVariableDeclaration arg = (SingleVariableDeclaration) method.parameters().get(0);
+		
+		
+		List typeArgs = ((ParameterizedType) arg.getType()).typeArguments();
+		
+		WildcardType wildcard = (WildcardType) typeArgs.get(0);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker()"});
+		Type type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+
+		wildcard = (WildcardType) typeArgs.get(1);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker3()"});
+		type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker4()"});
+		
+		method = methods[1];
+		arg = (SingleVariableDeclaration) method.parameters().get(0);
+		typeArgs = ((ParameterizedType) arg.getType()).typeArguments();
+
+		wildcard = (WildcardType) typeArgs.get(0);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker4()"});
+		type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker3()"});
+
+		wildcard = (WildcardType) typeArgs.get(1);
+		verifyAnnotationOnType(wildcard, new String[]{"@Marker2()"});
+		type = wildcard.getBound();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+	}
+	public void test016() throws Exception {
+		String contents = 
+				"public class X<E> {\n" +
+				"  class Y {\n" +
+				"    E e;\n" +
+				"    E getOtherElement(Object other) {\n" +
+				"      if (!(other instanceof @Marker X<?>.Y)) {};\n" +
+				"      return null;\n" +
+				"    }\n" +
+				"  }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		typeDecl = typeDecl.getTypes()[0];
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		IfStatement ifStmt = (IfStatement) method.getBody().statements().get(0);
+		PrefixExpression prefix = (PrefixExpression ) ifStmt.getExpression();
+		ParenthesizedExpression operand = (ParenthesizedExpression) prefix.getOperand();
+		InstanceofExpression expression = (InstanceofExpression) operand.getExpression();
+		QualifiedType type = (QualifiedType) expression.getRightOperand();
+		verifyAnnotationOnType(type, new String[]{});
+		verifyAnnotationOnType(type.getQualifier(), new String[]{"@Marker()"});
+	}
+	public void test017() throws Exception {
+		String contents = 
+				"public class X<P, C> {\n" +
+				"  public X() {\n" +
+				"    if (!(this instanceof @Marker X)) {}\n" +
+				"  }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		IfStatement ifStmt = (IfStatement) method.getBody().statements().get(0);
+		PrefixExpression prefix = (PrefixExpression ) ifStmt.getExpression();
+		ParenthesizedExpression operand = (ParenthesizedExpression) prefix.getOperand();
+		InstanceofExpression expression = (InstanceofExpression) operand.getExpression();
+		verifyAnnotationOnType(expression.getRightOperand(), new String[]{"@Marker()"});
+	}
+	public void test018() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    void foo(Y<String>.Z z, int x);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = Y<String>.@Marker Z::foo;\n" +
+				"        i.foo(new Y<String>().new Z(), 10); \n" +
+				"    }\n" +
+				"}\n" +
+				"class Y<T> {\n" +
+				"    class Z {\n" +
+				"        void foo(int x) {\n" +
+				"        }\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) method.getBody().statements().get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		TypeMethodReference initializer = (TypeMethodReference) fragment.getInitializer();
+		Type type = initializer.getType();
+		assertTrue(type.isQualifiedType());
+		QualifiedType qualifiedType = (QualifiedType) type;
+		checkSourceRange(qualifiedType.getName(), "Z", contents);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		assertEquals("Should be a qualified type", ASTNode.QUALIFIED_TYPE, type.getNodeType());
+		verifyAnnotationOnType(((QualifiedType) type).getQualifier() , new String[]{});
+	}
+	public void test019() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        X [] x = new @Marker X @Marker2 [5];\n" +
+				"        X [] x2 = new @Marker2 X @Marker [] { null };\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		assertEquals("Incorrect no of statements", 2, statements.size());
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		ArrayCreation initializer = (ArrayCreation) fragment.getInitializer();
+		ArrayType arrayType = initializer.getType();
+		ITypeBinding binding = arrayType.resolveBinding();
+		
+		verifyAnnotationOnType(arrayType, new String[]{"@Marker2()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+		
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+
+		statement = (VariableDeclarationStatement) statements.get(1);
+		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		initializer = (ArrayCreation) fragment.getInitializer();
+		arrayType = initializer.getType();
+		binding = arrayType.resolveBinding();
+		verifyAnnotationOnType(arrayType, new String[]{"@Marker()"});
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker()"});
+		
+		binding = binding.getComponentType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@Marker2()"});
+	}
+	public void test020() throws Exception {
+		String contents = 
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        Map.Entry<String, String> [] e = (Map.@Marker Entry<String, String> []) null;\n" +
+				"    }\n" +
+				"}\n" +
+				"class Map<K, V> {\n" +
+				"	interface Entry<K, V> {}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		assertEquals("Incorrect no of statements", 1, statements.size());
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		CastExpression castExp = (CastExpression) fragment.getInitializer();
+		ArrayType arrayType = (ArrayType) castExp.getType();
+		verifyAnnotationOnType(arrayType, new String[]{});
+		ParameterizedType type = (ParameterizedType) arrayType.getElementType();
+		verifyAnnotationOnType(type.getType(), new String[]{"@Marker()"});
+	}
+	public void test021() throws Exception {
+		String contents = 
+				"import java.io.Serializable;\n" +
+				"import java.util.List;\n" +
+				"public class X<T extends Comparable<T> & Serializable> {\n" +
+				"	void foo(List<? extends @Marker @Marker2 Comparable<T>> p) {} \n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		SingleVariableDeclaration param = (SingleVariableDeclaration) method.parameters().get(0);
+		Type type = param.getType();
+		assertEquals("Should be a parameterized type", ASTNode.PARAMETERIZED_TYPE, type.getNodeType());
+		List typeArgs = ((ParameterizedType) type).typeArguments();
+		assertEquals("Incorrect type args", 1, typeArgs.size());
+		WildcardType wildcard = (WildcardType) typeArgs.get(0);
+		ParameterizedType bound = (ParameterizedType) wildcard.getBound();
+		verifyAnnotationOnType(bound, new String[]{"@Marker()", "@Marker2()"});
+	}
+	public void test022() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    X x = new @Marker X();\n" +
+				"    X y = new <String> @Marker X();\n" +	
+				"	<T> X(){}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 2, fields.length);
+		FieldDeclaration field = fields[0];
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		ClassInstanceCreation creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+		
+		field = fields[1];
+		fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+	}
+	public void test023() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    class Y {\n" +
+				"	    <T> Y(){}\n" +
+				"    }\n" +
+				"    Y y1 = new @Marker X().new @Marker2 Y();\n" +
+				"    Y y2 = new @Marker2 X().new <String> @Marker Y();\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 2, fields.length);
+		FieldDeclaration field = fields[0];
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		ClassInstanceCreation creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker2()"});
+		creation = (ClassInstanceCreation) creation.getExpression();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+		
+		field = fields[1];
+		fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		creation = (ClassInstanceCreation) fragment.getInitializer();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker()"});
+		creation = (ClassInstanceCreation) creation.getExpression();
+		verifyAnnotationOnType(creation.getType(), new String[]{"@Marker2()"});
+	}
+	public void test024() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    void foo() throws @Marker NullPointerException, @Marker2 ArrayIndexOutOfBoundsException {}\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List thrownTypes = method.thrownExceptionTypes();
+		assertEquals("Incorrect no of thrown exceptions", 2, thrownTypes.size());
+		Type type = (Type) thrownTypes.get(0);
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		type = (Type) thrownTypes.get(1);
+		verifyAnnotationOnType(type, new String[]{"@Marker2()"});
+	}
+	public void test025() throws Exception {
+		String contents = 
+				"interface I {}\n" +
+				"interface J {}\n" +
+				"interface K extends @Marker I, @Marker2 J {}\n" +
+				"interface L {}\n" +
+				"public class X implements @Marker2 K, @Marker L {\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 7, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
+		List interfaces = typeDecl.superInterfaceTypes();
+		assertEquals("Incorrect no of super interfaces", 2, interfaces.size());
+		verifyAnnotationOnType((Type) interfaces.get(0), new String[]{"@Marker()"});
+		verifyAnnotationOnType((Type) interfaces.get(1), new String[]{"@Marker2()"});
+		
+		typeDecl = (TypeDeclaration) types.get(4);
+		interfaces = typeDecl.superInterfaceTypes();
+		assertEquals("Incorrect no of super interfaces", 2, interfaces.size());
+		verifyAnnotationOnType((Type) interfaces.get(0), new String[]{"@Marker2()"});
+		verifyAnnotationOnType((Type) interfaces.get(1), new String[]{"@Marker()"});
+	}
+	public void test026() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    void foo(int x);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = A.Y.@Marker Z ::foo;\n" +
+				"        i.foo(10); \n" +
+				"    }\n" +
+				"}\n" +
+				"class A {\n" +
+				"  static class Y {\n" +
+				"    static class Z {\n" +
+				"        public static void foo(int x) {\n" +
+				"	        System.out.println(x);\n" +
+				"        }\n" +
+				"    }\n" +
+				"  }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		
+		VariableDeclarationStatement stmt = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) stmt.fragments().get(0);
+		TypeMethodReference lambda = (TypeMethodReference) fragment.getInitializer();
+		Type type = lambda.getType();
+
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+	}
+	public void test027() throws Exception {
+		String contents = 
+				"interface I {\n" +
+				"    Y foo(int x);\n" +
+				"}\n" +
+				"public class X  {\n" +
+				"    class Z extends Y {\n" +
+				"        public Z(int x) {\n" +
+				"            super(x);\n" +
+				"        }\n" +
+				"    }\n" +
+				"    public static void main(String [] args) {\n" +
+				"        I i = @Marker W<@Marker2 Integer>::<@Marker3 String> new;\n" +
+				"    }\n" +
+				"}\n" +
+				"class W<T> extends Y {\n" +
+				"    public <C> W(T x) {\n" +
+				"        super(0);\n" +
+				"    }\n" +
+				"}\n" +
+				"class Y {\n" +
+				"    public Y(int x) {\n" +
+				"    }\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker2 {}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker3 {}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 7, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		List statements = method.getBody().statements();
+		VariableDeclarationStatement statement = (VariableDeclarationStatement) statements.get(0);
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		CreationReference lambda = (CreationReference) fragment.getInitializer();
+		Type type = lambda.getType();
+		verifyAnnotationOnType(type, new String[]{"@Marker()"});
+		ParameterizedType paramType = (ParameterizedType) type;
+		verifyAnnotationOnType((Type) paramType.typeArguments().get(0), new String[]{"@Marker2()"});
+		List typeArgs = lambda.typeArguments();
+		verifyAnnotationOnType((Type) typeArgs.get(0), new String[]{"@Marker3()"});
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=418096
+	public void test028() throws Exception {
+		String contents = 
+				"public class X {\n" +
+				"    @TypeUseAnnotation(\"a\") String @TypeUseAnnotation(\"a1\") [] @TypeUseAnnotation(\"a2\") [] _field2 @TypeUseAnnotation(\"a3\") [], _field3 @TypeUseAnnotation(\"a4\") [][] = null;\n" +
+				"}" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface TypeUseAnnotation {\n" +
+				"	String value() default \"\";\n" +
+				"}\n";
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 1, fields.length);
+		FieldDeclaration field = fields[0];
+		List fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 2, fragments.size());
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
+		ITypeBinding binding = fragment.resolveBinding().getType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@TypeUseAnnotation(value = a3)"});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a1)"});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a2)"});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a)"});
+		fragment = (VariableDeclarationFragment) fragments.get(1);
+		binding = fragment.resolveBinding().getType();
+		verifyAnnotationsOnBinding(binding, new String[]{"@TypeUseAnnotation(value = a4)"});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a1)"});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a2)"});
+		verifyAnnotationsOnBinding(binding = binding.getComponentType(), new String[]{"@TypeUseAnnotation(value = a)"});
+	}
+	
+	public void testAnnotatedBinaryType() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer  {\n" +
+				"	class Middle {\n" +
+				"		class Inner {\n" +
+				"		}\n" +
+				"	}\n" +
+				"	public @Marker(\"Outer\") Outer.@Marker (\"Middle\") Middle.@Marker(\"Inner\") Inner omi;\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {\n" +
+				"	String value() default \"GOK\";\n" +
+				"}\n"
+			};
+		
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer o) {\n" +
+					"        o.omi = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@Marker((String)\"Outer\") Outer.@Marker((String)\"Middle\") Middle.@Marker((String)\"Inner\") Inner", type.toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testAnnotatedBinaryType2() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer  {\n" +
+				"	class Middle {\n" +
+				"		class Inner {\n" +
+				"		}\n" +
+				"	}\n" +
+				"	public @Marker(\"Outer\") Outer.@Marker (\"Middle\") Middle.@Marker(\"Inner\") Inner @Marker(\"Prefix []\") [] omi @Marker(\"Extended []\") [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface Marker {\n" +
+				"	String value() default \"GOK\";\n" +
+				"}\n"
+			};
+		
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer o) {\n" +
+					"        o.omi = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@Marker((String)\"Outer\") Outer.@Marker((String)\"Middle\") Middle.@Marker((String)\"Inner\") Inner @Marker((String)\"Extended []\") [] @Marker((String)\"Prefix []\") []", type.toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testAnnotatedBinaryType3() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	public @T(1) Outer<@T(2) String>.@T(3) Inner<@T(4) Integer> @T(5) [] omi @T(6) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.omi = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T((int)1) Outer<@T((int)2) String>.@T((int)3) Inner<@T((int)4) Integer> @T((int)6) [] @T((int)5) []", type.toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	
+	public void testAnnotatedBinaryType4() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	@T(1) K @T(2) [] f @T(3) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.f = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T((int)1) String @T((int)3) [] @T((int)2) []", type.toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testAnnotatedBinaryType5() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	@T(1) Outer<@T(2) ? extends @T(3) String>.@T(4) Inner<@T(5) ? super @T(6) Integer> @T(7) [] f @T(8) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.f = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T((int)1) Outer<@T((int)2) ? extends @T((int)3) String>.@T((int)4) Inner<@T((int)5) ? super @T((int)6) Integer> @T((int)8) [] @T((int)7) []", type.toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testAnnotatedBinaryType6() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer<K>  {\n" +
+				"	class Inner<P> {\n" +
+				"	}\n" +
+				"	@T(1) Outer.@T(2) Inner @T(3) [] f @T(4) [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value();\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer<String> o) {\n" +
+					"        o.f = null;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T((int)1) Outer#RAW.@T((int)2) Inner#RAW @T((int)4) [] @T((int)3) []", type.toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testIntersectionCastType() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.ElementType;\n" +
+						"import java.lang.annotation.Target;\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface T1 {\n" +
+						"}\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface T2 {\n" +
+						"}\n" +
+						"@Target(ElementType.TYPE_USE)\n" +
+						"@interface T3 {\n" +
+						"}\n" +
+						"public class X {\n" +
+						"	Object o = (@T1 Object & @T2 Runnable & java.io.@T3 Serializable) null;\n" +
+						"	Object p = (@T1 Object & @T2 Runnable & java.io.@T3 Serializable) null;\n" +
+						"}\n";
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 4, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(3);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 2, fields.length);
+		FieldDeclaration field = fields[0];
+		List fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);
+		CastExpression cast = (CastExpression) fragment.getInitializer();
+		Type castType = cast.getType();
+		ITypeBinding binding1 = castType.resolveBinding();
+		assertEquals("Wrong annotations", "@T1 Object & @T2 Runnable & @T3 Serializable", binding1.toString());
+		
+		field = fields[1];
+		fragments = field.fragments();
+		assertEquals("Incorrect no of fragments", 1, fragments.size());
+		fragment = (VariableDeclarationFragment) fragments.get(0);
+		cast = (CastExpression) fragment.getInitializer();
+		castType = cast.getType();
+		ITypeBinding binding2 = castType.resolveBinding();
+		assertEquals("Wrong annotations", "@T1 Object & @T2 Runnable & @T3 Serializable", binding2.toString());
+		assertSame("Should be equal", binding1, binding2);
+	}
+	public void testMemberType() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer  {\n" +
+				"	class Inner {\n" +
+				"	}\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(@T Outer o) {\n" +
+					"    }\n" +
+					"}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface T {\n" +
+					"}\n";
+					
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 2, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			List parameters = method.parameters();
+			SingleVariableDeclaration parameter = (SingleVariableDeclaration) parameters.get(0);
+			ITypeBinding binding = parameter.resolveBinding().getType();
+			assertEquals("@T Outer", binding.toString());
+			ITypeBinding [] memberTypes = binding.getDeclaredTypes();
+			assertEquals("Incorrect no of types", 1, memberTypes.length);
+			assertEquals("Incorrect no of types", "@T Outer.Inner", memberTypes[0].toString());
+			assertEquals("Incorrect no of types", "@T Outer", memberTypes[0].getDeclaringClass().toString());
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testMemberType2() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer  {\n" +
+				"    @T Outer f;\n"+
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Outer o) {\n" +
+					"		o.f = null;\n" +
+					"    }\n" +
+					"}\n";
+					
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			assertEquals("Wrong type", "@T Outer", type.toString());
+			IVariableBinding[] declaredFields = type.getDeclaredFields();
+			assertEquals("Wrong type", 1, declaredFields.length);
+			assertEquals("Wrong type", "@T Outer", declaredFields[0].getType().toString());
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testBinarySuperInterfaces() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Y.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T1 {\n" +
+				"}\n" +
+				"public abstract class Y implements Comparable<@T1 Y>{  \n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"    void foo(Y y) {\n" +
+					"    }\n" +
+					"}\n";
+					
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			List parameters = method.parameters();
+			SingleVariableDeclaration parameter = (SingleVariableDeclaration) parameters.get(0);
+			ITypeBinding binding = parameter.resolveBinding().getType();
+			ITypeBinding binding2 = binding.getInterfaces()[0].getTypeArguments()[0];
+			assertEquals("Wrong type", "@T1 Y", binding2.toString());
+			assertEquals("Wrong type", "Comparable<@T1 Y>", binding2.getInterfaces()[0].toString());		
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testMemberTypeSource() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"    class Y {}\n" +
+				"    @T X.Y xy;\n" +
+				"}\n";
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 1, fields.length);
+		FieldDeclaration field = fields[0];
+		ITypeBinding binding = field.getType().resolveBinding();
+		assertEquals("Wrong Type", "@T X", (binding = binding.getDeclaringClass()).toString());
+		assertEquals("Wrong Type", "@T X.Y", (binding = binding.getDeclaredTypes()[0]).toString());
+	}
+	public void testAnnotatedTypeIdentity() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"import java.util.List;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"    @T List<@T String> ls = (@T List<@T String>) null;\n" +
+				"}\n";
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 1, fields.length);
+		FieldDeclaration field = fields[0];
+		ITypeBinding binding = field.getType().resolveBinding();
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		CastExpression cast = (CastExpression) fragment.getInitializer();
+		ITypeBinding binding2 = cast.resolveTypeBinding();
+		assertEquals("Wrong Type", "@T List<@T String>", binding.toString());
+		assertSame("not Equal", binding, binding2);
+	}
+	public void testAnnotatedTypeIdentity2() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"public class Outer  {\n" +
+				"	Outer @T [] f @T [];\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value() default 10;\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"public class X {\n" +
+					"	 Outer @T [] f @T [];\n" +
+					"    void foo(Outer o) {\n" +
+					"        o.f = this.f;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			Expression right = assignment.getRightHandSide();
+			ITypeBinding type2 = right.resolveTypeBinding();
+			assertEquals("Wrong type", "Outer @T [] @T []", type.toString());
+			assertSame ("Should be same", type, type2);
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testAnnotatedTypeIdentity3() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Outer.java",
+				"import java.util.List;\n" +
+				"public class Outer  {\n" +
+				"	@T List<@T String> ls;\n" +
+				"}\n" +
+				"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value() default 10;\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"import java.util.List;\n" +
+					"public class X {\n" +
+					"	@T List<@T String> ls;\n" +
+					"    void foo(Outer o) {\n" +
+					"        o.ls = this.ls;\n" +
+					"    }\n" +
+					"}";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			
+			MethodDeclaration[] methods = typeDecl.getMethods();
+			assertEquals("Incorrect no of methods", 1, methods.length);
+			MethodDeclaration method = methods[0];
+			Block body = method.getBody();
+			ExpressionStatement stmt = (ExpressionStatement) body.statements().get(0);
+			Assignment assignment = (Assignment) stmt.getExpression();
+			Expression left = assignment.getLeftHandSide();
+			ITypeBinding type = left.resolveTypeBinding();
+			Expression right = assignment.getRightHandSide();
+			ITypeBinding type2 = right.resolveTypeBinding();
+			assertEquals("Wrong type", "@T List<@T String>", type.toString());
+			assertSame ("Should be same", type, type2);
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	public void testHybridAnnotations() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@interface A {\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface AUse {\n" +
+				"}\n" +
+				"@Target({ElementType.TYPE_USE, ElementType.PARAMETER})\n" +
+				"@interface AUseParameter {\n" +
+				"}\n" +
+				"@Target({ElementType.TYPE_USE, ElementType.LOCAL_VARIABLE})\n" +
+				"@interface AUseLocal {\n" +
+				"}\n" +
+				"@Target({ElementType.PARAMETER})\n" +
+				"@interface AParameter {\n" +
+				"}\n" +
+				"public class X {    \n" +
+				"	void foo(@A @AUse @AUseParameter @AUseLocal @AParameter X x) {\n" +
+				"	}\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 6, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(5);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect no of methods", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		SingleVariableDeclaration parameter = (SingleVariableDeclaration) method.parameters().get(0);
+		IVariableBinding parameterBinding = parameter.resolveBinding();
+		verifyAnnotationsOnBinding(parameterBinding, new String [] { "@A()", "@AUseParameter()", "@AParameter()" });
+		ITypeBinding type = parameterBinding.getType();
+		verifyAnnotationsOnBinding(type, new String [] { "@AUse()", "@AUseParameter()", "@AUseLocal()" });
+	}
+	public void testGenericMethod() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.Annotation;\n" +
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"}\n" +
+				"public class X { \n" +
+				"	<N extends Annotation> @T String f(N a) {\n" +
+				"		return null;\n" +
+				"	}\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect no of methods", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		Type returnType = method.getReturnType2();
+		ITypeBinding type = returnType.resolveBinding();
+		verifyAnnotationsOnBinding(type, new String [] { "@T()" });
+	}
+	public void testHybridAnnotations2() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.Target;\n" +
+				"import java.lang.annotation.ElementType;\n" +
+				"@Target({ ElementType.TYPE_USE, ElementType.METHOD })\n" +
+				"@interface SillyAnnotation {  }\n" +
+				"public class X {\n" +
+				"    @SillyAnnotation\n" +
+				"    X(@SillyAnnotation int x) {\n" +
+				"    }\n" +
+				"    @SillyAnnotation\n" +
+				"    void foo(@SillyAnnotation int x) {\n" +
+				"    }\n" +
+				"    @SillyAnnotation\n" +
+				"    String goo(@SillyAnnotation int x) {\n" +
+				"	return null;\n" +
+				"    }\n" +
+				"    @SillyAnnotation\n" +
+				"    X field;\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect no of methods", 3, methods.length);
+		
+		MethodDeclaration method = methods[0];
+		List modifiers = method.modifiers();
+		int size = modifiers.size();
+		assertTrue("Should be just 1", size == 1);
+		MarkerAnnotation annotation = (MarkerAnnotation) modifiers.get(0);
+		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
+		SingleVariableDeclaration parameter = (SingleVariableDeclaration) method.parameters().get(0);
+	    IAnnotationBinding [] annotations = parameter.resolveBinding().getAnnotations();
+		assertTrue("should be 0", annotations == null || annotations.length == 0);
+		IAnnotationBinding [] typeAnnotations = parameter.getType().resolveBinding().getTypeAnnotations();
+		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
+		
+		method = methods[1];
+		modifiers = method.modifiers();
+		size = modifiers.size();
+		assertTrue("Should be just 1", size == 1);
+		annotation = (MarkerAnnotation) modifiers.get(0);
+		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
+		typeAnnotations = method.getReturnType2().resolveBinding().getTypeAnnotations();
+		assertTrue("Should be just 0", typeAnnotations.length == 0);
+		parameter = (SingleVariableDeclaration) method.parameters().get(0);
+	    annotations = parameter.resolveBinding().getAnnotations();
+		assertTrue("should be 0", annotations == null || annotations.length == 0);
+		typeAnnotations = parameter.getType().resolveBinding().getTypeAnnotations();
+		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
+		
+		method = methods[2];
+		modifiers = method.modifiers();
+		size = modifiers.size();
+		assertTrue("Should be just 1", size == 1);
+		annotation = (MarkerAnnotation) modifiers.get(0);
+		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
+		typeAnnotations = method.getReturnType2().resolveBinding().getTypeAnnotations();
+		assertTrue("Should be just 1", typeAnnotations.length == 1);
+		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
+		parameter = (SingleVariableDeclaration) method.parameters().get(0);
+	    annotations = parameter.resolveBinding().getAnnotations();
+		assertTrue("should be 0", annotations == null || annotations.length == 0);
+		typeAnnotations = parameter.getType().resolveBinding().getTypeAnnotations();
+		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
+		
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of fields", 1, fields.length);
+		
+		FieldDeclaration field = fields[0];
+		modifiers = field.modifiers();
+		size = modifiers.size();
+		assertTrue("Should be just 1", size == 1);
+		annotation = (MarkerAnnotation) modifiers.get(0);
+		assertEquals("Incorrect annotation", "@SillyAnnotation", annotation.toString());
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) field.fragments().get(0);
+		annotations = fragment.resolveBinding().getAnnotations();
+		assertTrue("Incorrect annotation", annotations == null || annotations.length == 0);
+		
+		typeAnnotations = field.getType().resolveBinding().getTypeAnnotations();
+		assertTrue("Should be just 1", typeAnnotations.length == 1);
+		assertEquals("Incorrect annotation", "@SillyAnnotation()", typeAnnotations[0].toString());
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419918, [1.8][compiler] Annotations are not restored from class files in a few situations.
+	public void testBinaryWithoutGenericSignature() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Superclass.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value() default 0;\n" +
+				"}\n" +
+				"@T(1)\n" +
+				"public abstract class Superclass extends @T(2) Object implements @T(3) Runnable {\n" +
+				"	Object @T(4) [] field;\n" +
+				"	@T(5)\n" +
+				"	public String run(@T(6) Superclass this, Object @T(7) [] that) throws @T(8) NullPointerException {\n" +
+				"		return null;\n" +
+				"	}\n" +
+				"   @T(9)\n" +
+				"   Superclass () {}\n" +
+				"   @T(10)\n" +
+				"   class Inner {}\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"@T(21)\n" +
+					"public abstract class X extends @T(22) Superclass implements @T(23) Runnable {\n" +
+					"	Object @T(24) [] field;\n" +
+					"	@T(25)\n" +
+					"	public String run(@T(26) X this, Object @T(27) [] that) throws @T(28) NullPointerException {\n" +
+					"		return null;\n" +
+					"	}\n" +
+					"   @T(29)\n" +
+					"   X() {\n" +
+		            "   }" +
+					"   @T(30)\n" +
+					"   class Inner {\n" +
+					"   }\n" +
+					"}\n";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			ITypeBinding typeBinding = typeDecl.resolveBinding();
+			IAnnotationBinding[] annotations = typeBinding.getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 21)", annotations[0].toString());
+			annotations = typeBinding.getSuperclass().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 22)", annotations[0].toString());
+			annotations = typeBinding.getInterfaces()[0].getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 23)", annotations[0].toString());
+			
+			annotations = typeDecl.getFields()[0].getType().resolveBinding().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 24)", annotations[0].toString());
+			
+			annotations = typeDecl.getMethods()[0].getReturnType2().resolveBinding().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 25)", annotations[0].toString());
+			
+			annotations = typeDecl.getMethods()[0].getReceiverType().resolveBinding().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 26)", annotations[0].toString());
+			
+			annotations = ((SingleVariableDeclaration) (typeDecl.getMethods()[0].parameters().get(0))).getType().resolveBinding().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 27)", annotations[0].toString());
+			
+			annotations = ((Type) typeDecl.getMethods()[0].thrownExceptionTypes().get(0)).resolveBinding().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 28)", annotations[0].toString());
+			
+			annotations = typeDecl.getMethods()[1].resolveBinding().getAnnotations();
+			assertTrue("Should be 0", annotations.length == 0);
+			
+			annotations = typeDecl.getTypes()[0].resolveBinding().getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 30)", annotations[0].toString());
+			
+			
+			// Check the same set of things for the binary type.
+			annotations = typeBinding.getSuperclass().getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 1)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getSuperclass().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 2)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getInterfaces()[0].getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 3)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getDeclaredFields()[0].getType().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 4)", annotations[0].toString());
+			
+			// Skip past the constructor at [0]
+			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getReturnType().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 5)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getDeclaredReceiverType().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 6)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getParameterTypes()[0].getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 7)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getDeclaredMethods()[1].getExceptionTypes()[0].getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 8)", annotations[0].toString());
+			
+			annotations = typeBinding.getSuperclass().getDeclaredMethods()[0].getAnnotations();
+			assertTrue("Should be 0", annotations.length == 0);
+			
+			annotations = typeBinding.getSuperclass().getDeclaredTypes()[0].getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 10)", annotations[0].toString());
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	// Variants where superclass in binary is an annotated inner/nested class
+	public void testBinaryWithoutGenericSignature_b() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"Superclass.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value() default 0;\n" +
+				"}\n" +
+				"@T(1)\n" +
+				"public abstract class Superclass extends @T(2) Object implements @T(3) Runnable {\n" +
+				"   @T(9)\n" +
+				"   Superclass () {}\n" +
+				"   @T(10)\n" +
+				"   class Inner {}\n" +
+				"   @T(11)\n" +
+				"   class SubInner extends @T(12) Inner {}\n" +
+				"   @T(13)\n" +
+				"   static class Nested {}\n" +
+				"   @T(14)\n" +
+				"   static class SubNested extends @T(15) Nested {}\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"@T(21)\n" +
+					"public abstract class X extends @T(22) Superclass implements @T(23) Runnable {\n" +
+					"}\n";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 0);
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			ITypeBinding typeBinding = typeDecl.resolveBinding();
+			IAnnotationBinding[] annotations = typeBinding.getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 21)", annotations[0].toString());
+			
+			ITypeBinding superclass = typeBinding.getSuperclass();
+			ITypeBinding[] inners = superclass.getDeclaredTypes();
+			assertTrue("Should be 2", inners.length == 4);
+			
+			ITypeBinding subInner = inners[2];
+			assertEquals("Type name mismatch", "SubInner", subInner.getName());
+			annotations = subInner.getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 11)", annotations[0].toString());
+			
+			annotations = subInner.getSuperclass().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 12)", annotations[0].toString());
+			
+			ITypeBinding subNested = inners[3];
+			annotations = subNested.getAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 14)", annotations[0].toString());
+			
+			annotations = subNested.getSuperclass().getTypeAnnotations();
+			assertTrue("Should be 1", annotations.length == 1);
+			assertEquals("Annotation mismatch", "@T(value = 15)", annotations[0].toString());			
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=419918, [1.8][compiler] Annotations are not restored from class files in a few situations.
+	public void testBinaryAnnotationType() throws CoreException, IOException {
+		String jarName = "TypeBindingTests308.jar";
+		String srcName = "TypeBindingTests308_src.zip";
+		final IJavaProject javaProject = getJavaProject("Converter18");
+		try {
+			String[] pathAndContents = new String[] {
+				"T.java",
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Deprecated\n" +		
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface T {\n" +
+				"	int value() default 0;\n" +
+				"}\n"
+			};
+			
+			HashMap libraryOptions = new HashMap(javaProject.getOptions(true));
+			libraryOptions.put(CompilerOptions.OPTION_Store_Annotations, CompilerOptions.ENABLED);
+			addLibrary(javaProject, jarName, srcName, pathAndContents, JavaCore.VERSION_1_8, libraryOptions);
+			
+			String contents = 
+					"@T\n" +
+					"public class X {\n" +
+					"}\n";
+			
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy, false);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			CompilationUnit compilationUnit = (CompilationUnit) node;
+			assertProblemsSize(compilationUnit, 1, "The type T is deprecated");
+			List types = compilationUnit.types();
+			assertEquals("Incorrect no of types", 1, types.size());
+			TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+			ITypeBinding typeBinding = typeDecl.resolveBinding();
+			IAnnotationBinding[] annotations = typeBinding.getAnnotations()[0].getAnnotationType().getAnnotations();
+			assertTrue("Should be 2", annotations.length == 2);
+			assertEquals("Annotation mismatch", "@Target(value = {public static final java.lang.annotation.ElementType TYPE_USE})", annotations[0].toString());
+			assertEquals("Annotation mismatch", "@Deprecated()", annotations[1].toString());
+		} finally {
+			removeLibrary(javaProject, jarName, srcName);
+		}
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=420320, [1.8] Bad AST recovery with type annotation and a syntax error in secondary type
+	public void testAnnotationRecovery() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"import java.util.List;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface NonNull {\n" +
+				"}\n" +
+				"public class X {\n" +
+				"	List<@NonNull String> list2;\n" +
+				"}\n" +
+				"class Y {\n" +
+				"    void bar()\n" +
+				"    void foo() { }\n" +
+				"}\n";
+		
+		String expected =
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"import java.util.List;\n" +
+				"@Target(ElementType.TYPE_USE) @interface NonNull {}\n" +
+				"public class X {\n" +
+				"  List<@NonNull String> list2;\n" +
+				"}\n" +
+				"class Y {\n" +
+				"  void bar(){\n" +
+				"  }\n" +
+				"  void foo(){\n" +
+				"  }\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy, false, true);
+		assertEquals("AST mismatch", expected, node.toString());
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=427337
+	public void testBug427337() throws CoreException, IOException {
+		String contents = 
+				"public class X implements I {\n" +
+				"}\n";
+
+		createFile("/Converter18/src/NonNull.java", 
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface NonNull {}");
+		createFile("/Converter18/src/I.java",
+				"import java.util.List;\n" +
+				"interface I { \n" +
+				"	String bar2(@NonNull String s, @NonNull List<@NonNull String> l2);\n" +
+				"}");
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy, false, true);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		TypeDeclaration type = (TypeDeclaration) ((CompilationUnit) node).types().get(0);
+		ITypeBinding binding = type.resolveBinding();
+		ITypeBinding superInterface = binding.getInterfaces()[0];
+		IMethodBinding method = superInterface.getDeclaredMethods()[0];
+		binding = method.getParameterTypes()[0];
+		assertEquals("Incorrect type binding", "@NonNull String", binding.toString());
+		binding = method.getParameterTypes()[1];
+		assertEquals("Incorrect type binding", "@NonNull List<@NonNull String>", binding.toString());
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=426515
+	public void testBug426515() throws CoreException {
+		try {
+			String contents =
+					"public class X {\n" +
+					"	void foo() {\n" +
+					"		Outer.getInner();\n" +
+					"	}\n" +
+					"}\n";
+
+			createFile("/Converter18/src/A.java",
+					"import java.lang.annotation.ElementType;\n" +
+					"import java.lang.annotation.Target;\n" +
+					"@Target(ElementType.TYPE_USE)\n" +
+					"@interface A { int value() default 0; \n }");
+			createFile("/Converter18/src/Outer.java",
+					"class Outer<T> { \n" +
+					"	public class Inner<I> {}\n" +
+					"	public static @A(1) Outer<java.lang.@A(2) String>.@A(3) Inner<java.lang.@A(4) Object> getInner() { \n" +
+					"		return null;\n" +
+					"	}\n" +
+					"}");
+
+			this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+			ASTNode node = buildAST(contents, this.workingCopy, false, true);
+			assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+			TypeDeclaration type = (TypeDeclaration) ((CompilationUnit) node).types().get(0);
+			MethodDeclaration method = type.getMethods()[0];
+			ExpressionStatement statement = (ExpressionStatement) method.getBody().statements().get(0);
+			MethodInvocation methodCal = (MethodInvocation) statement.getExpression();
+			ITypeBinding binding = methodCal.resolveTypeBinding();
+			assertEquals("Incorrect type binding", "@A((int)1) Outer<@A((int)2) String>.@A((int)3) Inner<@A((int)4) Object>", binding.toString());
+		} finally {
+			deleteFile("/Converter18/src/A.java");
+			deleteFile("/Converter18/src/Outer.java");
+		}
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425599, [1.8][compiler] ISE when trying to compile qualified and annotated class instance creation 
+	public void test425599() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.ElementType;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"public class X {\n" +
+				"    Object ax = new @A(1) Outer().new @A(2) Middle<@A(3) String>();\n" +
+				"}\n" +
+				"@Target(ElementType.TYPE_USE) @interface A { int value(); }\n" +
+				"class Outer {\n" +
+				"    class Middle<E> {}\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 3, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		FieldDeclaration[] fields = typeDecl.getFields();
+		assertEquals("Incorrect no of methods", 1, fields.length);
+		FieldDeclaration field = fields[0];
+		assertEquals("Object ax=new @A(1) Outer().new @A(2) Middle<@A(3) String>();\n", field.toString());
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425216, Bug 425216 - [1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated
+	public void test425216() throws CoreException, IOException {
+		String contents = 
+				"import static java.lang.annotation.ElementType.TYPE_USE;\n" +
+				"import java.lang.annotation.Target;\n" +
+				"@Target(TYPE_USE)\n" +
+				"@interface NonNull {}\n" +
+				"public class X {\n" +
+				"   X foo(@NonNull X this) {\n" +
+				"	   return this;\n" +
+				"   }\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration[] methods = typeDecl.getMethods();
+		assertEquals("Incorrect no of methods", 1, methods.length);
+		MethodDeclaration method = methods[0];
+		ReturnStatement statement = (ReturnStatement) method.getBody().statements().get(0);
+		ThisExpression expression = (ThisExpression) statement.getExpression();
+		ITypeBinding type = expression.resolveTypeBinding();
+		assertEquals("@NonNull X", type.toString());
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425216, Bug 425216 - [1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated
+	public void test425216a() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.*;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface A {\n" +
+				"    int value() default 0;\n" +
+				"}\n" +
+				"public class Outer {\n" +
+				"    class Middle {\n" +
+				"    	class Inner {\n" +
+				"    		public @A(1) Inner(@A(2) Outer.@A(3) Middle Middle.this) {\n" +
+				"    			Outer r1 = Outer.this;\n" +
+				"    			Outer.Middle middle = Outer.Middle.this;\n" +
+				"    			Inner i = this;\n" +
+				"    		}\n" +
+				"    	}\n" +
+				"    }\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/Outer.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method= typeDecl.getTypes()[0].getTypes()[0].getMethods()[0];
+		ITypeBinding receiverType = method.getReceiverType().resolveBinding();
+		assertEquals("@A((int)2) Outer.@A((int)3) Middle", receiverType.toString());
+		ITypeBinding declaringClass = receiverType.getDeclaringClass();
+		assertEquals("@A((int)2) Outer", declaringClass.toString());
+		final List statements = method.getBody().statements();
+		VariableDeclarationStatement statement = ((VariableDeclarationStatement) statements.get(0));
+		VariableDeclarationFragment fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		ITypeBinding type = fragment.getInitializer().resolveTypeBinding();
+		assertEquals("@A((int)2) Outer", type.toString());
+		statement = ((VariableDeclarationStatement) statements.get(1));
+		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		type = fragment.getInitializer().resolveTypeBinding();
+		assertEquals("@A((int)2) Outer.@A((int)3) Middle", type.toString());
+		assertEquals("@A((int)2) Outer", type.getDeclaringClass().toString());
+		statement = ((VariableDeclarationStatement) statements.get(2));
+		fragment = (VariableDeclarationFragment) statement.fragments().get(0);
+		type = fragment.getInitializer().resolveTypeBinding();
+		assertTrue(type.getTypeAnnotations().length == 0);
+		assertTrue(type.getName().equals("Inner"));
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=425216, Bug 425216 - [1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated
+	public void test425216b() throws CoreException, IOException {
+		String contents = 
+				"import java.lang.annotation.*;\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface A {\n" +
+				"    int value() default 0;\n" +
+				"}\n" +
+				"public class Outer {\n" +
+				"    class Middle {\n" +
+				"    	class Inner {\n" +
+				"    		public @A(1) Inner(@A(2) Outer.@A(3) Middle Middle.this) {\n" +
+				"    		}\n" +
+				"    	}\n" +
+				"    }\n" +
+				"}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/Outer.java", true);
+		ASTNode node = buildAST(contents, this.workingCopy);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		assertEquals("Incorrect no of types", 2, types.size());
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(1);
+		MethodDeclaration method= typeDecl.getTypes()[0].getTypes()[0].getMethods()[0];
+		SimpleName receiverQualifier = method.getReceiverQualifier();
+		ITypeBinding type = receiverQualifier.resolveTypeBinding();
+		assertEquals("@A((int)2) Outer.@A((int)3) Middle", type.toString());
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=427320
+	public void testBug427320() throws Exception {
+		try {
+			String contents = 
+					"public class X {\n" +
+					"	@A @B @C X() {}\n" +
+					"	@A @B @C String foo() {\nreturn null;\n}\n" +
+					"}\n" +
+					"@java.lang.annotation.Target ({java.lang.annotation.ElementType.CONSTRUCTOR, "
+													+ "java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.TYPE_USE})\n" +
+					"@interface A {}\n" +
+					"@java.lang.annotation.Target ({java.lang.annotation.ElementType.CONSTRUCTOR, "
+													+ "java.lang.annotation.ElementType.METHOD})\n" +
+					"@interface B {}\n" +
+					"@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)\n" +
+					"@interface C {}\n";
+		
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy, false);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+		List types = compilationUnit.types();
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(0);
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		assertTrue("Should be a constructor", method.isConstructor());
+		IMethodBinding methodBinding = method.resolveBinding();
+		IAnnotationBinding[] annots = methodBinding.getAnnotations();
+		assertEquals("Incorrect no of annotations", 2, annots.length);
+		assertEquals("Incorrect annotations attached","@A()", annots[0].toString());
+		assertEquals("Incorrect annotations attached","@B()", annots[1].toString());
+		ITypeBinding binding = methodBinding.getReturnType();
+		annots = binding.getTypeAnnotations();
+		assertEquals("Incorrect no of annotations", 0, annots.length);
+		
+		method = typeDecl.getMethods()[1];
+		methodBinding = method.resolveBinding();
+		annots = methodBinding.getAnnotations();
+		assertEquals("Incorrect no of annotations", 2, annots.length);
+		assertEquals("Incorrect annotations attached","@A()", annots[0].toString());
+		assertEquals("Incorrect annotations attached","@B()", annots[1].toString());
+		binding = methodBinding.getReturnType();
+		annots = binding.getTypeAnnotations();
+		assertEquals("Incorrect no of annotations", 2, annots.length);
+		assertEquals("Incorrect annotations attached","@A @C String", binding.toString());
+		} finally {
+			deleteFile("/Converter18/src/X.java");
+		}
+	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=431810
+	public void testBug431810() throws Exception {
+		try {
+			String contents =
+				"import java.lang.annotation.ElementType; \n" +
+				"import java.lang.annotation.Target; \n" +
+				"@interface A {}\n" +
+				"@Target(ElementType.TYPE_USE)\n" +
+				"@interface B {} \n" +
+				"class X {\n" +
+				"	@A \n" +
+				"	X() {}\n" +
+				"	@B \n" +
+				"	X(int x) {}\n" +
+				"}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy, false);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+		assertProblemsSize(compilationUnit, 0);
+
+		List types = compilationUnit.types();
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
+
+		// X()
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		assertTrue("Should be a constructor", method.isConstructor());
+		IMethodBinding methodBinding = method.resolveBinding();
+		IAnnotationBinding[] annots = methodBinding.getAnnotations();
+
+		assertEquals("Incorrect no of annotations", 1, annots.length);
+		assertEquals("Incorrect annotations attached","@A()", annots[0].toString());
+
+		// X(int)
+		method = typeDecl.getMethods()[1];
+		assertTrue("Should be a constructor", method.isConstructor());
+		methodBinding = method.resolveBinding();
+		annots = methodBinding.getAnnotations();
+
+		assertEquals("Incorrect no of annotations", 0, annots.length);
+		} finally {
+			deleteFile("/Converter18/src/X.java");
+		}
+	}
+
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=431810
+	// Incorrect use of annotations on constructors
+	public void testBug431810a() throws Exception {
+		try {
+			String contents =
+				"import java.lang.annotation.ElementType; \n" +
+				"import java.lang.annotation.Target; \n" +
+				"@Target({}) \n" +
+				"@interface A {} \n" +
+				"@Target(ElementType.TYPE)\n" +
+				"@interface B {} \n" +
+				"class X {\n" +
+				"	@A \n" +
+				"	X() {}\n" +
+				"	@B \n" +
+				"	X(int x) {}\n" +
+				"}\n";
+
+		this.workingCopy = getWorkingCopy("/Converter18/src/X.java", true/*resolve*/);
+		ASTNode node = buildAST(contents, this.workingCopy, false);
+		assertEquals("Not a compilation unit", ASTNode.COMPILATION_UNIT, node.getNodeType());
+		CompilationUnit compilationUnit = (CompilationUnit) node;
+
+		List types = compilationUnit.types();
+		TypeDeclaration typeDecl = (TypeDeclaration) types.get(2);
+
+		// X()
+		MethodDeclaration method = typeDecl.getMethods()[0];
+		assertTrue("Should be a constructor", method.isConstructor());
+		IMethodBinding methodBinding = method.resolveBinding();
+		IAnnotationBinding[] annots = methodBinding.getAnnotations();
+		assertEquals("Incorrect no of annotations", 0, annots.length);
+
+		// X(int)
+		method = typeDecl.getMethods()[1];
+		assertTrue("Should be a constructor", method.isConstructor());
+		methodBinding = method.resolveBinding();
+		annots = methodBinding.getAnnotations();
+		assertEquals("Incorrect no of annotations", 0, annots.length);
+		} finally {
+			deleteFile("/Converter18/src/X.java");
+		}
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
index 3c007c4..f5031ef 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterBugsTests.java
@@ -5986,7 +5986,7 @@ public void testBug304529e() {
 }
 
 /**
- * @bug 309706: [formatter] doesnt work when code has three semicolons side by side
+ * @bug 309706: [formatter] doesn't work when code has three semicolons side by side
  * @test Verify that formatter does get puzzled by three consecutive semicolons
  * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=309706"
  */
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
index 87b5a73..b65b282 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/formatter/FormatterRegressionTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8828,9 +8828,9 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 			"/**\r\n" + 
 			" * Mensagens SMTP tem o seguinte formato:\r\n" + 
 			" * <pre>\r\n" + 
-			" * resposta de uma linha s:\r\n" + 
+			" * resposta de uma linha s:\r\n" + 
 			" *  nnn [SP] lalalal [CR] [LF]\r\n" + 
-			" * resposta de vrias linhas:\r\n" + 
+			" * resposta de vrias linhas:\r\n" + 
 			" *  nnn [-] lalalalal [CR] [LF]\r\n" + 
 			" *  nnn [-] lalalalal [CR] [LF]\r\n" + 
 			" *  ...\r\n" + 
@@ -8842,9 +8842,9 @@ public class FormatterRegressionTests extends AbstractJavaModelTests {
 			" * Mensagens SMTP tem o seguinte formato:\n" + 
 			" * \n" + 
 			" * <pre>\n" + 
-			" * resposta de uma linha s:\n" + 
+			" * resposta de uma linha s:\n" + 
 			" *  nnn [SP] lalalal [CR] [LF]\n" + 
-			" * resposta de vrias linhas:\n" + 
+			" * resposta de vrias linhas:\n" + 
 			" *  nnn [-] lalalalal [CR] [LF]\n" + 
 			" *  nnn [-] lalalalal [CR] [LF]\n" + 
 			" *  ...\n" + 
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MatchingRegionsTest.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MatchingRegionsTest.java
index d6c5ca5..b00aef8 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MatchingRegionsTest.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/MatchingRegionsTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1506,14 +1506,14 @@ public void test0323() {
 // bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=271284
 public void test0324() {
 	String name = "IOException";
-	int[] regions = SearchPattern.getMatchingRegions("IO",  name, SearchPattern.R_CAMELCASE_MATCH);
+	int[] regions = SearchPattern.getMatchingRegions("IO",  name, SearchPattern.R_CAMELCASE_MATCH);
 	assertNull("Unexpected regions", regions);
 }
 public void test0325() {
-	String name = "IOExceptin";
-	int[] regions = SearchPattern.getMatchingRegions("IOExcepti",  name, SearchPattern.R_CAMELCASE_MATCH);
+	String name = "IOExceptin";
+	int[] regions = SearchPattern.getMatchingRegions("IOExcepti",  name, SearchPattern.R_CAMELCASE_MATCH);
 	assertEquals("Unexpected regions length", 2, regions.length);
-	assertEquals("Unexpected matching regions", "[IOExcepti]n", printRegions(name, regions));
+	assertEquals("Unexpected matching regions", "[IOExcepti]n", printRegions(name, regions));
 }
 
 }
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
index 9ae16f0..f87a3aa 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/NamingConventionTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2009 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -1181,13 +1181,13 @@ public void testSuggestGetterName007() {
 public void testSuggestGetterName008() {
 	char[] suggestion = NamingConventions.suggestGetterName(
 		this.project,
-		"field".toCharArray(), //$NON-NLS-1$
+		"field".toCharArray(), //$NON-NLS-1$
 		0,
 		false,
 		CharOperation.NO_CHAR_CHAR);
 
 	assumeEquals(
-		"getfield", //$NON-NLS-1$
+		"getfield", //$NON-NLS-1$
 		new String(suggestion));
 }
 public void testSuggestGetterName009() {
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_in.java
index 790a4ba..46e76d5 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_in.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_in.java
@@ -6,9 +6,9 @@ import uol.proxy.smtp.SmtpResponse;
 /**
  * Mensagens SMTP tem o seguinte formato:
  * <pre>
- * resposta de uma linha s:
+ * resposta de uma linha s:
  *  nnn [SP] lalalal [CR] [LF]
- * resposta de vrias linhas:
+ * resposta de vrias linhas:
  *  nnn [-] lalalalal [CR] [LF]
  *  nnn [-] lalalalal [CR] [LF]
  *  ...
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_out.java
index 2359bb7..f4a3c0d 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_out.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test607/A_out.java
@@ -7,9 +7,9 @@ import uol.proxy.smtp.SmtpResponse;
 /**
  * Mensagens SMTP tem o seguinte formato:
  * <pre>
- * resposta de uma linha s:
+ * resposta de uma linha s:
  *  nnn [SP] lalalal [CR] [LF]
- * resposta de vrias linhas:
+ * resposta de vrias linhas:
  *  nnn [-] lalalalal [CR] [LF]
  *  nnn [-] lalalalal [CR] [LF]
  *  ...
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_in.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_in.java
index d28e849..ebf8f08 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_in.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_in.java
@@ -1,9 +1,9 @@
 /**
  * Mensagens SMTP tem o seguinte formato:
  * <pre>
- * resposta de uma linha s:
+ * resposta de uma linha s:
  *  nnn [SP] lalalal [CR] [LF]
- * resposta de vrias linhas:
+ * resposta de vrias linhas:
  *  nnn [-] lalalalal [CR] [LF]
  *  nnn [-] lalalalal [CR] [LF]
  *  ...
diff --git a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_out.java b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_out.java
index 52218ac..f9f1066 100644
--- a/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_out.java
+++ b/org.eclipse.jdt.core.tests.model/workspace/Formatter/test608/A_out.java
@@ -2,9 +2,9 @@
  * Mensagens SMTP tem o seguinte formato:
  * 
  * <pre>
- *   resposta de uma linha s:
+ *   resposta de uma linha s:
  *    nnn [SP] lalalal [CR] [LF]
- *   resposta de vrias linhas:
+ *   resposta de vrias linhas:
  *    nnn [-] lalalalal [CR] [LF]
  *    nnn [-] lalalalal [CR] [LF]
  *    ...
diff --git a/org.eclipse.jdt.core.tests.performance/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.core.tests.performance/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.performance/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java b/org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java
index 645b085..6b7ea1f 100644
--- a/org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java
+++ b/org.eclipse.jdt.core.tests.performance/src/org/eclipse/jdt/core/tests/performance/FullSourceWorkspaceTests.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -787,7 +787,7 @@ public abstract class FullSourceWorkspaceTests extends TestCase {
 		super.stopMeasuring();
 		this.nbMeasures++;
 		long duration = System.currentTimeMillis() - this.startMeasuring;
-		if (PRINT) System.out.println("		- n "+this.nbMeasures+": "+duration+"ms");
+		if (PRINT) System.out.println("		- n "+this.nbMeasures+": "+duration+"ms");
 		this.testDuration += duration;
 	}
 	public void commitMeasurements() {
diff --git a/org.eclipse.jdt.core/.settings/org.eclipse.core.resources.prefs b/org.eclipse.jdt.core/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..796937c
--- /dev/null
+++ b/org.eclipse.jdt.core/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+encoding//scripts/ecj.1=ISO-8859-1
+encoding/<project>=UTF-8
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
index 8fa40f8..ea15617 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ParameterizedQualifiedTypeReference.java
@@ -11,7 +11,7 @@
  *								bug 342671 - ClassCastException: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding
  *								bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
  *								Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
- *								Bug 416181  [1.8][compiler][null] Invalid assignment is not rejected by the compiler
+ *								Bug 416181 - [1.8][compiler][null] Invalid assignment is not rejected by the compiler
  *								Bug 429958 - [1.8][null] evaluate new DefaultLocation attribute of @NonNullByDefault
  *								Bug 434600 - Incorrect null analysis error reporting on type parameters
  *        Andy Clement - Contributions for
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
index ab058a8..3567686 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InvocationSite.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -8,7 +8,7 @@
  * Contributors:
  *     IBM Corporation - initial API and implementation
  *     Stephan Herrmann - Contribution for
- *								bug 384380 - False positive on a  Potential null pointer access  after a continue
+ *								bug 384380 - False positive on a "Potential null pointer access" after a continue
  *								Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.lookup;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
index ab9cc05..37e178d 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodVerifier15.java
@@ -970,7 +970,7 @@ public boolean isMethodSubsignature(MethodBinding method, MethodBinding inherite
 boolean isUnsafeReturnTypeOverride(MethodBinding currentMethod, MethodBinding inheritedMethod) {
 	// called when currentMethod's return type is NOT compatible with inheritedMethod's return type
 
-	// JLS 3 8.4.5: more are accepted, with an unchecked conversion
+	// JLS 3 8.4.5: more are accepted, with an unchecked conversion
 	if (TypeBinding.equalsEquals(currentMethod.returnType, inheritedMethod.returnType.erasure())) {
 		TypeBinding[] currentParams = currentMethod.parameters;
 		TypeBinding[] inheritedParams = inheritedMethod.parameters;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
index 16f0a48..9e6ae03 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/parser/RecoveredElement.java
@@ -1,349 +1,349 @@
-/*******************************************************************************
- * Copyright (c) 2000, 2012 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- * 
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-
-package org.eclipse.jdt.internal.compiler.parser;
-
-/**
- * Internal structure for parsing recovery
- */
-import org.eclipse.jdt.internal.compiler.ast.ASTNode;
-import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.Block;
-import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.ImportReference;
-import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
-import org.eclipse.jdt.internal.compiler.ast.Statement;
-import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
-import org.eclipse.jdt.internal.compiler.util.Util;
-
-public class RecoveredElement {
-
-	public RecoveredElement parent;
-	public int bracketBalance;
-	public boolean foundOpeningBrace;
-	protected Parser recoveringParser;
-public RecoveredElement(RecoveredElement parent, int bracketBalance){
-	this(parent, bracketBalance, null);
-}
-public RecoveredElement(RecoveredElement parent, int bracketBalance, Parser parser){
-	this.parent = parent;
-	this.bracketBalance = bracketBalance;
-	this.recoveringParser = parser;
-}
-public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(annotationStart - 1));
-	return this.parent.addAnnotationName(identifierPtr, identifierLengthPtr, annotationStart, bracketBalanceValue);
-}
-/*
- *	Record a method declaration
- */
-public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bracketBalanceValue) {
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(methodDeclaration.declarationSourceStart - 1));
-	return this.parent.add(methodDeclaration, bracketBalanceValue);
-}
-/*
- * Record a nested block declaration
- */
-public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValue) {
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(nestedBlockDeclaration.sourceStart - 1));
-	return this.parent.add(nestedBlockDeclaration, bracketBalanceValue);
-}
-/*
- * Record a field declaration
- */
-public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanceValue) {
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(fieldDeclaration.declarationSourceStart - 1));
-	return this.parent.add(fieldDeclaration, bracketBalanceValue);
-}
-/*
- *	Record an import reference
- */
-public RecoveredElement add(ImportReference importReference, int bracketBalanceValue){
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(importReference.declarationSourceStart - 1));
-	return this.parent.add(importReference, bracketBalanceValue);
-}
-/*
- * Record a local declaration
- */
-public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanceValue) {
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(localDeclaration.declarationSourceStart - 1));
-	return this.parent.add(localDeclaration, bracketBalanceValue);
-}
-/*
- * Record a statement
- */
-public RecoveredElement add(Statement statement, int bracketBalanceValue) {
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	if (this instanceof RecoveredType) {
-		TypeDeclaration typeDeclaration = ((RecoveredType) this).typeDeclaration;
-		if (typeDeclaration != null && (typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) { 
-			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=291040, new X(<SelectOnMessageSend:zoo()>) { ???
-			if (statement.sourceStart > typeDeclaration.sourceStart && statement.sourceEnd < typeDeclaration.sourceEnd) {
-				return this;
-			}
-		}
-	}
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(statement.sourceStart - 1));
-	return this.parent.add(statement, bracketBalanceValue);
-}
-/*
- *	Record a type declaration
- */
-public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue){
-
-	/* default behavior is to delegate recording to parent if any */
-	resetPendingModifiers();
-	if (this.parent == null) return this; // ignore
-	this.updateSourceEndIfNecessary(previousAvailableLineEnd(typeDeclaration.declarationSourceStart - 1));
-	return this.parent.add(typeDeclaration, bracketBalanceValue);
-}
-protected void addBlockStatement(RecoveredBlock recoveredBlock) {
-	Block block = recoveredBlock.blockDeclaration;
-	if(block.statements != null) {
-		Statement[] statements = block.statements;
-		for (int i = 0; i < statements.length; i++) {
-			recoveredBlock.add(statements[i], 0);
-		}
-	}
-}
-public void addModifier(int flag, int modifiersSourceStart) {
-	// default implementation: do nothing
-}
-/*
- * Answer the depth of this element, considering the parent link.
- */
-public int depth(){
-	int depth = 0;
-	RecoveredElement current = this;
-	while ((current = current.parent) != null) depth++;
-	return depth;
-}
-/*
- * Answer the enclosing method node, or null if none
- */
-public RecoveredInitializer enclosingInitializer(){
-	RecoveredElement current = this;
-	while (current != null){
-		if (current instanceof RecoveredInitializer){
-			return (RecoveredInitializer) current;
-		}
-		current = current.parent;
-	}
-	return null;
-}
-/*
- * Answer the enclosing method node, or null if none
- */
-public RecoveredMethod enclosingMethod(){
-	RecoveredElement current = this;
-	while (current != null){
-		if (current instanceof RecoveredMethod){
-			return (RecoveredMethod) current;
-		}
-		current = current.parent;
-	}
-	return null;
-}
-/*
- * Answer the enclosing type node, or null if none
- */
-public RecoveredType enclosingType(){
-	RecoveredElement current = this;
-	while (current != null){
-		if (current instanceof RecoveredType){
-			return (RecoveredType) current;
-		}
-		current = current.parent;
-	}
-	return null;
-}
-/*
- * Answer the closest specified parser
- */
-public Parser parser(){
-	RecoveredElement current = this;
-	while (current != null){
-		if (current.recoveringParser != null){
-			return current.recoveringParser;
-		}
-		current = current.parent;
-	}
-	return null;
-}
-/*
- * Answer the associated parsed structure
- */
-public ASTNode parseTree(){
-	return null;
-}
-public void resetPendingModifiers() {
-	// default implementation: do nothing
-	// recovered elements which have pending modifiers must override this method
-}
-/*
- * Iterate the enclosing blocks and tag them so as to preserve their content
- */
-public void preserveEnclosingBlocks(){
-	RecoveredElement current = this;
-	while (current != null){
-		if (current instanceof RecoveredBlock){
-			((RecoveredBlock)current).preserveContent = true;
-		}
-		if (current instanceof RecoveredType){ // for anonymous types
-			((RecoveredType)current).preserveContent = true;
-		}
-		current = current.parent;
-	}
-}
-/*
- * Answer the position of the previous line end if
- * there is nothing but spaces in between it and the
- * line end. Used to trim spaces on unclosed elements.
- */
-public int previousAvailableLineEnd(int position){
-
-	Parser parser = parser();
-	if (parser == null) return position;
-
-	Scanner scanner = parser.scanner;
-	if (scanner.lineEnds == null) return position;
-
-	int index = Util.getLineNumber(position, scanner.lineEnds, 0, scanner.linePtr);
-	if (index < 2) return position;
-	int previousLineEnd = scanner.lineEnds[index-2];
-
-	char[] source = scanner.source;
-	for (int i = previousLineEnd+1; i < position; i++){
-		if (!(source[i] == ' ' || source[i] == '\t')) return position;
-	}
-	return previousLineEnd;
-}
-/*
- * Answer the very source end of the corresponding parse node
- */
-public int sourceEnd(){
-	return 0;
-}
-protected String tabString(int tab) {
-	StringBuffer result = new StringBuffer();
-	for (int i = tab; i > 0; i--) {
-		result.append("  "); //$NON-NLS-1$
-	}
-	return result.toString();
-}
-/*
- * Answer the top node
- */
-public RecoveredElement topElement(){
-	RecoveredElement current = this;
-	while (current.parent != null){
-		current = current.parent;
-	}
-	return current;
-}
-public String toString() {
-	return toString(0);
-}
-public String toString(int tab) {
-	return super.toString();
-}
-/*
- * Answer the enclosing type node, or null if none
- */
-public RecoveredType type(){
-	RecoveredElement current = this;
-	while (current != null){
-		if (current instanceof RecoveredType){
-			return (RecoveredType) current;
-		}
-		current = current.parent;
-	}
-	return null;
-}
-/*
- * Update the bodyStart of the corresponding parse node
- */
-public void updateBodyStart(int bodyStart){
-	this.foundOpeningBrace = true;
-}
-/*
- * Update the corresponding parse node from parser state which
- * is about to disappear because of restarting recovery
- */
-public void updateFromParserState(){
-	// default implementation: do nothing
-}
-/*
- * A closing brace got consumed, might have closed the current element,
- * in which case both the currentElement is exited
- */
-public RecoveredElement updateOnClosingBrace(int braceStart, int braceEnd){
-	if ((--this.bracketBalance <= 0) && (this.parent != null)){
-		this.updateSourceEndIfNecessary(braceStart, braceEnd);
-		return this.parent;
-	}
-	return this;
-}
-/*
- * An opening brace got consumed, might be the expected opening one of the current element,
- * in which case the bodyStart is updated.
- */
-/*public RecoveredElement updateOnOpeningBrace(int braceEnd){return null;}*/
-public RecoveredElement updateOnOpeningBrace(int braceStart, int braceEnd){
-
-	if (this.bracketBalance++ == 0){
-		updateBodyStart(braceEnd + 1);
-		return this;
-	}
-	return null; // no update is necessary
-}
-/*
- * Final update the corresponding parse node
- */
-public void updateParseTree(){
-	// default implementation: do nothing
-}
-/*
- * Update the declarationSourceEnd of the corresponding parse node
- */
-public void updateSourceEndIfNecessary(int braceStart, int braceEnd){
-	// default implementation: do nothing
-}
-public void updateSourceEndIfNecessary(int sourceEnd){
-	this.updateSourceEndIfNecessary(sourceEnd + 1, sourceEnd);
-}
-}
+/*******************************************************************************
+ * Copyright (c) 2000, 2012 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+
+package org.eclipse.jdt.internal.compiler.parser;
+
+/**
+ * Internal structure for parsing recovery
+ */
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Block;
+import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.ImportReference;
+import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.Statement;
+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;
+import org.eclipse.jdt.internal.compiler.util.Util;
+
+public class RecoveredElement {
+
+	public RecoveredElement parent;
+	public int bracketBalance;
+	public boolean foundOpeningBrace;
+	protected Parser recoveringParser;
+public RecoveredElement(RecoveredElement parent, int bracketBalance){
+	this(parent, bracketBalance, null);
+}
+public RecoveredElement(RecoveredElement parent, int bracketBalance, Parser parser){
+	this.parent = parent;
+	this.bracketBalance = bracketBalance;
+	this.recoveringParser = parser;
+}
+public RecoveredElement addAnnotationName(int identifierPtr, int identifierLengthPtr, int annotationStart, int bracketBalanceValue) {
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(annotationStart - 1));
+	return this.parent.addAnnotationName(identifierPtr, identifierLengthPtr, annotationStart, bracketBalanceValue);
+}
+/*
+ *	Record a method declaration
+ */
+public RecoveredElement add(AbstractMethodDeclaration methodDeclaration, int bracketBalanceValue) {
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(methodDeclaration.declarationSourceStart - 1));
+	return this.parent.add(methodDeclaration, bracketBalanceValue);
+}
+/*
+ * Record a nested block declaration
+ */
+public RecoveredElement add(Block nestedBlockDeclaration, int bracketBalanceValue) {
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(nestedBlockDeclaration.sourceStart - 1));
+	return this.parent.add(nestedBlockDeclaration, bracketBalanceValue);
+}
+/*
+ * Record a field declaration
+ */
+public RecoveredElement add(FieldDeclaration fieldDeclaration, int bracketBalanceValue) {
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(fieldDeclaration.declarationSourceStart - 1));
+	return this.parent.add(fieldDeclaration, bracketBalanceValue);
+}
+/*
+ *	Record an import reference
+ */
+public RecoveredElement add(ImportReference importReference, int bracketBalanceValue){
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(importReference.declarationSourceStart - 1));
+	return this.parent.add(importReference, bracketBalanceValue);
+}
+/*
+ * Record a local declaration
+ */
+public RecoveredElement add(LocalDeclaration localDeclaration, int bracketBalanceValue) {
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(localDeclaration.declarationSourceStart - 1));
+	return this.parent.add(localDeclaration, bracketBalanceValue);
+}
+/*
+ * Record a statement
+ */
+public RecoveredElement add(Statement statement, int bracketBalanceValue) {
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	if (this instanceof RecoveredType) {
+		TypeDeclaration typeDeclaration = ((RecoveredType) this).typeDeclaration;
+		if (typeDeclaration != null && (typeDeclaration.bits & ASTNode.IsAnonymousType) != 0) { 
+			// https://bugs.eclipse.org/bugs/show_bug.cgi?id=291040, new X(<SelectOnMessageSend:zoo()>) { ???
+			if (statement.sourceStart > typeDeclaration.sourceStart && statement.sourceEnd < typeDeclaration.sourceEnd) {
+				return this;
+			}
+		}
+	}
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(statement.sourceStart - 1));
+	return this.parent.add(statement, bracketBalanceValue);
+}
+/*
+ *	Record a type declaration
+ */
+public RecoveredElement add(TypeDeclaration typeDeclaration, int bracketBalanceValue){
+
+	/* default behavior is to delegate recording to parent if any */
+	resetPendingModifiers();
+	if (this.parent == null) return this; // ignore
+	this.updateSourceEndIfNecessary(previousAvailableLineEnd(typeDeclaration.declarationSourceStart - 1));
+	return this.parent.add(typeDeclaration, bracketBalanceValue);
+}
+protected void addBlockStatement(RecoveredBlock recoveredBlock) {
+	Block block = recoveredBlock.blockDeclaration;
+	if(block.statements != null) {
+		Statement[] statements = block.statements;
+		for (int i = 0; i < statements.length; i++) {
+			recoveredBlock.add(statements[i], 0);
+		}
+	}
+}
+public void addModifier(int flag, int modifiersSourceStart) {
+	// default implementation: do nothing
+}
+/*
+ * Answer the depth of this element, considering the parent link.
+ */
+public int depth(){
+	int depth = 0;
+	RecoveredElement current = this;
+	while ((current = current.parent) != null) depth++;
+	return depth;
+}
+/*
+ * Answer the enclosing method node, or null if none
+ */
+public RecoveredInitializer enclosingInitializer(){
+	RecoveredElement current = this;
+	while (current != null){
+		if (current instanceof RecoveredInitializer){
+			return (RecoveredInitializer) current;
+		}
+		current = current.parent;
+	}
+	return null;
+}
+/*
+ * Answer the enclosing method node, or null if none
+ */
+public RecoveredMethod enclosingMethod(){
+	RecoveredElement current = this;
+	while (current != null){
+		if (current instanceof RecoveredMethod){
+			return (RecoveredMethod) current;
+		}
+		current = current.parent;
+	}
+	return null;
+}
+/*
+ * Answer the enclosing type node, or null if none
+ */
+public RecoveredType enclosingType(){
+	RecoveredElement current = this;
+	while (current != null){
+		if (current instanceof RecoveredType){
+			return (RecoveredType) current;
+		}
+		current = current.parent;
+	}
+	return null;
+}
+/*
+ * Answer the closest specified parser
+ */
+public Parser parser(){
+	RecoveredElement current = this;
+	while (current != null){
+		if (current.recoveringParser != null){
+			return current.recoveringParser;
+		}
+		current = current.parent;
+	}
+	return null;
+}
+/*
+ * Answer the associated parsed structure
+ */
+public ASTNode parseTree(){
+	return null;
+}
+public void resetPendingModifiers() {
+	// default implementation: do nothing
+	// recovered elements which have pending modifiers must override this method
+}
+/*
+ * Iterate the enclosing blocks and tag them so as to preserve their content
+ */
+public void preserveEnclosingBlocks(){
+	RecoveredElement current = this;
+	while (current != null){
+		if (current instanceof RecoveredBlock){
+			((RecoveredBlock)current).preserveContent = true;
+		}
+		if (current instanceof RecoveredType){ // for anonymous types
+			((RecoveredType)current).preserveContent = true;
+		}
+		current = current.parent;
+	}
+}
+/*
+ * Answer the position of the previous line end if
+ * there is nothing but spaces in between it and the
+ * line end. Used to trim spaces on unclosed elements.
+ */
+public int previousAvailableLineEnd(int position){
+
+	Parser parser = parser();
+	if (parser == null) return position;
+
+	Scanner scanner = parser.scanner;
+	if (scanner.lineEnds == null) return position;
+
+	int index = Util.getLineNumber(position, scanner.lineEnds, 0, scanner.linePtr);
+	if (index < 2) return position;
+	int previousLineEnd = scanner.lineEnds[index-2];
+
+	char[] source = scanner.source;
+	for (int i = previousLineEnd+1; i < position; i++){
+		if (!(source[i] == ' ' || source[i] == '\t')) return position;
+	}
+	return previousLineEnd;
+}
+/*
+ * Answer the very source end of the corresponding parse node
+ */
+public int sourceEnd(){
+	return 0;
+}
+protected String tabString(int tab) {
+	StringBuffer result = new StringBuffer();
+	for (int i = tab; i > 0; i--) {
+		result.append("  "); //$NON-NLS-1$
+	}
+	return result.toString();
+}
+/*
+ * Answer the top node
+ */
+public RecoveredElement topElement(){
+	RecoveredElement current = this;
+	while (current.parent != null){
+		current = current.parent;
+	}
+	return current;
+}
+public String toString() {
+	return toString(0);
+}
+public String toString(int tab) {
+	return super.toString();
+}
+/*
+ * Answer the enclosing type node, or null if none
+ */
+public RecoveredType type(){
+	RecoveredElement current = this;
+	while (current != null){
+		if (current instanceof RecoveredType){
+			return (RecoveredType) current;
+		}
+		current = current.parent;
+	}
+	return null;
+}
+/*
+ * Update the bodyStart of the corresponding parse node
+ */
+public void updateBodyStart(int bodyStart){
+	this.foundOpeningBrace = true;
+}
+/*
+ * Update the corresponding parse node from parser state which
+ * is about to disappear because of restarting recovery
+ */
+public void updateFromParserState(){
+	// default implementation: do nothing
+}
+/*
+ * A closing brace got consumed, might have closed the current element,
+ * in which case both the currentElement is exited
+ */
+public RecoveredElement updateOnClosingBrace(int braceStart, int braceEnd){
+	if ((--this.bracketBalance <= 0) && (this.parent != null)){
+		this.updateSourceEndIfNecessary(braceStart, braceEnd);
+		return this.parent;
+	}
+	return this;
+}
+/*
+ * An opening brace got consumed, might be the expected opening one of the current element,
+ * in which case the bodyStart is updated.
+ */
+/*public RecoveredElement updateOnOpeningBrace(int braceEnd){return null;}*/
+public RecoveredElement updateOnOpeningBrace(int braceStart, int braceEnd){
+
+	if (this.bracketBalance++ == 0){
+		updateBodyStart(braceEnd + 1);
+		return this;
+	}
+	return null; // no update is necessary
+}
+/*
+ * Final update the corresponding parse node
+ */
+public void updateParseTree(){
+	// default implementation: do nothing
+}
+/*
+ * Update the declarationSourceEnd of the corresponding parse node
+ */
+public void updateSourceEndIfNecessary(int braceStart, int braceEnd){
+	// default implementation: do nothing
+}
+public void updateSourceEndIfNecessary(int sourceEnd){
+	this.updateSourceEndIfNecessary(sourceEnd + 1, sourceEnd);
+}
+}
diff --git a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
index f13a31b..08190fa 100644
--- a/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
+++ b/org.eclipse.jdt.core/dom/org/eclipse/jdt/internal/core/dom/SourceRangeVerifier.java
@@ -1,114 +1,114 @@
-/*******************************************************************************
- * Copyright (c) 2013 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.core.dom;
-
-import java.util.List;
-
-import org.eclipse.jdt.core.dom.ASTNode;
-import org.eclipse.jdt.core.dom.ASTParser;
-import org.eclipse.jdt.core.dom.ASTVisitor;
-import org.eclipse.jdt.core.dom.ArrayCreation;
-import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
-
-@SuppressWarnings("rawtypes")
-public class SourceRangeVerifier extends ASTVisitor {
-
-	public static boolean DEBUG = false;
-	public static boolean DEBUG_THROW = false;
-	
-	private StringBuffer bugs; 
-	
-	/**
-	 * Verifies proper node nesting as specified in {@link ASTParser#setKind(int)}:
-	 * <p>
-	 * Source ranges nest properly: the source range for a child is always
-	 * within the source range of its parent, and the source ranges of sibling
-	 * nodes never overlap.
-	 * </p>
-	 * 
-	 * @param node
-	 * @return <code>null</code> if everything is OK; a list of errors otherwise
-	 */
-	public String process(ASTNode node) {
-		StringBuffer buffer = new StringBuffer();
-		this.bugs = buffer;
-		node.accept(this);
-		this.bugs = null;
-		if (buffer.length() == 0)
-			return null;
-		return buffer.toString();
-	}
-	
-	public boolean preVisit2(ASTNode node) {
-		ASTNode previous = null;
-		
-		List properties = node.structuralPropertiesForType();
-		for (int i = 0; i < properties.size(); i++) {
-			StructuralPropertyDescriptor property = (StructuralPropertyDescriptor) properties.get(i);
-			if (property.isChildProperty()) {
-				ASTNode child = (ASTNode) node.getStructuralProperty(property);
-				if (child != null) {
-					boolean ok = checkChild(node, previous, child);
-					if (ok) {
-						previous = child;
-					} else {
-						return false;
-					}
-				}
-			} else if (property.isChildListProperty()) {
-				List children = (List) node.getStructuralProperty(property);
-				for (int j= 0; j < children.size(); j++) {
-					ASTNode child = (ASTNode) children.get(j);
-					boolean ok = checkChild(node, previous, child);
-					if (ok) {
-						previous = child;
-					} else {
-						return false;
-					}
-				}
-			}
-		}
-		return true;
-	}
-
-	private boolean checkChild(ASTNode parent, ASTNode previous, ASTNode child) {
-		if ((parent.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0
-				|| (child.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0)
-			return false; 
-		
-		int parentStart = parent.getStartPosition();
-		int parentEnd = parentStart + parent.getLength();
-		
-		int childStart = child.getStartPosition();
-		int childEnd = childStart + child.getLength();
-		
-		if (previous != null) {
-			// Turn a blind eye on a known problem ... see https://bugs.eclipse.org/391894#c4
-			if (child.getLocationInParent() == ArrayCreation.DIMENSIONS_PROPERTY)
-				return false;
-			
-			int previousStart = previous.getStartPosition();
-			int previousEnd = previousStart + previous.getLength();
-			if (childStart < previousEnd) {
-				String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-						+ "   previous [" + previousStart + ", " + previousEnd + "] "  + previous.getClass().getName() + '\n'//$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-						+ "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
-				this.bugs.append(bug);
-			}
-		}
-		if (!(parentStart <= childStart && childEnd <= parentEnd)) {
-			String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
-					   + "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
-			this.bugs.append(bug);
-		}
-		return true;
-	}
-}
+/*******************************************************************************
+ * Copyright (c) 2013 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.core.dom;
+
+import java.util.List;
+
+import org.eclipse.jdt.core.dom.ASTNode;
+import org.eclipse.jdt.core.dom.ASTParser;
+import org.eclipse.jdt.core.dom.ASTVisitor;
+import org.eclipse.jdt.core.dom.ArrayCreation;
+import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
+
+@SuppressWarnings("rawtypes")
+public class SourceRangeVerifier extends ASTVisitor {
+
+	public static boolean DEBUG = false;
+	public static boolean DEBUG_THROW = false;
+	
+	private StringBuffer bugs; 
+	
+	/**
+	 * Verifies proper node nesting as specified in {@link ASTParser#setKind(int)}:
+	 * <p>
+	 * Source ranges nest properly: the source range for a child is always
+	 * within the source range of its parent, and the source ranges of sibling
+	 * nodes never overlap.
+	 * </p>
+	 * 
+	 * @param node
+	 * @return <code>null</code> if everything is OK; a list of errors otherwise
+	 */
+	public String process(ASTNode node) {
+		StringBuffer buffer = new StringBuffer();
+		this.bugs = buffer;
+		node.accept(this);
+		this.bugs = null;
+		if (buffer.length() == 0)
+			return null;
+		return buffer.toString();
+	}
+	
+	public boolean preVisit2(ASTNode node) {
+		ASTNode previous = null;
+		
+		List properties = node.structuralPropertiesForType();
+		for (int i = 0; i < properties.size(); i++) {
+			StructuralPropertyDescriptor property = (StructuralPropertyDescriptor) properties.get(i);
+			if (property.isChildProperty()) {
+				ASTNode child = (ASTNode) node.getStructuralProperty(property);
+				if (child != null) {
+					boolean ok = checkChild(node, previous, child);
+					if (ok) {
+						previous = child;
+					} else {
+						return false;
+					}
+				}
+			} else if (property.isChildListProperty()) {
+				List children = (List) node.getStructuralProperty(property);
+				for (int j= 0; j < children.size(); j++) {
+					ASTNode child = (ASTNode) children.get(j);
+					boolean ok = checkChild(node, previous, child);
+					if (ok) {
+						previous = child;
+					} else {
+						return false;
+					}
+				}
+			}
+		}
+		return true;
+	}
+
+	private boolean checkChild(ASTNode parent, ASTNode previous, ASTNode child) {
+		if ((parent.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0
+				|| (child.getFlags() & (ASTNode.RECOVERED | ASTNode.MALFORMED)) != 0)
+			return false; 
+		
+		int parentStart = parent.getStartPosition();
+		int parentEnd = parentStart + parent.getLength();
+		
+		int childStart = child.getStartPosition();
+		int childEnd = childStart + child.getLength();
+		
+		if (previous != null) {
+			// Turn a blind eye on a known problem ... see https://bugs.eclipse.org/391894#c4
+			if (child.getLocationInParent() == ArrayCreation.DIMENSIONS_PROPERTY)
+				return false;
+			
+			int previousStart = previous.getStartPosition();
+			int previousEnd = previousStart + previous.getLength();
+			if (childStart < previousEnd) {
+				String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+						+ "   previous [" + previousStart + ", " + previousEnd + "] "  + previous.getClass().getName() + '\n'//$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+						+ "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+				this.bugs.append(bug);
+			}
+		}
+		if (!(parentStart <= childStart && childEnd <= parentEnd)) {
+			String bug = "- parent [" + parentStart + ", " + parentEnd + "] " + parent.getClass().getName() + '\n' //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
+					   + "   " + child.getLocationInParent().getId() + " [" + childStart + ", " + childEnd + "] " + child.getClass().getName() + '\n'; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
+			this.bugs.append(bug);
+		}
+		return true;
+	}
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IConstantPoolEntry2.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IConstantPoolEntry2.java
index 3b4984b..c7c8674 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IConstantPoolEntry2.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/core/util/IConstantPoolEntry2.java
@@ -1,59 +1,59 @@
-/*******************************************************************************
- * Copyright (c) 2011 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.core.util;
-
-/**
- * Description of the new constant pool entry as described in the JVM specifications
- * added for Java 7 support.
- * Its contents is initialized according to its kind.
- *
- * This interface may be implemented by clients.
- *
- * @since 3.8
- */
-public interface IConstantPoolEntry2 extends IConstantPoolEntry {
-	/**
-	 * Returns the descriptor index. This value is set only when decoding a MethodType entry.
-	 * The value is unspecified otherwise. The corresponding UTF8 value can be retrieved by using
-	 * {@link #getMethodDescriptor()}.
-	 *
-	 * @return the descriptor index. This value is set only when decoding a MethodType entry.
-	 * @see IConstantPoolConstant#CONSTANT_MethodType
-	 */
-	int getDescriptorIndex();
-
-	/**
-	 * Returns the reference kind. This value is set only when decoding a MethodHandle entry.
-	 * The value is unspecified otherwise.
-	 *
-	 * @return the reference kind. This value is set only when decoding a MethodHandle entry.
-	 * @see IConstantPoolConstant#CONSTANT_MethodHandle
-	 */
-	int getReferenceKind();
-
-	/**
-	 * Returns the reference index. This value is set only when decoding a MethodHandle entry.
-	 * The value is unspecified otherwise.
-	 *
-	 * @return the reference kind. This value is set only when decoding a MethodHandle entry.
-	 * @see IConstantPoolConstant#CONSTANT_MethodHandle
-	 */
-	int getReferenceIndex();
-	
-	/**
-	 * Returns the bootstrap method attribute index. This value is set only when decoding a InvokeDynamic entry.
-	 * The value is unspecified otherwise.
-	 *
-	 * @return the reference kind. This value is set only when decoding a MethodHandle entry.
-	 * @see IConstantPoolConstant#CONSTANT_InvokeDynamic
-	 */
-	int getBootstrapMethodAttributeIndex();
-}
+/*******************************************************************************
+ * Copyright (c) 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.util;
+
+/**
+ * Description of the new constant pool entry as described in the JVM specifications
+ * added for Java 7 support.
+ * Its contents is initialized according to its kind.
+ *
+ * This interface may be implemented by clients.
+ *
+ * @since 3.8
+ */
+public interface IConstantPoolEntry2 extends IConstantPoolEntry {
+	/**
+	 * Returns the descriptor index. This value is set only when decoding a MethodType entry.
+	 * The value is unspecified otherwise. The corresponding UTF8 value can be retrieved by using
+	 * {@link #getMethodDescriptor()}.
+	 *
+	 * @return the descriptor index. This value is set only when decoding a MethodType entry.
+	 * @see IConstantPoolConstant#CONSTANT_MethodType
+	 */
+	int getDescriptorIndex();
+
+	/**
+	 * Returns the reference kind. This value is set only when decoding a MethodHandle entry.
+	 * The value is unspecified otherwise.
+	 *
+	 * @return the reference kind. This value is set only when decoding a MethodHandle entry.
+	 * @see IConstantPoolConstant#CONSTANT_MethodHandle
+	 */
+	int getReferenceKind();
+
+	/**
+	 * Returns the reference index. This value is set only when decoding a MethodHandle entry.
+	 * The value is unspecified otherwise.
+	 *
+	 * @return the reference kind. This value is set only when decoding a MethodHandle entry.
+	 * @see IConstantPoolConstant#CONSTANT_MethodHandle
+	 */
+	int getReferenceIndex();
+	
+	/**
+	 * Returns the bootstrap method attribute index. This value is set only when decoding a InvokeDynamic entry.
+	 * The value is unspecified otherwise.
+	 *
+	 * @return the reference kind. This value is set only when decoding a MethodHandle entry.
+	 * @see IConstantPoolConstant#CONSTANT_InvokeDynamic
+	 */
+	int getBootstrapMethodAttributeIndex();
+}
diff --git a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
index ac28594..5db5a38 100644
--- a/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
+++ b/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/Disassembler.java
@@ -1575,14 +1575,14 @@ public class Disassembler extends ClassFileBytesDisassembler {
 	private String bootstrapMethodDescription(IBootstrapMethodsEntry entry, IConstantPool constantPool) {
 		// http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html
 		// The BootstrapMethods attribute records bootstrap method specifiers referenced by invokedynamic instructions.
-		// The value of the bootstrap_method_ref item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a CONSTANT_MethodHandle_info structure (4.4.8).
+		// The value of the bootstrap_method_ref item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a CONSTANT_MethodHandle_info structure (4.4.8).
 		// http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8
 		// constantpoolentry.getKind() = IConstantPoolConstant.CONSTANT_MethodHandle
 
 		ConstantPoolEntry2 constantPoolEntry2 =  (ConstantPoolEntry2) constantPool.decodeEntry(entry.getBootstrapMethodReference());
 
 		// The reference_kind item of the CONSTANT_MethodHandle_info structure should have the value 6 (REF_invokeStatic) or 8 (REF_newInvokeSpecial)
-		// (5.4.3.5) or else invocation of the bootstrap method handle during call site specifier resolution for an invokedynamic instruction will complete abruptly.
+		// (5.4.3.5) or else invocation of the bootstrap method handle during call site specifier resolution for an invokedynamic instruction will complete abruptly.
 		// If the value of the reference_kind item is 5 (REF_invokeVirtual), 6 (REF_invokeStatic), 7 (REF_invokeSpecial),
 		// or 9 (REF_invokeInterface), the name of the method represented by a CONSTANT_Methodref_info structure must not be <init> or <clinit>.
 
@@ -1601,7 +1601,7 @@ public class Disassembler extends ClassFileBytesDisassembler {
 		// 	    Each entry in the bootstrap_arguments array must be a valid index into the constant_pool table.
 		//      The constant_pool entry at that index must be a CONSTANT_String_info, CONSTANT_Class_info, CONSTANT_Integer_info
 		//      CONSTANT_Long_info, CONSTANT_Float_info, CONSTANT_Double_info, CONSTANT_MethodHandle_info, or
-		//      CONSTANT_MethodType_info structure (4.4.3, 4.4.1, 4.4.4, 4.4.5), 4.4.8, 4.4.9).
+		//      CONSTANT_MethodType_info structure (4.4.3, 4.4.1, 4.4.4, 4.4.5), 4.4.8, 4.4.9).
 		if (entry.getBootstrapArguments().length == 0)
 			return null;
 		int[] bootstrapArguments = entry.getBootstrapArguments();
@@ -1616,8 +1616,8 @@ public class Disassembler extends ClassFileBytesDisassembler {
 					// http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8
 					// If the value of the reference_kind item is 5 (REF_invokeVirtual), 6 (REF_invokeStatic),
 					// 7 (REF_invokeSpecial), or 8 (REF_newInvokeSpecial), then the constant_pool entry at that
-					// index must be a CONSTANT_Methodref_info structure (4.4.2) representing a class's method or
-					// constructor (2.9) for which a method handle is to be created.
+					// index must be a CONSTANT_Methodref_info structure (4.4.2) representing a class's method or
+					// constructor (2.9) for which a method handle is to be created.
 					ConstantPoolEntry2 constantPoolEntry2 = (ConstantPoolEntry2) constantPoolEntry;
 					StringBuilder builder = new StringBuilder(10);
 					switch(constantPoolEntry2.getReferenceKind()) {
