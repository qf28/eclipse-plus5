commit 2156fedddc9b679afe1f45ef1e9d318ac4df4d9a
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sun Oct 5 12:14:29 2014 +0530

    Prepatory work for Bug 437444 - [1.8][compiler] Evaluate alternate
    integration between overload resolution and type inference

5	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
86	0	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
1	3	org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter17Test.java
5	5	org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
17	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
1	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
17	17	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java
18	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java
3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
21	18	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
10	10	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
18	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java
2	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
14	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemMethodBinding.java
1	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
32	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
8	14	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
58	63	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
index 04b89ee..d039720 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/AbstractRegressionTest.java
@@ -72,6 +72,7 @@ import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
 import org.eclipse.jdt.internal.core.search.JavaSearchParticipant;
 import org.eclipse.jdt.internal.core.search.indexing.BinaryIndexer;
 import org.osgi.framework.Bundle;
+import java.util.regex.Pattern;
 
 public abstract class AbstractRegressionTest extends AbstractCompilerTest implements StopableTestCase {
 
@@ -878,6 +879,7 @@ protected static class JavacTestOptions {
 	protected boolean createdVerifier;
 	protected INameEnvironment javaClassLib;
 	protected TestVerifier verifier;
+	protected boolean shouldSwallowCaptureId;
 	public AbstractRegressionTest(String name) {
 		super(name);
 	}
@@ -1062,6 +1064,9 @@ protected static class JavacTestOptions {
 	protected void checkCompilerLog(String[] testFiles, Requestor requestor,
 			String[] alternatePlatformIndependantExpectedLogs, Throwable exception) {
 		String computedProblemLog = Util.convertToIndependantLineDelimiter(requestor.problemLog.toString());
+		if (this.shouldSwallowCaptureId)
+			computedProblemLog = Pattern.compile("capture#(\\d+)").matcher(computedProblemLog).replaceAll("capture");
+		  
 		int i;
 		for (i = 0; i < alternatePlatformIndependantExpectedLogs.length; i++) {
 			if (alternatePlatformIndependantExpectedLogs[i].equals(computedProblemLog))
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
new file mode 100644
index 0000000..d98fcce
--- /dev/null
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/RunOnly335CompilerTests.java
@@ -0,0 +1,86 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.core.tests;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.eclipse.jdt.core.tests.compiler.regression.GenericTypeTest;
+import org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest;
+import org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_7;
+import org.eclipse.jdt.core.tests.compiler.regression.GenericsRegressionTest_1_8;
+import org.eclipse.jdt.core.tests.compiler.regression.LambdaExpressionsTest;
+import org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest;
+import org.eclipse.jdt.core.tests.compiler.regression.NullTypeAnnotationTest;
+import org.eclipse.jdt.core.tests.compiler.regression.OverloadResolutionTest8;
+import org.eclipse.jdt.core.tests.dom.ConverterTestSetup;
+import org.eclipse.jdt.core.tests.util.AbstractCompilerTest;
+
+public class RunOnly335CompilerTests extends TestCase {
+	
+	public RunOnly335CompilerTests(String name) {
+		super(name);
+	}
+	public static Class[] getAllTestClasses() {
+		return new Class[] {
+			GenericsRegressionTest_1_8.class,
+			LambdaExpressionsTest.class,
+			NegativeLambdaExpressionsTest.class,
+			OverloadResolutionTest8.class,
+			NullTypeAnnotationTest.class, // tests type inference
+		};
+	}
+	
+	public static Class[] getCompilerClasses() {
+		return new Class[] {
+			GenericTypeTest.class,
+			GenericsRegressionTest.class,
+			GenericsRegressionTest_1_7.class,
+		};
+	}
+
+	public static Test suite() {
+		TestSuite ts = new TestSuite(RunOnly335CompilerTests.class.getName());
+
+		Class[] testClasses = getAllTestClasses();
+		addTestsToSuite(ts, testClasses);
+	
+		AbstractCompilerTest.setpossibleComplianceLevels(AbstractCompilerTest.F_1_8);
+		addTestsToSuite(ts, getCompilerClasses());
+		return ts;
+	}
+	public static void addTestsToSuite(TestSuite suite, Class[] testClasses) {
+
+		for (int i = 0; i < testClasses.length; i++) {
+			Class testClass = testClasses[i];
+			// call the suite() method and add the resulting suite to the suite
+			try {
+				Method suiteMethod = testClass.getDeclaredMethod("suite", new Class[0]); //$NON-NLS-1$
+				Test test = (Test)suiteMethod.invoke(null, new Object[0]);
+				suite.addTest(test);
+			} catch (IllegalAccessException e) {
+				e.printStackTrace();
+			} catch (InvocationTargetException e) {
+				e.getTargetException().printStackTrace();
+			} catch (NoSuchMethodException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+	protected void tearDown() throws Exception {
+		ConverterTestSetup.PROJECT_SETUP = false;
+		super.tearDown();
+	}
+}
diff --git a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter17Test.java b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter17Test.java
index 4a7fd79..c61ef4e 100644
--- a/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter17Test.java
+++ b/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/dom/ASTConverter17Test.java
@@ -894,12 +894,10 @@ public class ASTConverter17Test extends ConverterTestSetup {
 		
 		String error = "Lambda expressions are allowed only at source level 1.8 or above\n" + 
 				"Lambda expressions are allowed only at source level 1.8 or above\n" + 
-				"The method foo(X.StringToInt) in the type X is not applicable for the arguments ((String s) -> {})\n" + 
 				"Lambda expressions are allowed only at source level 1.8 or above\n" + 
 				"Lambda expressions are allowed only at source level 1.8 or above\n" + 
-				"The method bar(X.ReduceInt) in the type X is not applicable for the arguments ((int x, int y) -> {})\n" + 
 				"Lambda expressions are allowed only at source level 1.8 or above";
-		assertProblemsSize(unit, 7, error);
+		assertProblemsSize(unit, 5, error);
 
 		TypeDeclaration typedeclaration = (TypeDeclaration) getASTNode(unit, 0);
 		MethodDeclaration methoddecl = (MethodDeclaration)typedeclaration.bodyDeclarations().get(4);
diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
index cf42d73..da45d53 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/complete/CompletionOnQualifiedAllocationExpression.java
@@ -39,13 +39,13 @@ import org.eclipse.jdt.internal.compiler.lookup.*;
 
 public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {
 public TypeBinding resolveType(BlockScope scope) {
-	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
+	this.argumentTypes = Binding.NO_PARAMETERS;
 	if (this.arguments != null) {
 		int argsLength = this.arguments.length;
 		int length = this.arguments.length;
-		argumentTypes = new TypeBinding[length];
+		this.argumentTypes = new TypeBinding[length];
 		for (int a = argsLength; --a >= 0;) {
-			argumentTypes[a] = this.arguments[a].resolveType(scope);
+			this.argumentTypes[a] = this.arguments[a].resolveType(scope);
 		}
 	}
 	final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
@@ -66,7 +66,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		}
 		this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);
 		if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
-			TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);
+			TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);
 			if (inferredTypes != null) {
 				this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
 			} else {
@@ -81,7 +81,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	} else {
 	 	this.resolvedType = this.type.resolveType(scope, true /* check bounds*/);
 	 	if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
-			TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);
+			TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);
 			if (inferredTypes != null) {
 				this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
 			} else {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index b2fe043..624aa47 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -78,6 +78,7 @@ public class AllocationExpression extends Expression implements Invocation {
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PMB,IC18>*/ inferenceContexts;
 	protected InnerInferenceHelper innerInferenceHelper;
+	public TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
 
 	/** Record to keep state between different parts of resolution. */
 	ResolutionState suspendedResolutionState;
@@ -87,7 +88,6 @@ public class AllocationExpression extends Expression implements Invocation {
 		boolean diamondNeedsDeferring;
 		boolean argsContainCast;
 		boolean cannotInferDiamond; // request the an error be reported in due time
-		TypeBinding[] argumentTypes;
 		boolean hasReportedError;
 
 		ResolutionState(BlockScope scope, boolean isDiamond, boolean diamonNeedsDeferring,
@@ -97,7 +97,6 @@ public class AllocationExpression extends Expression implements Invocation {
 			this.isDiamond = isDiamond;
 			this.diamondNeedsDeferring = diamonNeedsDeferring;
 			this.argsContainCast = argsContainCast;
-			this.argumentTypes = argumentTypes;
 		}
 	}
 
@@ -412,11 +411,10 @@ public TypeBinding resolveType(BlockScope scope) {
 
 	// buffering the arguments' types
 	boolean argsContainCast = false;
-	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
 	if (this.arguments != null) {
 		boolean argHasError = false;
 		int length = this.arguments.length;
-		argumentTypes = new TypeBinding[length];
+		this.argumentTypes = new TypeBinding[length];
 		for (int i = 0; i < length; i++) {
 			Expression argument = this.arguments[i];
 			if (argument instanceof CastExpression) {
@@ -426,7 +424,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			argument.setExpressionContext(INVOCATION_CONTEXT);
 			if (this.arguments[i].resolvedType != null) 
 				scope.problemReporter().genericInferenceError("Argument was unexpectedly found resolved", this); //$NON-NLS-1$
-			if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
+			if ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {
 				argHasError = true;
 			}
 			if (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || ((argument instanceof Invocation) && ((Invocation) argument).usesInference()))) {
@@ -446,7 +444,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				// record a best guess, for clients who need hint about possible constructor match
 				TypeBinding[] pseudoArgs = new TypeBinding[length];
 				for (int i = length; --i >= 0;) {
-					pseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type
+					pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
 				}
 				this.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);
 				if (this.binding != null && !this.binding.isValidBinding()) {
@@ -478,7 +476,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		scope.problemReporter().cannotInstantiate(this.type, this.resolvedType);
 		return this.resolvedType;
 	}
-	ResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, argumentTypes);
+	ResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, this.argumentTypes);
 	if (diamondNeedsDeferring) {
 		this.suspendedResolutionState = state; // resolving to be continued later (via binding(TypeBinding targetType)).
 		return new PolyTypeBinding(this);
@@ -494,7 +492,7 @@ boolean resolvePart2(ResolutionState state) {
 	// TODO: all information persisted during this method may need to be stored per targetType?
 	if (state.isDiamond) {
 		ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
-		TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), state.argumentTypes, state.scope);
+		TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, state.scope);
 		if (inferredTypes == null) {
 			if (!state.diamondNeedsDeferring) {
 				state.scope.problemReporter().cannotInferElidedTypes(this);
@@ -509,7 +507,7 @@ boolean resolvePart2(ResolutionState state) {
 		state.cannotInferDiamond = false;
  	}
 	ReferenceBinding receiverType = (ReferenceBinding) this.resolvedType;
-	this.binding = findConstructorBinding(state.scope, this, receiverType, state.argumentTypes);
+	this.binding = findConstructorBinding(state.scope, this, receiverType, this.argumentTypes);
 	return true;
 }
 
@@ -539,14 +537,14 @@ TypeBinding resolvePart3(ResolutionState state) {
 	if (isMethodUseDeprecated(this.binding, state.scope, true)) {
 		state.scope.problemReporter().deprecatedMethod(this.binding, this);
 	}
-	if (checkInvocationArguments(state.scope, null, allocationType, this.binding, this.arguments, state.argumentTypes, state.argsContainCast, this)) {
+	if (checkInvocationArguments(state.scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, state.argsContainCast, this)) {
 		this.bits |= ASTNode.Unchecked;
 	}
 	if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
 		state.scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
 	}
 	if (!state.isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {
- 		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), state.argumentTypes, state.scope);
+ 		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, state.scope);
  	}
 	CompilerOptions compilerOptions = state.scope.compilerOptions();
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
@@ -572,13 +570,13 @@ void checkIllegalNullAnnotation(BlockScope scope, TypeBinding allocationType) {
 	}
 }
 
-public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope) {
+public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope) {
 	/* Given the allocation type and the arguments to the constructor, see if we can synthesize a generic static factory
 	   method that would, given the argument types and the invocation site, manufacture a parameterized object of type allocationType.
 	   If we are successful then by design and construction, the parameterization of the return type of the factory method is identical
 	   to the types elided in the <>.
 	 */   
-	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTypes, this);
+	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTyps, this);
 	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
 		ParameterizedGenericMethodBinding genericFactory = (ParameterizedGenericMethodBinding) factory;
 		this.inferredReturnType = genericFactory.inferredReturnType;
@@ -588,9 +586,9 @@ public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, R
 			// refresh argumentTypes from updated bindings in arguments:
 			// (this shouldn't be strictly necessary, as FunctionExpression.isCompatibleWith() should give the same result,
 			//  but it's probably be a good idea to avoid the necessity to call isCompatibleWith() in the first place). 
-			for (int i = 0; i < argumentTypes.length; i++) {
-				if (argumentTypes[i] instanceof PolyTypeBinding)
-					argumentTypes[i] = this.arguments[i].resolvedType;
+			for (int i = 0; i < argumentTyps.length; i++) {
+				if (argumentTyps[i] instanceof PolyTypeBinding)
+					argumentTyps[i] = this.arguments[i].resolvedType;
 			}
 		}
 		return ((ParameterizedTypeBinding)factory.returnType).arguments;
@@ -598,12 +596,12 @@ public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, R
 	return null;
 }
 
-public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope) {
+public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope) {
 	if ((scope.problemReporter().computeSeverity(IProblem.RedundantSpecificationOfTypeArguments) == ProblemSeverities.Ignore) || scope.compilerOptions().sourceLevel < ClassFileConstants.JDK1_7) return;
 	if (allocationType.arguments == null) return;  // raw binding
 	if (this.genericTypeArguments != null) return; // diamond can't occur with explicit type args for constructor
 	if (this.type == null) return;
-	if (argumentTypes == Binding.NO_PARAMETERS && this.typeExpected instanceof ParameterizedTypeBinding) {
+	if (argumentTyps == Binding.NO_PARAMETERS && this.typeExpected instanceof ParameterizedTypeBinding) {
 		ParameterizedTypeBinding expected = (ParameterizedTypeBinding) this.typeExpected;
 		if (expected.arguments != null && allocationType.arguments.length == expected.arguments.length) {
 			// check the case when no ctor takes no params and inference uses the expected type directly
@@ -625,7 +623,7 @@ public void checkTypeArgumentRedundancy(ParameterizedTypeBinding allocationType,
 		// checking for redundant type parameters must fake a diamond, 
 		// so we infer the same results as we would get with a diamond in source code:
 		this.type.bits |= IsDiamond;
-		inferredTypes = inferElidedTypes(allocationType, enclosingType, argumentTypes, scope);
+		inferredTypes = inferElidedTypes(allocationType, enclosingType, argumentTyps, scope);
 	} finally {
 		// reset effects of inference
 		this.type.bits = previousBits;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
index 699b4cf..e526d93 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Assignment.java
@@ -193,7 +193,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	this.expression.setExpressionContext(ASSIGNMENT_CONTEXT);
 	this.expression.setExpectedType(lhsType); // needed in case of generic method invocation
 	if (lhsType != null) {
-		this.resolvedType = lhsType.capture(scope, this.sourceEnd);
+		this.resolvedType = lhsType.capture(scope, this.lhs.sourceEnd); // make it unique, `this' shares source end with 'this.expression'.
 	}
 	LocalVariableBinding localVariableBinding = this.lhs.localVariableBinding();
 	if (localVariableBinding != null && (localVariableBinding.isCatchParameter() || localVariableBinding.isParameter())) { 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
index 171ef8d..8f638d8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java
@@ -281,7 +281,7 @@ private static void checkAlternateBinding(BlockScope scope, Expression receiver,
 			public int sourceEnd() { return 0; }
 			public TypeBinding invocationTargetType() { return invocationSite.invocationTargetType(); }
 			public boolean receiverIsImplicitThis() { return invocationSite.receiverIsImplicitThis();}
-			public InferenceContext18 freshInferenceContext(Scope someScope) { return null; /* suppress inference */ }
+			public InferenceContext18 freshInferenceContext(Scope someScope) { return invocationSite.freshInferenceContext(someScope); }
 			public ExpressionContext getExpressionContext() { return invocationSite.getExpressionContext(); }
 		};
 		MethodBinding bindingIfNoCast;
@@ -580,7 +580,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				this.bits |= ASTNode.DisableUnnecessaryCastCheck; // disable further secondary diagnosis
 			}
 		}
-		this.resolvedType = castType.capture(scope, this.sourceEnd);
+		this.resolvedType = castType.capture(scope, this.type.sourceEnd); // make it unique, a cast expression shares source end with the expression.
 		if (exprContainCast) {
 			checkNeedForCastCast(scope, this);
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java
index 5f23107..5da6e09 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocAllocationExpression.java
@@ -43,23 +43,23 @@ public class JavadocAllocationExpression extends AllocationExpression {
 		}
 
 		// buffering the arguments' types
-		TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
+		this.argumentTypes = Binding.NO_PARAMETERS;
 		boolean hasTypeVarArgs = false;
 		if (this.arguments != null) {
 			boolean argHasError = false;
 			int length = this.arguments.length;
-			argumentTypes = new TypeBinding[length];
+			this.argumentTypes = new TypeBinding[length];
 			for (int i = 0; i < length; i++) {
 				Expression argument = this.arguments[i];
 				if (scope.kind == Scope.CLASS_SCOPE) {
-					argumentTypes[i] = argument.resolveType((ClassScope)scope);
+					this.argumentTypes[i] = argument.resolveType((ClassScope)scope);
 				} else {
-					argumentTypes[i] = argument.resolveType((BlockScope)scope);
+					this.argumentTypes[i] = argument.resolveType((BlockScope)scope);
 				}
-				if (argumentTypes[i] == null) {
+				if (this.argumentTypes[i] == null) {
 					argHasError = true;
 				} else if (!hasTypeVarArgs) {
-					hasTypeVarArgs = argumentTypes[i].isTypeVariable();
+					hasTypeVarArgs = this.argumentTypes[i].isTypeVariable();
 				}
 			}
 			if (argHasError) {
@@ -78,13 +78,13 @@ public class JavadocAllocationExpression extends AllocationExpression {
 		}
 
 		ReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;
-		this.binding = scope.getConstructor(allocationType, argumentTypes, this);
+		this.binding = scope.getConstructor(allocationType, this.argumentTypes, this);
 		if (!this.binding.isValidBinding()) {
 			ReferenceBinding enclosingTypeBinding = allocationType;
 			MethodBinding contructorBinding = this.binding;
 			while (!contructorBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {
 				enclosingTypeBinding = enclosingTypeBinding.enclosingType();
-				contructorBinding = scope.getConstructor(enclosingTypeBinding, argumentTypes, this);
+				contructorBinding = scope.getConstructor(enclosingTypeBinding, this.argumentTypes, this);
 			}
 			if (contructorBinding.isValidBinding()) {
 				this.binding = contructorBinding;
@@ -92,7 +92,7 @@ public class JavadocAllocationExpression extends AllocationExpression {
 		}
 		if (!this.binding.isValidBinding()) {
 			// First try to search a method instead
-			MethodBinding methodBinding = scope.getMethod(this.resolvedType, this.resolvedType.sourceName(), argumentTypes, this);
+			MethodBinding methodBinding = scope.getMethod(this.resolvedType, this.resolvedType.sourceName(), this.argumentTypes, this);
 			if (methodBinding.isValidBinding()) {
 				this.binding = methodBinding;
 			} else {
@@ -103,22 +103,22 @@ public class JavadocAllocationExpression extends AllocationExpression {
 			}
 			return this.resolvedType;
 		} else if (this.binding.isVarargs()) {
-			int length = argumentTypes.length;
-			if (!(this.binding.parameters.length == length && argumentTypes[length-1].isArrayType())) {
-				MethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);
+			int length = this.argumentTypes.length;
+			if (!(this.binding.parameters.length == length && this.argumentTypes[length-1].isArrayType())) {
+				MethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, this.argumentTypes, ProblemReasons.NotFound);
 				scope.problemReporter().javadocInvalidConstructor(this, problem, scope.getDeclarationModifiers());
 			}
 		} else if (hasTypeVarArgs) {
-			MethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);
+			MethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, this.argumentTypes, ProblemReasons.NotFound);
 			scope.problemReporter().javadocInvalidConstructor(this, problem, scope.getDeclarationModifiers());
 		} else if (this.binding instanceof ParameterizedMethodBinding) {
 			ParameterizedMethodBinding paramMethodBinding = (ParameterizedMethodBinding) this.binding;
 			if (paramMethodBinding.hasSubstitutedParameters()) {
-				int length = argumentTypes.length;
+				int length = this.argumentTypes.length;
 				for (int i=0; i<length; i++) {
-					if (TypeBinding.notEquals(paramMethodBinding.parameters[i], argumentTypes[i]) &&
-							TypeBinding.notEquals(paramMethodBinding.parameters[i].erasure(), argumentTypes[i].erasure())) {
-						MethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, argumentTypes, ProblemReasons.NotFound);
+					if (TypeBinding.notEquals(paramMethodBinding.parameters[i], this.argumentTypes[i]) &&
+							TypeBinding.notEquals(paramMethodBinding.parameters[i].erasure(), this.argumentTypes[i].erasure())) {
+						MethodBinding problem = new ProblemMethodBinding(this.binding, this.binding.selector, this.argumentTypes, ProblemReasons.NotFound);
 						scope.problemReporter().javadocInvalidConstructor(this, problem, scope.getDeclarationModifiers());
 						break;
 					}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java
index 87dccc3..9b8f062 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/JavadocMessageSend.java
@@ -50,23 +50,22 @@ public class JavadocMessageSend extends MessageSend {
 
 		// will check for null after args are resolved
 
-		TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
 		boolean hasArgsTypeVar = false;
 		if (this.arguments != null) {
 			boolean argHasError = false; // typeChecks all arguments
 			int length = this.arguments.length;
-			argumentTypes = new TypeBinding[length];
+			this.argumentTypes = new TypeBinding[length];
 			for (int i = 0; i < length; i++){
 				Expression argument = this.arguments[i];
 				if (scope.kind == Scope.CLASS_SCOPE) {
-					argumentTypes[i] = argument.resolveType((ClassScope)scope);
+					this.argumentTypes[i] = argument.resolveType((ClassScope)scope);
 				} else {
-					argumentTypes[i] = argument.resolveType((BlockScope)scope);
+					this.argumentTypes[i] = argument.resolveType((BlockScope)scope);
 				}
-				if (argumentTypes[i] == null) {
+				if (this.argumentTypes[i] == null) {
 					argHasError = true;
 				} else if (!hasArgsTypeVar) {
-					hasArgsTypeVar = argumentTypes[i].isTypeVariable();
+					hasArgsTypeVar = this.argumentTypes[i].isTypeVariable();
 				}
 			}
 			if (argHasError) {
@@ -86,17 +85,17 @@ public class JavadocMessageSend extends MessageSend {
 
 		// base type cannot receive any message
 		if (this.actualReceiverType.isBaseType()) {
-			scope.problemReporter().javadocErrorNoMethodFor(this, this.actualReceiverType, argumentTypes, scope.getDeclarationModifiers());
+			scope.problemReporter().javadocErrorNoMethodFor(this, this.actualReceiverType, this.argumentTypes, scope.getDeclarationModifiers());
 			return null;
 		}
-		this.binding = scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
+		this.binding = scope.getMethod(this.actualReceiverType, this.selector, this.argumentTypes, this);
 		if (!this.binding.isValidBinding()) {
 			// Try method in enclosing types
 			TypeBinding enclosingTypeBinding = this.actualReceiverType;
 			MethodBinding methodBinding = this.binding;
 			while (!methodBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {
 				enclosingTypeBinding = enclosingTypeBinding.enclosingType();
-				methodBinding = scope.getMethod(enclosingTypeBinding, this.selector, argumentTypes, this);
+				methodBinding = scope.getMethod(enclosingTypeBinding, this.selector, this.argumentTypes, this);
 			}
 			if (methodBinding.isValidBinding()) {
 				this.binding = methodBinding;
@@ -105,12 +104,12 @@ public class JavadocMessageSend extends MessageSend {
 				enclosingTypeBinding = this.actualReceiverType;
 				MethodBinding contructorBinding = this.binding;
 				if (!contructorBinding.isValidBinding() && CharOperation.equals(this.selector, enclosingTypeBinding.shortReadableName())) {
-					contructorBinding = scope.getConstructor((ReferenceBinding)enclosingTypeBinding, argumentTypes, this);
+					contructorBinding = scope.getConstructor((ReferenceBinding)enclosingTypeBinding, this.argumentTypes, this);
 				}
 				while (!contructorBinding.isValidBinding() && (enclosingTypeBinding.isMemberType() || enclosingTypeBinding.isLocalType())) {
 					enclosingTypeBinding = enclosingTypeBinding.enclosingType();
 					if (CharOperation.equals(this.selector, enclosingTypeBinding.shortReadableName())) {
-						contructorBinding = scope.getConstructor((ReferenceBinding)enclosingTypeBinding, argumentTypes, this);
+						contructorBinding = scope.getConstructor((ReferenceBinding)enclosingTypeBinding, this.argumentTypes, this);
 					}
 				}
 				if (contructorBinding.isValidBinding()) {
@@ -140,7 +139,7 @@ public class JavadocMessageSend extends MessageSend {
 				if (this.actualReceiverType instanceof ReferenceBinding) {
 					this.binding.declaringClass = (ReferenceBinding) this.actualReceiverType;
 				} else {
-					scope.problemReporter().javadocErrorNoMethodFor(this, this.actualReceiverType, argumentTypes, scope.getDeclarationModifiers());
+					scope.problemReporter().javadocErrorNoMethodFor(this, this.actualReceiverType, this.argumentTypes, scope.getDeclarationModifiers());
 					return null;
 				}
 			}
@@ -152,19 +151,19 @@ public class JavadocMessageSend extends MessageSend {
 			}
 			return this.resolvedType = this.binding == null ? null : this.binding.returnType;
 		} else if (hasArgsTypeVar) {
-			MethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, argumentTypes, ProblemReasons.NotFound);
+			MethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, this.argumentTypes, ProblemReasons.NotFound);
 			scope.problemReporter().javadocInvalidMethod(this, problem, scope.getDeclarationModifiers());
 		} else if (this.binding.isVarargs()) {
-			int length = argumentTypes.length;
-			if (!(this.binding.parameters.length == length && argumentTypes[length-1].isArrayType())) {
-				MethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, argumentTypes, ProblemReasons.NotFound);
+			int length = this.argumentTypes.length;
+			if (!(this.binding.parameters.length == length && this.argumentTypes[length-1].isArrayType())) {
+				MethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, this.argumentTypes, ProblemReasons.NotFound);
 				scope.problemReporter().javadocInvalidMethod(this, problem, scope.getDeclarationModifiers());
 			}
 		} else {
-			int length = argumentTypes.length;
+			int length = this.argumentTypes.length;
 			for (int i=0; i<length; i++) {
-				if (TypeBinding.notEquals(this.binding.parameters[i].erasure(), argumentTypes[i].erasure())) {
-					MethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, argumentTypes, ProblemReasons.NotFound);
+				if (TypeBinding.notEquals(this.binding.parameters[i].erasure(), this.argumentTypes[i].erasure())) {
+					MethodBinding problem = new ProblemMethodBinding(this.binding, this.selector, this.argumentTypes, ProblemReasons.NotFound);
 					scope.problemReporter().javadocInvalidMethod(this, problem, scope.getDeclarationModifiers());
 					break;
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 95705a8..133fcad 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -734,12 +734,14 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				if (this.body instanceof Block) {
 					if (this.returnsVoid) {
 						this.shapeAnalysisComplete = true;
+						break shapeAnalysis;
 					}
 				} else {
-					final Expression expressionBody = (Expression) this.body;
+					final Expression expressionBody = (Expression) copy.body;
 					this.voidCompatible = this.assistNode ? true : expressionBody.statementExpression();
 					this.valueCompatible = expressionBody.resolvedType != TypeBinding.VOID;
 					this.shapeAnalysisComplete = true;
+					break shapeAnalysis;
 				}
 				// Do not proceed with data/control flow analysis if resolve encountered errors.
 				if (this.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 15b6cad..520b5c0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -116,6 +116,10 @@ public class MessageSend extends Expression implements Invocation {
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
 	protected InnerInferenceHelper innerInferenceHelper;
+	private boolean receiverIsType;
+	protected boolean argsContainCast;
+	public TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
+	
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	boolean nonStatic = !this.binding.isStatic();
@@ -593,7 +597,7 @@ public TypeBinding resolveType(BlockScope scope) {
 
 	this.constant = Constant.NotAConstant;
 	long sourceLevel = scope.compilerOptions().sourceLevel;
-	boolean receiverCast = false, argsContainCast = false;
+	boolean receiverCast = false;
 	if (this.receiver instanceof CastExpression) {
 		this.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
 		receiverCast = true;
@@ -601,7 +605,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	if (this.receiver.resolvedType != null)
 		scope.problemReporter().genericInferenceError("Receiver was unexpectedly found resolved", this); //$NON-NLS-1$
 	this.actualReceiverType = this.receiver.resolveType(scope);
-	boolean receiverIsType = this.receiver instanceof NameReference && (((NameReference) this.receiver).bits & Binding.TYPE) != 0;
+	this.receiverIsType = this.receiver instanceof NameReference && (((NameReference) this.receiver).bits & Binding.TYPE) != 0;
 	if (receiverCast && this.actualReceiverType != null) {
 		 // due to change of declaring class with receiver type, only identity cast should be notified
 		if (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {
@@ -632,21 +636,20 @@ public TypeBinding resolveType(BlockScope scope) {
 		}
 	}
 	// will check for null after args are resolved
-	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
 	if (this.arguments != null) {
 		boolean argHasError = false; // typeChecks all arguments
 		int length = this.arguments.length;
-		argumentTypes = new TypeBinding[length];
+		this.argumentTypes = new TypeBinding[length];
 		for (int i = 0; i < length; i++){
 			Expression argument = this.arguments[i];
 			if (this.arguments[i].resolvedType != null) 
 				scope.problemReporter().genericInferenceError("Argument was unexpectedly found resolved", this); //$NON-NLS-1$
 			if (argument instanceof CastExpression) {
 				argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
-				argsContainCast = true;
+				this.argsContainCast = true;
 			}
 			argument.setExpressionContext(INVOCATION_CONTEXT);
-			if ((argumentTypes[i] = argument.resolveType(scope)) == null){
+			if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
 				argHasError = true;
 			}
 			if (sourceLevel >= ClassFileConstants.JDK1_8) {
@@ -662,7 +665,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				//  record a best guess, for clients who need hint about possible method match
 				TypeBinding[] pseudoArgs = new TypeBinding[length];
 				for (int i = length; --i >= 0;)
-					pseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type
+					pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
 				this.binding =
 					this.receiver.isImplicitThis()
 						? scope.getImplicitMethod(this.selector, pseudoArgs, this)
@@ -692,18 +695,18 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 	// base type cannot receive any message
 	if (this.actualReceiverType.isBaseType()) {
-		scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);
+		scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
 		return null;
 	}
 
-	findMethodBinding(scope, argumentTypes);
+	findMethodBinding(scope);
 
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
 			if (this.actualReceiverType instanceof ReferenceBinding) {
 				this.binding.declaringClass = (ReferenceBinding) this.actualReceiverType;
 			} else {
-				scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);
+				scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
 				return null;
 			}
 		}
@@ -773,7 +776,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 	if (!this.binding.isStatic()) {
 		// the "receiver" must not be a type
-		if (receiverIsType) {
+		if (this.receiverIsType) {
 			scope.problemReporter().mustUseAStaticMethod(this, this.binding);
 			if (this.actualReceiverType.isRawType()
 					&& (this.receiver.bits & ASTNode.IgnoreRawTypeCheck) == 0
@@ -792,14 +795,14 @@ public TypeBinding resolveType(BlockScope scope) {
 		}
 	} else {
 		// static message invoked through receiver? legal but unoptimal (optional warning).
-		if (!(this.receiver.isImplicitThis() || this.receiver.isSuper() || receiverIsType)) {
+		if (!(this.receiver.isImplicitThis() || this.receiver.isSuper() || this.receiverIsType)) {
 			scope.problemReporter().nonStaticAccessToStaticMethod(this, this.binding);
 		}
 		if (!this.receiver.isImplicitThis() && TypeBinding.notEquals(this.binding.declaringClass, this.actualReceiverType)) {
 			scope.problemReporter().indirectAccessToStaticMethod(this, this.binding);
 		}
 	}
-	if (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {
+	if (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
 		this.bits |= ASTNode.Unchecked;
 	}
 
@@ -846,7 +849,7 @@ public TypeBinding resolveType(BlockScope scope) {
 	}
 	if (this.receiver.isSuper() && this.actualReceiverType.isInterface()) {
 		// 15.12.3 (Java 8)
-		scope.checkAppropriateMethodAgainstSupers(this.selector, this.binding, argumentTypes, this);
+		scope.checkAppropriateMethodAgainstSupers(this.selector, this.binding, this.argumentTypes, this);
 	}
 	if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
 		scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
@@ -862,11 +865,11 @@ public TypeBinding resolveType(BlockScope scope) {
  * after applicability checking (18.5.1) to include more information into the final
  * invocation type inference (18.5.2).
  */
-protected void findMethodBinding(BlockScope scope, TypeBinding[] argumentTypes) {
+protected void findMethodBinding(BlockScope scope) {
 	this.binding = this.receiver.isImplicitThis()
-			? scope.getImplicitMethod(this.selector, argumentTypes, this)
-			: scope.getMethod(this.actualReceiverType, this.selector, argumentTypes, this);
-	resolvePolyExpressionArguments(this, this.binding, argumentTypes, scope);
+			? scope.getImplicitMethod(this.selector, this.argumentTypes, this)
+			: scope.getMethod(this.actualReceiverType, this.selector, this.argumentTypes, this);
+	resolvePolyExpressionArguments(this, this.binding, this.argumentTypes, scope);
 	
 	/* There are embedded assumptions in the JLS8 type inference scheme that a successful solution of the type equations results in an
 	   applicable method. This appears to be a tenuous assumption, at least one not made by the JLS7 engine or the reference compiler and 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 5920a80..1d7386a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -396,10 +396,10 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		}
 
 		// will check for null after args are resolved
-		TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
+		this.argumentTypes = Binding.NO_PARAMETERS;
 		if (this.arguments != null) {
 			int length = this.arguments.length;
-			argumentTypes = new TypeBinding[length];
+			this.argumentTypes = new TypeBinding[length];
 			for (int i = 0; i < length; i++) {
 				Expression argument = this.arguments[i];
 				if (argument instanceof CastExpression) {
@@ -407,7 +407,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					argsContainCast = true;
 				}
 				argument.setExpressionContext(INVOCATION_CONTEXT);
-				if ((argumentTypes[i] = argument.resolveType(scope)) == null){
+				if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
 					hasError = true;
 				}
 				if (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || (argument instanceof Invocation && ((Invocation)argument).usesInference()))) {
@@ -433,7 +433,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 					int length = this.arguments  == null ? 0 : this.arguments.length;
 					TypeBinding[] pseudoArgs = new TypeBinding[length];
 					for (int i = length; --i >= 0;) {
-						pseudoArgs[i] = argumentTypes[i] == null ? TypeBinding.NULL : argumentTypes[i]; // replace args with errors with null type
+						pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
 					}
 					this.binding = scope.findMethod(referenceReceiver, TypeConstants.INIT, pseudoArgs, this, false);
 					if (this.binding != null && !this.binding.isValidBinding()) {
@@ -469,7 +469,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				return this.resolvedType = receiverType;
 			}
 			if (isDiamond) {
-				TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) receiverType, receiverType.enclosingType(), argumentTypes, scope);
+				TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) receiverType, receiverType.enclosingType(), this.argumentTypes, scope);
 				if (inferredTypes == null) {
 					scope.problemReporter().cannotInferElidedTypes(this);
 					return this.resolvedType = null;
@@ -477,13 +477,13 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				receiverType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) receiverType).genericType(), inferredTypes, ((ParameterizedTypeBinding) receiverType).enclosingType());
 			}
 			ReferenceBinding allocationType = (ReferenceBinding) receiverType;
-			this.binding = findConstructorBinding(scope, this, allocationType, argumentTypes);
+			this.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);
 
 			if (this.binding.isValidBinding()) {	
 				if (isMethodUseDeprecated(this.binding, scope, true)) {
 					scope.problemReporter().deprecatedMethod(this.binding, this);
 				}
-				if (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {
+				if (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, argsContainCast, this)) {
 					this.bits |= ASTNode.Unchecked;
 				}
 				if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
@@ -504,7 +504,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				scope.problemReporter().missingTypeInConstructor(this, this.binding);
 			}
 			if (!isDiamond && receiverType.isParameterizedTypeWithActualArguments()) {
-		 		checkTypeArgumentRedundancy((ParameterizedTypeBinding)receiverType, receiverType.enclosingType(), argumentTypes , scope);
+		 		checkTypeArgumentRedundancy((ParameterizedTypeBinding)receiverType, receiverType.enclosingType(), this.argumentTypes , scope);
 		 	}
 			// The enclosing instance must be compatible with the innermost enclosing type
 			ReferenceBinding expectedType = this.binding.declaringClass.enclosingType();
@@ -543,7 +543,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 		if ((this.resolvedType.tagBits & TagBits.HierarchyHasProblems) != 0) {
 			return null; // stop secondary errors
 		}
-		MethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, argumentTypes);
+		MethodBinding inheritedBinding = findConstructorBinding(scope, this, anonymousSuperclass, this.argumentTypes);
 			
 		if (!inheritedBinding.isValidBinding()) {
 			if (inheritedBinding.declaringClass == null) {
@@ -571,7 +571,7 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 			this.enclosingInstance.computeConversion(scope, targetEnclosing, enclosingInstanceType);
 		}
 		if (this.arguments != null) {
-			if (checkInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, argumentTypes, argsContainCast, this)) {
+			if (checkInvocationArguments(scope, null, anonymousSuperclass, inheritedBinding, this.arguments, this.argumentTypes, argsContainCast, this)) {
 				this.bits |= ASTNode.Unchecked;
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java
index 9b4bf14..52ff94e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CaptureBinding.java
@@ -15,6 +15,7 @@
 package org.eclipse.jdt.internal.compiler.lookup;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
@@ -28,6 +29,7 @@ public class CaptureBinding extends TypeVariableBinding {
 	/* information to compute unique binding key */
 	public ReferenceBinding sourceType;
 	public int position;
+	public ASTNode cud; // to facilitate recaptures.
 
 	public CaptureBinding(WildcardBinding wildcard, ReferenceBinding sourceType, int position, int captureID) {
 		super(TypeConstants.WILDCARD_CAPTURE_NAME_PREFIX, null, 0, wildcard.environment);
@@ -53,6 +55,11 @@ public class CaptureBinding extends TypeVariableBinding {
 		}
 	}
 	
+	public CaptureBinding(WildcardBinding wildcard, ReferenceBinding sourceType, int position, ASTNode cud, int captureID) {
+		this(wildcard, sourceType, position, captureID);
+		this.cud = cud;
+	}
+	
 	// for subclass CaptureBinding18
 	protected CaptureBinding(ReferenceBinding sourceType, char[] sourceName, int position, int captureID, LookupEnvironment environment) {
 		super(sourceName, null, 0, environment);
@@ -350,6 +357,17 @@ public class CaptureBinding extends TypeVariableBinding {
 	}
 
 	@Override
+	TypeBinding substituteInferenceVariable(InferenceVariable var, TypeBinding substituteType) {
+		TypeBinding newWildcard = this.wildcard.substituteInferenceVariable(var, substituteType);
+		if (newWildcard != this.wildcard) {  //$IDENTITY-COMPARISON$
+			CaptureBinding newCapture = new CaptureBinding((WildcardBinding) newWildcard, this.sourceType, this.position, this.cud, this.captureID);
+		    newCapture.id = this.id; // there is no need really to add this to the derived types, just equate the type system ids and the capture ids.
+			return newCapture;
+		}
+		return this;
+	}
+	
+	@Override
 	public void setTypeAnnotations(AnnotationBinding[] annotations, boolean evalNullAnnotations) {
 		super.setTypeAnnotations(annotations, evalNullAnnotations);
 		if (annotations != Binding.NO_ANNOTATIONS && this.wildcard != null) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
index 21f7c1e..3680cd1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java
@@ -800,6 +800,8 @@ public String toString() {
 	return "--- CompilationUnit Scope : " + new String(this.referenceContext.getFileName()); //$NON-NLS-1$
 }
 private ReferenceBinding typeToRecord(TypeBinding type) {
+	if (type == null)
+		return null;
 	while (type.isArrayType())
 		type = ((ArrayBinding) type).leafComponentType();
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
index 8144e21..4928704 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/LookupEnvironment.java
@@ -38,6 +38,7 @@ import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ClassFilePool;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
@@ -1003,6 +1004,10 @@ public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, Ty
 	return this.typeSystem.getWildcard(genericType, rank, bound, otherBounds, boundKind);
 }
 
+public CaptureBinding createCapturedWildcard(WildcardBinding wildcard, ReferenceBinding contextType, int position, ASTNode cud, int id) {
+	return this.typeSystem.getCapturedWildcard(wildcard, contextType, position, cud, id);
+}
+
 public WildcardBinding createWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, AnnotationBinding [] annotations) {
 	return this.typeSystem.getWildcard(genericType, rank, bound, otherBounds, boundKind, annotations);
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
index ad8fa12..c5dfed4 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedTypeBinding.java
@@ -43,6 +43,7 @@ import java.util.List;
 import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
@@ -123,11 +124,12 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 	public boolean canBeInstantiated() {
 		return ((this.tagBits & TagBits.HasDirectWildcard) == 0) && super.canBeInstantiated(); // cannot instantiate param type with wildcard arguments
 	}
+
 	/**
 	 * Perform capture conversion for a parameterized type with wildcard arguments
 	 * @see org.eclipse.jdt.internal.compiler.lookup.TypeBinding#capture(Scope,int)
 	 */
-	public TypeBinding capture(Scope scope, int position) {
+	public ParameterizedTypeBinding capture(Scope scope, int position) {
 		if ((this.tagBits & TagBits.HasDirectWildcard) == 0)
 			return this;
 
@@ -139,14 +141,22 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		ReferenceBinding contextType = scope.enclosingSourceType();
 		if (contextType != null) contextType = contextType.outermostEnclosingType(); // maybe null when used programmatically by DOM
 
+		CompilationUnitScope compilationUnitScope = scope.compilationUnitScope();
+		ASTNode cud = compilationUnitScope.referenceContext;
+		long sourceLevel = this.environment.globalOptions.sourceLevel;
+		// A couple of NTAT tests fail with interned captures. The new messages look better and correct. Stephan to validate. 
+		final boolean needUniqueCapture = sourceLevel >= ClassFileConstants.JDK1_8 && !this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled;
+		
 		for (int i = 0; i < length; i++) {
 			TypeBinding argument = originalArguments[i];
 			if (argument.kind() == Binding.WILDCARD_TYPE) { // no capture for intersection types
 				final WildcardBinding wildcard = (WildcardBinding) argument;
 				if (wildcard.boundKind == Wildcard.SUPER && wildcard.bound.id == TypeIds.T_JavaLangObject)
 					capturedArguments[i] = wildcard.bound;
-				else
-					capturedArguments[i] = new CaptureBinding(wildcard, contextType, position, scope.compilationUnitScope().nextCaptureID());
+				else if (needUniqueCapture)
+					capturedArguments[i] = this.environment.createCapturedWildcard(wildcard, contextType, position, cud, compilationUnitScope.nextCaptureID());
+				else 
+					capturedArguments[i] = new CaptureBinding(wildcard, contextType, position, compilationUnitScope.nextCaptureID());	
 			} else {
 				capturedArguments[i] = argument;
 			}
@@ -160,7 +170,7 @@ public class ParameterizedTypeBinding extends ReferenceBinding implements Substi
 		}
 		return capturedParameterizedType;
 	}
-	
+
 	/**
 	 * Perform capture deconversion for a parameterized type with captured wildcard arguments
 	 * @see org.eclipse.jdt.internal.compiler.lookup.TypeBinding#uncapture(Scope)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
index ff02719..9a672fc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
@@ -36,6 +36,11 @@ public class PolyTypeBinding extends TypeBinding {
 	public boolean isCompatibleWith(TypeBinding left, Scope scope) {
 		return this.vanillaCompatibilty ? this.expression.isCompatibleWith(left, scope) : this.expression.isBoxingCompatibleWith(left, scope);
 	}
+	
+	@Override
+	public boolean isPolyType() {
+		return true;
+	}
 
 	public char[] qualifiedSourceName() {
 		return readableName();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemMethodBinding.java
index bab0919..f6bb9b5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemMethodBinding.java
@@ -40,6 +40,10 @@ public ProblemMethodBinding(MethodBinding closestMatch, char[] selector, TypeBin
 		this.returnType = closestMatch.returnType;
 	}
 }
+@Override
+public MethodBinding shallowOriginal() {
+	return this.closestMatch == null ? this : this.closestMatch.shallowOriginal();
+}
 /* API
 * Answer the problem id associated with the receiver.
 * NoError if the receiver is a valid binding.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
index 1bd3daf..73e041b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
@@ -44,4 +44,5 @@ public interface ProblemReasons {
 	final int ApplicableMethodOverriddenByInapplicable = 24;
 	final int ContradictoryNullAnnotations = 25;
 	final int NoSuchMethodOnArray = 26;
+	final int InferredAppliableMethodInapplicable = 27; // 18.5.1 ignores arguments not pertinent to applicability. When these are taken into consideration method could fail applicability
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index c3f63fb..6672400 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -740,6 +740,11 @@ public boolean isParameterizedWithOwnVariables() {
 public boolean isProperType(boolean admitCapture18) {
 	return true;
 }
+
+public boolean isPolyType() {
+	return false;
+}
+
 /**
  * Substitute all occurrences of 'var' within the current type by 'substituteType.
  * @param var an inference variable (JLS8 18.1.1)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
index 3887fe3..0907e94 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeSystem.java
@@ -15,6 +15,7 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import java.util.HashMap;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 import org.eclipse.jdt.internal.compiler.util.Util;
 
@@ -337,6 +338,37 @@ public class TypeSystem {
 		return (WildcardBinding) (this.types[wildcard.id = this.typeid++][0] = wildcard);
 	}
 	
+	// No need for an override in ATS, since we are dealing with recaptures here.
+	public final CaptureBinding getCapturedWildcard(WildcardBinding wildcard, ReferenceBinding contextType, int position, ASTNode cud, int id) {
+		
+		WildcardBinding unannotatedWildcard = (WildcardBinding) getUnannotatedType(wildcard);
+		TypeBinding[] derivedTypes = this.types[unannotatedWildcard.id];  // by construction, cachedInfo != null now.
+		int i, length = derivedTypes.length;
+		for (i = 0; i < length; i++) {
+			TypeBinding derivedType = derivedTypes[i];
+			if (derivedType == null) 
+				break;
+			if (!derivedType.isCapture())
+				continue;
+			CaptureBinding prior = (CaptureBinding) derivedType;
+			if (prior.sourceType != contextType || prior.position != position || prior.cud != cud) //$IDENTITY-COMPARISON$
+				continue;
+			return prior;
+		}
+		
+		if (i == length) {
+			System.arraycopy(derivedTypes, 0, derivedTypes = new TypeBinding[length * 2], 0, length);
+			this.types[unannotatedWildcard.id] = derivedTypes;
+		}
+		TypeBinding capture = derivedTypes[i] = new CaptureBinding(wildcard, contextType, position, cud, id);
+	
+		int typesLength = this.types.length;
+		if (this.typeid == typesLength)
+			System.arraycopy(this.types, 0, this.types = new TypeBinding[typesLength * 2][], 0, typesLength);
+		this.types[this.typeid] = new TypeBinding[1];
+		return (CaptureBinding) (this.types[capture.id = this.typeid++][0] = capture);
+	}
+	
 	public WildcardBinding getWildcard(ReferenceBinding genericType, int rank, TypeBinding bound, TypeBinding[] otherBounds, int boundKind, AnnotationBinding[] annotations) {
 		return getWildcard(genericType, rank, bound, otherBounds, boundKind);
 	}
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
index 623bc35..e88350c 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetAllocationExpression.java
@@ -24,7 +24,6 @@ import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.CastExpression;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
-import org.eclipse.jdt.internal.compiler.ast.InnerInferenceHelper;
 import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;
 import org.eclipse.jdt.internal.compiler.ast.TypeReference;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
@@ -185,12 +184,11 @@ public TypeBinding resolveType(BlockScope scope) {
 
 	// buffering the arguments' types
 	boolean argsContainCast = false;
-	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
+	this.argumentTypes = Binding.NO_PARAMETERS;
 	if (this.arguments != null) {
 		boolean argHasError = false;
 		int length = this.arguments.length;
-		argumentTypes = new TypeBinding[length];
-		TypeBinding argumentType;
+		this.argumentTypes = new TypeBinding[length];
 		for (int i = 0; i < length; i++) {
 			Expression argument = this.arguments[i];
 			if (argument instanceof CastExpression) {
@@ -198,13 +196,9 @@ public TypeBinding resolveType(BlockScope scope) {
 				argsContainCast = true;
 			}
 			argument.setExpressionContext(INVOCATION_CONTEXT);
-			if ((argumentType = argumentTypes[i] = argument.resolveType(scope)) == null) {
+			if ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {
 				argHasError = true;
 			}
-			if (argumentType != null && argumentType.kind() == Binding.POLY_TYPE) {
-				if (this.innerInferenceHelper == null)
-					this.innerInferenceHelper = new InnerInferenceHelper();
-			}
 		}
 		if (argHasError) {
 			return this.resolvedType;
@@ -218,7 +212,7 @@ public TypeBinding resolveType(BlockScope scope) {
 		return this.resolvedType;
 	}
 	if (isDiamond) {
-		TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, argumentTypes, scope);
+		TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, null, this.argumentTypes, scope);
 		if (inferredTypes == null) {
 			scope.problemReporter().cannotInferElidedTypes(this);
 			return this.resolvedType = null;
@@ -227,7 +221,7 @@ public TypeBinding resolveType(BlockScope scope) {
  	}
 	
 	ReferenceBinding allocatedType = (ReferenceBinding) this.resolvedType;
-	this.binding = findConstructorBinding(scope, this, allocatedType, argumentTypes);
+	this.binding = findConstructorBinding(scope, this, allocatedType, this.argumentTypes);
 
 	if (!this.binding.isValidBinding()) {	
 		if (this.binding instanceof ProblemMethodBinding
@@ -255,7 +249,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				return this.resolvedType;
 			}
 			CodeSnippetScope localScope = new CodeSnippetScope(scope);
-			MethodBinding privateBinding = localScope.getConstructor((ReferenceBinding)this.delegateThis.type, argumentTypes, this);
+			MethodBinding privateBinding = localScope.getConstructor((ReferenceBinding)this.delegateThis.type, this.argumentTypes, this);
 			if (!privateBinding.isValidBinding()) {
 				if (this.binding.declaringClass == null) {
 					this.binding.declaringClass = allocatedType;
@@ -285,14 +279,14 @@ public TypeBinding resolveType(BlockScope scope) {
 	if (this.arguments != null) {
 		for (int i = 0; i < this.arguments.length; i++) {
 			TypeBinding parameterType = this.binding.parameters[i];
-			TypeBinding argumentType = argumentTypes[i];
+			TypeBinding argumentType = this.argumentTypes[i];
 			this.arguments[i].computeConversion(scope, parameterType, argumentType);
 			if (argumentType.needsUncheckedConversion(parameterType)) {
 				scope.problemReporter().unsafeTypeConversion(this.arguments[i], argumentType, parameterType);
 			}
 		}
 		if (argsContainCast) {
-			CastExpression.checkNeedForArgumentCasts(scope, null, allocatedType, this.binding, this.arguments, argumentTypes, this);
+			CastExpression.checkNeedForArgumentCasts(scope, null, allocatedType, this.binding, this.arguments, this.argumentTypes, this);
 		}
 	}
 	if (allocatedType.isRawType() && this.binding.hasSubstitutedParameters()) {
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
index 1f2a4d3..6c172d9 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetMessageSend.java
@@ -23,7 +23,6 @@ import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.CastExpression;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
-import org.eclipse.jdt.internal.compiler.ast.InnerInferenceHelper;
 import org.eclipse.jdt.internal.compiler.ast.MessageSend;
 import org.eclipse.jdt.internal.compiler.ast.NameReference;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
@@ -195,73 +194,68 @@ public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo f
 public TypeBinding resolveType(BlockScope scope) {
 	// Answer the signature return type
 	// Base type promotion
-
-	this.constant = Constant.NotAConstant;
-	boolean receiverCast = false, argsContainCast = false;
-	if (this.receiver instanceof CastExpression) {
-		this.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on
-		receiverCast = true;
-	}
-	this.actualReceiverType = this.receiver.resolveType(scope);
-	if (receiverCast && this.actualReceiverType != null) {
-		 // due to change of declaring class with receiver type, only identity cast should be notified
-		if (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {
-			scope.problemReporter().unnecessaryCast((CastExpression)this.receiver);
+	
+	if (this.constant != Constant.NotAConstant) {
+		this.constant = Constant.NotAConstant;
+		boolean receiverCast = false;
+		if (this.receiver instanceof CastExpression) {
+			this.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on
+			receiverCast = true;
 		}
-	}
-	// resolve type arguments (for generic constructor call)
-	if (this.typeArguments != null) {
-		int length = this.typeArguments.length;
-		boolean argHasError = false; // typeChecks all arguments
-		this.genericTypeArguments = new TypeBinding[length];
-		for (int i = 0; i < length; i++) {
-			if ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {
-				argHasError = true;
+		this.actualReceiverType = this.receiver.resolveType(scope);
+		if (receiverCast && this.actualReceiverType != null) {
+			// due to change of declaring class with receiver type, only identity cast should be notified
+			if (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {
+				scope.problemReporter().unnecessaryCast((CastExpression)this.receiver);
 			}
 		}
-		if (argHasError) {
-			return null;
-		}
-	}
-	// will check for null after args are resolved
-	TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	if (this.arguments != null) {
-		boolean argHasError = false; // typeChecks all arguments
-		int length = this.arguments.length;
-		argumentTypes = new TypeBinding[length];
-		TypeBinding argumentType;
-		for (int i = 0; i < length; i++) {
-			Expression argument = this.arguments[i];
-			if (argument instanceof CastExpression) {
-				argument.bits |= DisableUnnecessaryCastCheck; // will check later on
-				argsContainCast = true;
+		// resolve type arguments (for generic constructor call)
+		if (this.typeArguments != null) {
+			int length = this.typeArguments.length;
+			boolean argHasError = false; // typeChecks all arguments
+			this.genericTypeArguments = new TypeBinding[length];
+			for (int i = 0; i < length; i++) {
+				if ((this.genericTypeArguments[i] = this.typeArguments[i].resolveType(scope, true /* check bounds*/)) == null) {
+					argHasError = true;
+				}
 			}
-			argument.setExpressionContext(INVOCATION_CONTEXT);
-			if ((argumentType = argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)
-				argHasError = true;
-			if (argumentType != null && argumentType.kind() == Binding.POLY_TYPE) {
-				if (this.innerInferenceHelper == null)
-					this.innerInferenceHelper = new InnerInferenceHelper();
+			if (argHasError) {
+				return null;
 			}
 		}
-		if (argHasError) {
-			if(this.actualReceiverType instanceof ReferenceBinding) {
-				// record any selector match, for clients who may still need hint about possible method match
-				this.binding = scope.findMethod((ReferenceBinding)this.actualReceiverType, this.selector, new TypeBinding[]{}, this, false);
+		// will check for null after args are resolved
+		if (this.arguments != null) {
+			boolean argHasError = false; // typeChecks all arguments
+			int length = this.arguments.length;
+			this.argumentTypes = new TypeBinding[length];
+			for (int i = 0; i < length; i++) {
+				Expression argument = this.arguments[i];
+				if (argument instanceof CastExpression) {
+					argument.bits |= DisableUnnecessaryCastCheck; // will check later on
+					this.argsContainCast = true;
+				}
+				argument.setExpressionContext(INVOCATION_CONTEXT);
+				if ((this.argumentTypes[i] = this.arguments[i].resolveType(scope)) == null)
+					argHasError = true;
 			}
+			if (argHasError) {
+				if(this.actualReceiverType instanceof ReferenceBinding) {
+					// record any selector match, for clients who may still need hint about possible method match
+					this.binding = scope.findMethod((ReferenceBinding)this.actualReceiverType, this.selector, new TypeBinding[]{}, this, false);
+				}
+				return null;
+			}
+		}
+		if (this.actualReceiverType == null) {
+			return null;
+		}
+		// base type cannot receive any message
+		if (this.actualReceiverType.isBaseType()) {
+			scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
 			return null;
 		}
 	}
-	if (this.actualReceiverType == null) {
-		return null;
-	}
-	// base type cannot receive any message
-	if (this.actualReceiverType.isBaseType()) {
-		scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);
-		return null;
-	}
-
-	findMethodBinding(scope, argumentTypes);
+	findMethodBinding(scope);
 		
 	if (!this.binding.isValidBinding()) {
 		if (this.binding instanceof ProblemMethodBinding
@@ -281,14 +275,14 @@ public TypeBinding resolveType(BlockScope scope) {
 			CodeSnippetScope localScope = new CodeSnippetScope(scope);
 			MethodBinding privateBinding =
 				this.receiver instanceof CodeSnippetThisReference && ((CodeSnippetThisReference) this.receiver).isImplicit
-					? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, argumentTypes, this)
-					: localScope.getMethod(this.delegateThis.type, this.selector, argumentTypes, this);
+					? localScope.getImplicitMethod((ReferenceBinding)this.delegateThis.type, this.selector, this.argumentTypes, this)
+					: localScope.getMethod(this.delegateThis.type, this.selector, this.argumentTypes, this);
 			if (!privateBinding.isValidBinding()) {
 				if (this.binding.declaringClass == null) {
 					if (this.actualReceiverType instanceof ReferenceBinding) {
 						this.binding.declaringClass = (ReferenceBinding) this.actualReceiverType;
 					} else { // really bad error ....
-						scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);
+						scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
 						return null;
 					}
 				}
@@ -302,7 +296,7 @@ public TypeBinding resolveType(BlockScope scope) {
 				if (this.actualReceiverType instanceof ReferenceBinding) {
 					this.binding.declaringClass = (ReferenceBinding) this.actualReceiverType;
 				} else { // really bad error ....
-					scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, argumentTypes);
+					scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
 					return null;
 				}
 			}
@@ -326,7 +320,7 @@ public TypeBinding resolveType(BlockScope scope) {
 			}			
 		}
 	}
-	if (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, argumentTypes, argsContainCast, this)) {
+	if (checkInvocationArguments(scope, this.receiver, this.actualReceiverType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
 		this.bits |= ASTNode.Unchecked;
 	}
 
@@ -360,3 +354,4 @@ public TypeBinding resolveType(BlockScope scope) {
 	return this.resolvedType;
 }
 }
+
commit f357f309273e0bfe8345ff708d18fa83c6a34931
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sat Oct 25 18:06:26 2014 +0530

    Fixed Bug 437444 - [1.8][compiler] Evaluate alternate integration
    between overload resolution and type inference

20	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConditionalExpressionTest.java
26	0	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
324	48	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
90	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
69	2	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
1	5	org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
28	110	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
176	275	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
20	25	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
9	52	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
9	11	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
21	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
0	42	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InnerInferenceHelper.java
9	46	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
25	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
161	164	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
0	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
0	4	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
38	7	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
25	69	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
9	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
72	301	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
113	135	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
18	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
60	252	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
4	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
6	9	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
4	5	org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConditionalExpressionTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConditionalExpressionTest.java
index c2a0104..2e199d0 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConditionalExpressionTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ConditionalExpressionTest.java
@@ -561,4 +561,24 @@ public class ConditionalExpressionTest extends AbstractRegressionTest {
 			"The method f2() is undefined for the type Y\n" +
 			"----------\n");
 	}
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c113, - Error building JRE8
+	public void test437444_c113() {
+		if (this.complianceLevel < ClassFileConstants.JDK1_8)
+			return;
+		this.runNegativeTest(
+				new String[] {
+						"X.java",
+						"public class X extends Y {\n" +
+						"    public X(Z[] n) {\n" +
+						"        super((n == null) ? null : n.clone());\n" +
+						"    }\n" +
+						"}\n" +
+						"class Y  {\n" +
+						"    public Y(Z[] notifications) {\n" +
+						"    }\n" +
+						"}\n" +
+						"interface Z {}\n",
+				},
+				"");
+	}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
index 4d6d7f4..021575f 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericTypeTest.java
@@ -39621,11 +39621,24 @@ public void test1142() {
 			"}\n", // =================
 		},
 		// compiler results
+		this.complianceLevel < ClassFileConstants.JDK1_8 ? 
 		"----------\n" + /* expected compiler log */
 		"1. ERROR in X.java (at line 5)\n" +
 		"	return compound(asList(a, b));\n" +
 		"	       ^^^^^^^^\n" +
 		"The method compound(Iterable<? extends Comparator<? super T>>) in the type X is not applicable for the arguments (List<Comparator<? extends Object>>)\n" +
+		"----------\n"
+		// 1.8+ ATM, we generate an extra error due to inner poly expression evaluation.
+		:"----------\n" + 
+		"1. ERROR in X.java (at line 5)\n" + 
+		"	return compound(asList(a, b));\n" + 
+		"	       ^^^^^^^^\n" + 
+		"The method compound(Iterable<? extends Comparator<? super T>>) in the type X is not applicable for the arguments (List<Comparator<? extends Object>>)\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 5)\n" + 
+		"	return compound(asList(a, b));\n" + 
+		"	                ^^^^^^^^^^^^\n" + 
+		"Type mismatch: cannot convert from List<Comparator<? extends Object>> to Iterable<? extends Comparator<? super T>>\n" + 
 		"----------\n",
 		// javac options
 		JavacTestOptions.JavacHasABug.JavacBug6573446 /* javac test options */);
@@ -44265,11 +44278,24 @@ public void test1271() {
 					"	}\n" +
 					"}\n", // =================
 			},
+			this.complianceLevel < ClassFileConstants.JDK1_8 ? 
 			"----------\n" +
 			"1. ERROR in X.java (at line 24)\n" +
 			"	put(Integer.class, combine(FUNC2, FUNC1));\n" +
 			"	^^^\n" +
 			"The method put(Class<E>, X.TO<? super E>) in the type X is not applicable for the arguments (Class<Integer>, X.OO<String,Object>)\n" +
+			"----------\n"
+			: // ATM, in 1.8+ we generate an extra error due to inner poly expression resolution after the target type is known.
+			"----------\n" + 
+			"1. ERROR in X.java (at line 24)\n" + 
+			"	put(Integer.class, combine(FUNC2, FUNC1));\n" + 
+			"	^^^\n" + 
+			"The method put(Class<E>, X.TO<? super E>) in the type X is not applicable for the arguments (Class<Integer>, X.OO<String,Object>)\n" + 
+			"----------\n" + 
+			"2. ERROR in X.java (at line 24)\n" + 
+			"	put(Integer.class, combine(FUNC2, FUNC1));\n" + 
+			"	                   ^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type mismatch: cannot convert from X.OO<String,Object> to X.TO<? super E>\n" + 
 			"----------\n");
 }
 //https://bugs.eclipse.org/bugs/show_bug.cgi?id=216686 - variation
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
index 9c37d42..02b2ffd 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/GenericsRegressionTest_1_8.java
@@ -607,6 +607,7 @@ public void testBug424712a() {
 			"    }\n" + 
 			"}\n"
 		},
+		// The extra error with <unknown> reads a bit weird.
 		"----------\n" + 
 		"1. ERROR in X.java (at line 12)\n" + 
 		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
@@ -620,10 +621,15 @@ public void testBug424712a() {
 		"----------\n" + 
 		"3. ERROR in X.java (at line 12)\n" + 
 		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
+		"	                            ^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type mismatch: cannot convert from Collection<Object> to <unknown>\n" + 
+		"----------\n" + 
+		"4. ERROR in X.java (at line 12)\n" + 
+		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
 		"	                                      ^^^^^^^^\n" + 
 		"The target type of this expression must be a functional interface\n" + 
 		"----------\n" + 
-		"4. ERROR in X.java (at line 12)\n" + 
+		"5. ERROR in X.java (at line 12)\n" + 
 		"	Set<Y> rosterSet = (Set<Y>) foo(null, Set::new);\n" + 
 		"	                                      ^^^\n" + 
 		"Cannot instantiate the type Set\n" + 
@@ -1230,7 +1236,12 @@ public void testBug425493() {
 		"	^^^^^^^^^^^^\n" + 
 		"The method addAttribute(Test.Attribute<T>, T) in the type Test is not applicable for the arguments (Test.Attribute<capture#1-of ?>, capture#2-of ?)\n" + 
 		"----------\n" + 
-		"2. ERROR in Test.java (at line 5)\n" + 
+		"2. ERROR in Test.java (at line 3)\n" + 
+		"	addAttribute(java.util.Objects.requireNonNull(attribute, \"\"),\n" + 
+		"	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type mismatch: cannot convert from Test.Attribute<capture#1-of ?> to Test.Attribute<T>\n" + 
+		"----------\n" + 
+		"3. ERROR in Test.java (at line 5)\n" + 
 		"	addAttribute(attribute, attribute.getDefault());\n" + 
 		"	^^^^^^^^^^^^\n" + 
 		"The method addAttribute(Test.Attribute<T>, T) in the type Test is not applicable for the arguments (Test.Attribute<capture#3-of ?>, capture#4-of ?)\n" + 
@@ -1676,6 +1687,11 @@ public void testBug424930c() {
 		"----------\n" + 
 		"1. ERROR in X.java (at line 14)\n" + 
 		"	return new X<>(() -> new ArrayDeque<>(dequeCapacity));\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"The constructor X<S,Deque<S>>(() -> {}) is undefined\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 14)\n" + 
+		"	return new X<>(() -> new ArrayDeque<>(dequeCapacity));\n" + 
 		"	                                      ^^^^^^^^^^^^^\n" + 
 		"Cannot make a static reference to the non-static field dequeCapacity\n" + 
 		"----------\n");
@@ -2047,8 +2063,21 @@ public void testBug427626() {
 			"	}\n" + 
 			"}"
 		},
+		// 8u20 emits just one message inferred type not conforming to upper bound. ECJ's message is actually better.
+		// We used to emit only 1 error here. Here the lambda is broken, so inference fails leading to two messages.			
 		"----------\n" + 
-		"1. ERROR in X.java (at line 13)\n" + 
+		"1. ERROR in X.java (at line 8)\n" + 
+		"	ss.stream().map(s -> {\n" + 
+		"          class L1 {};\n" + 
+		"          class L2 {\n" + 
+		"            void mm(L1 l) {}\n" + 
+		"          }\n" + 
+		"          return new L2().mm(new L1());\n" + 
+		"        }).forEach(e -> System.out.println(e));\n" + 
+		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type mismatch: cannot convert from Stream<Object> to <unknown>\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 13)\n" + 
 		"	return new L2().mm(new L1());\n" + 
 		"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
 		"Cannot return a void result\n" + 
@@ -2520,9 +2549,8 @@ public void testBug429490_comment33() {
             "}\n"
         });
 }
-public void _testBug428811() {
-	// perhaps fail is the correct answer? FIXME: validate!
-	runNegativeTest(
+public void testBug428811() {
+	runConformTest(
 		new String[] {
 			"MoreCollectors.java",
 			"import java.util.AbstractList;\n" + 
@@ -2569,18 +2597,7 @@ public void _testBug428811() {
 			"    }\n" + 
 			"}\n"
 		},
-		"----------\n" + 
-		"1. ERROR in MoreCollectors.java (at line 16)\n" + 
-		"	return Collector.of(ArrayList<T>::new,\n" + 
-		"	                 ^^\n" + 
-		"The method of(ArrayList<T>::new, List<T>::add, (<no type> left, <no type> right) -> {}" + 
-		", ImmutableList::copyOf) is undefined for the type Collector\n" + 
-		"----------\n" + 
-		"2. WARNING in MoreCollectors.java (at line 23)\n" + 
-		"	public static <T> ImmutableList<T> copyOf (Collection<T> c) {\n" + 
-		"	                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-		"The method copyOf(Collection<T>) from the type MoreCollectors.ImmutableList<T> is never used locally\n" + 
-		"----------\n");
+		"[a, b, c]");
 }
 // all exceptions can be inferred to match
 public void testBug429430() {
@@ -2843,6 +2860,7 @@ public void testBug429203() {
 			"	public DTest(Function<T, T> func) { }\n" + 
 			"	\n" + 
 			"	public DTest(DTest<Integer> dti) {}\n" + 
+			"	public DTest() {}\n" + 
 			"	\n" + 
 			"	public static void main(String[] args) {\n" + 
 			"		DTest<String> t1 = new DTest<String>(new DTest<Integer>());\n" + 
@@ -2850,16 +2868,11 @@ public void testBug429203() {
 			"}\n"
 		},
 		"----------\n" + 
-		"1. ERROR in DTest.java (at line 10)\n" + 
+		"1. ERROR in DTest.java (at line 11)\n" + 
 		"	DTest<String> t1 = new DTest<String>(new DTest<Integer>());\n" + 
 		"	                       ^^^^^\n" + 
 		"Redundant specification of type arguments <String>\n" + 
-		"----------\n" + 
-		"2. ERROR in DTest.java (at line 10)\n" + 
-		"	DTest<String> t1 = new DTest<String>(new DTest<Integer>());\n" + 
-		"	                                     ^^^^^^^^^^^^^^^^^^^^\n" + 
-		"The constructor DTest<Integer>() is undefined\n" +
-		"----------\n",
+		"----------\n", 
 		null, true, customOptions);
 }
 public void testBug430296() {
@@ -3042,14 +3055,9 @@ public void testBug433158() {
 			"	}\n" + 
 			"}\n"
 		},
-		"----------\n" + 
-		"1. ERROR in CollectorsMaps.java (at line 20)\n" + 
-		"	p -> p.lhs.stream().map(p::keepingRhs)).collect(\n" + 
-		"	                                        ^^^^^^^\n" + 
-		"The method collect(Collector<? super Object,A,R>) in the type Stream<Object> is not applicable for the arguments (Collector<CollectorsMaps.Pair<String,String>,capture#3-of ?,Map<String,List<String>>>)\n" + 
-		"----------\n");
+		"");
 }
-public void _testBug432626() {
+public void testBug432626() {
 	runConformTest(
 		new String[] {
 			"StreamInterface2.java",
@@ -3116,6 +3124,29 @@ public void _testBug432626() {
 			"}\n"
 		});
 }
+public void testBug432626_reduced() {
+	runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.ArrayList;\n" +
+			"import java.util.HashMap;\n" +
+			"import java.util.Map;\n" +
+			"import java.util.function.Function;\n" +
+			"import java.util.stream.Collector;\n" +
+			"import java.util.stream.Collectors;\n" +
+			"public interface X {\n" +
+			"	static <T, K> Map<K, ArrayList<T>> terminalAsMapToList(Function<? super T, ? extends K> classifier)  {\n" +
+			"		return terminalAsCollected(Collectors.groupingBy(\n" +
+			"			  classifier,\n" +
+			"			  () -> new HashMap<>(),\n" +
+			"			  (Collector<T,ArrayList<T>,ArrayList<T>>) null));\n" +
+			"	}\n" +
+			"	static <T, M> M terminalAsCollected(Collector<T, ?, M> collector) {\n" +
+			"		return null;\n" +
+			"	}\n" +
+			"}\n"
+		});
+}
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=433825 [1.8][compiler] Internal compiler error: NullPointerException in AllocationExpression#resolvePart3
 public void testBug433825() {
 	this.runConformTest(
@@ -3329,14 +3360,14 @@ public void testBug435187() {
 			"}\n"
 		},
 		"----------\n" + 
-		"1. ERROR in ExtractLocalLambda.java (at line 22)\n" + 
-		"	).collect(groupingBy);\n" + 
-		"	  ^^^^^^^\n" + 
-		"The method collect(Collector<? super Object,A,R>) in the type Stream<Object> is not applicable for the arguments (Collector<Map.Entry<String,String>,capture#1-of ?,Map<String,List<String>>>)\n" + 
+		"1. WARNING in ExtractLocalLambda.java (at line 5)\n" + 
+		"	import java.util.function.Function;\n" + 
+		"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"The import java.util.function.Function is never used\n" + 
 		"----------\n");
 }
 public void testBug435767() {
-	runNegativeTest(
+	runConformTest(
 		new String[] {
 			"DummyClass.java",
 			"import java.util.*;\n" +
@@ -3378,17 +3409,7 @@ public void testBug435767() {
 			"	}\n" + 
 			"}\n"
 		},
-		"----------\n" + 
-		"1. ERROR in DummyClass.java (at line 18)\n" + 
-		"	.collect(Collectors.toMap(path -> this.getKey(path), path -> this.getValue(path))));\n" + 
-		"	                                       ^^^^^^\n" + 
-		"The method getKey(String) in the type DummyClass is not applicable for the arguments (Object)\n" + 
-		"----------\n" + 
-		"2. ERROR in DummyClass.java (at line 18)\n" + 
-		"	.collect(Collectors.toMap(path -> this.getKey(path), path -> this.getValue(path))));\n" + 
-		"	                                                                  ^^^^^^^^\n" + 
-		"The method getValue(String) in the type DummyClass is not applicable for the arguments (Object)\n" + 
-		"----------\n");
+		"");
 }
 public void testBug434483() {
 	runConformTest(
@@ -4404,4 +4425,259 @@ public void testBug442245() {
 			"}\n"
 		});
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=439594  [1.8][compiler] nested lambda type incorrectly inferred vs javac
+public void test439594() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java", 
+			"import java.util.ArrayList;\n" +
+			"import java.util.List;\n" +
+			"import java.util.function.Function;\n" +
+			"import java.util.function.Predicate;\n" +
+			"import java.util.stream.Collectors;\n" +
+			"import java.util.stream.Stream;\n" +
+			"public class X {\n" +
+			"	protected static interface IListEntry {\n" +
+			"		public <T> T visitRecordsWithResult(Function<Stream<Record>,T> func);		\n" +
+			"	}\n" +
+			"	protected static final class ImmutableRecord {\n" +
+			"		public ImmutableRecord(Record r) { }\n" +
+			"	}\n" +
+			"	protected static final class Record {}\n" +
+			"	public List<ImmutableRecord> compilesWithEclipseAndJavac() \n" +
+			"	{\n" +
+			"		return visitEntriesWithResult( stream -> {\n" +
+			"			return stream.map( entry -> {\n" +
+			"				final List<ImmutableRecord> result1 = entry.visitRecordsWithResult( stream2 -> stream2\n" +
+			"						.filter( somePredicate() )\n" +
+			"						.map( ImmutableRecord::new )\n" +
+			"						.collect( Collectors.toList() )\n" +
+			"					);	\n" +
+			"				return result1;\n" +
+			"			}).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) );\n" +
+			"		});		\n" +
+			"	}		\n" +
+			"	public List<ImmutableRecord> compilesWithJavacButNotEclipse1() \n" +
+			"	{\n" +
+			"		return visitEntriesWithResult( stream -> {\n" +
+			"			return stream.map( entry -> {\n" +
+			"				return entry.visitRecordsWithResult( stream2 -> stream2\n" +
+			"						.filter( somePredicate() )\n" +
+			"						.map( ImmutableRecord::new )\n" +
+			"						.collect( Collectors.toList() )\n" +
+			"					);	\n" +
+			"			}).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) );\n" +
+			"		});		\n" +
+			"	}		\n" +
+			"	public List<ImmutableRecord> compilesWithJavacButNotEclipse2() \n" +
+			"	{\n" +
+			"		return visitEntriesWithResult( stream -> {\n" +
+			"			return stream.map( entry -> entry.visitRecordsWithResult( stream2 -> stream2\n" +
+			"						.filter( somePredicate() )\n" +
+			"						.map( ImmutableRecord::new )\n" +
+			"						.collect( Collectors.toList() ) )\n" +
+			"			).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) );\n" +
+			"		});		\n" +
+			"	}	\n" +
+			"	public List<ImmutableRecord> compilesWithJavacButNotEclipse3() \n" +
+			"	{\n" +
+			"		return visitEntriesWithResult( stream -> stream.map( entry -> entry.visitRecordsWithResult( stream2 -> stream2\n" +
+			"						.filter( somePredicate() )\n" +
+			"						.map( ImmutableRecord::new )\n" +
+			"						.collect( Collectors.toList() ) )\n" +
+			"			)\n" +
+			"			.flatMap( List::stream )\n" +
+			"			.collect( Collectors.toCollection( ArrayList::new ) )\n" +
+			"		);		\n" +
+			"	}	\n" +
+			"	private static Predicate<Record> somePredicate() {\n" +
+			"		return record -> true;\n" +
+			"	}		\n" +
+			"	private <T> T visitEntriesWithResult(Function<Stream<IListEntry>,T> func) {\n" +
+			"		return func.apply( new ArrayList<IListEntry>().stream() );\n" +
+			"	}\n" +
+			"}\n"
+	},
+	"");
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=433852, [1.8][compiler] Javac rejects type inference results that ECJ accepts
+public void test433852() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java", 
+			"import java.util.Optional;\n" +
+			"import java.util.function.Function;\n" +
+			"import java.util.stream.Stream;\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		System.out.println(test(Stream.of(Stream.of(\"3\"))));\n" +
+			"		System.out.println(test2(Stream.of(Stream.of(\"1\")).skip(1)));\n" +
+			"		System.out.println(test31(Stream.of(Stream.of(\"2\")).skip(1)));\n" +
+			"	}\n" +
+			"	static Optional<Stream<Object>> test(Stream<Stream<String>> s31) {\n" +
+			"		return s31.map(s2 -> s2.map(s1 -> Integer.parseInt(s1))).findAny();\n" +
+			"	}\n" +
+			"	static Object test2(Stream<Stream<String>> s3) {\n" +
+			"		return s3.map(s2 -> s2.map(s1 -> Integer.parseInt(s1))).flatMap(Function.identity()).findAny().orElse(\n" +
+			"		  X.class);\n" +
+			"	}\n" +
+			"	static Stream<Object> test31(Stream<Stream<String>> s3) {\n" +
+			"		return s3.map(s2 -> s2.map(s1 -> Integer.parseInt(s1))).findAny().orElse(Stream.of(new Object()));\n" +
+			"	}\n" +
+			"}\n"
+	},
+	"----------\n" + 
+	"1. ERROR in X.java (at line 11)\n" + 
+	"	return s31.map(s2 -> s2.map(s1 -> Integer.parseInt(s1))).findAny();\n" + 
+	"	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+	"Type mismatch: cannot convert from Optional<Stream<Integer>> to Optional<Stream<Object>>\n" + 
+	"----------\n" + 
+	"2. ERROR in X.java (at line 14)\n" + 
+	"	return s3.map(s2 -> s2.map(s1 -> Integer.parseInt(s1))).flatMap(Function.identity()).findAny().orElse(\n" + 
+	"	                                                                                               ^^^^^^\n" + 
+	"The method orElse(Integer) in the type Optional<Integer> is not applicable for the arguments (Class<X>)\n" + 
+	"----------\n" + 
+	"3. ERROR in X.java (at line 18)\n" + 
+	"	return s3.map(s2 -> s2.map(s1 -> Integer.parseInt(s1))).findAny().orElse(Stream.of(new Object()));\n" + 
+	"	                                                                  ^^^^^^\n" + 
+	"The method orElse(Stream<Integer>) in the type Optional<Stream<Integer>> is not applicable for the arguments (Stream<Object>)\n" + 
+	"----------\n");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=442916,  [1.8][inference] Type Inference is broken for CompletableFuture then-methods  
+public void test442916() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import static java.util.concurrent.CompletableFuture.completedFuture;\n" +
+			"import java.util.Arrays;\n" +
+			"import java.util.concurrent.CompletableFuture;\n" +
+			"public class X {\n" +
+			"    public static CompletableFuture<Integer> cf(int value) {\n" +
+			"		return completedFuture(value);\n" +
+			"    }\n" +
+			"    public static void main(String[] args) {\n" +
+			"		cf(1).thenCompose((xInt) -> cf(2).thenApply((zInt) -> Arrays.asList(xInt, zInt)))\n" +
+			"		.thenAccept((ints) -> {\n" +
+			"			/* !!!! ints is incorrectly inferred to be an Object, but it is List<Integer> */\n" +
+			"			System.out.println(ints.get(0) + ints.get(1)); // should print 3;\n" +
+			"		});\n" +
+			"	}\n" +
+			"}\n"
+		},
+		"3");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=442769, [1.8][compiler] Invalid type inference using Stream  
+public void test442769() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.nio.file.Path;\n" +
+			"import java.nio.file.Paths;\n" +
+			"import java.util.Arrays;\n" +
+			"import java.util.HashMap;\n" +
+			"import java.util.List;\n" +
+			"import java.util.Map;\n" +
+			"import java.util.Map.Entry;\n" +
+			"import java.util.stream.Collector;\n" +
+			"import java.util.stream.Collectors;\n" +
+			"import java.util.stream.Stream;\n" +
+			"import java.io.Serializable;\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		Map<Object, Integer> allocated = new HashMap<>();\n" +
+			"		   Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\") // List<String>\n" +
+			"	          .stream() // Stream<String>\n" +
+			"	          .map(Paths::get) // Stream<Path>\n" +
+			"	          .flatMap(path -> allocated.keySet() // Set<Object>\n" +
+			"	                                    .stream() // Stream<Object>\n" +
+			"	                                    .map(group -> Pair.of(group, path) /*Pair<Object,Path>*/) // Stream<Pair<Object, Path>>\n" +
+			"	          ) // Stream<Object> [FAIL]\n" +
+			"	          .collect(Collectors.toList()) // List<Object>\n" +
+			"	          .forEach(item -> System.out.println(item.getKey() + \": \" + item.getValue())); // Consumer<? super Object>\n" +
+			"	    // with explicit type\n" +
+			"	    Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\") // List<String>\n" +
+			"	          .stream() // Stream<String>\n" +
+			"	          .map(Paths::get) // Stream<Path>\n" +
+			"	          .flatMap(path -> allocated.keySet() // Set<Object>\n" +
+			"	                                    .stream() // Stream<Object>\n" +
+			"	                                    .<Pair<Object,Path>>map(group -> Pair.of(group, path) /*Pair<Object,Path>*/) // Stream<Pair<Object, Path>>\n" +
+			"	          ) // Stream<Pair<Object, Path>>\n" +
+			"	          .collect(Collectors.toList()) // List<Pair<Object, Path>>\n" +
+			"	          .forEach(item -> System.out.println(item.getKey() + \": \" + item.getValue())); // Consumer<? super Pair<Object, Path>>\n" +
+			"	}\n" +
+			"}\n" +
+			"abstract class Pair<L, R> implements Map.Entry<L, R>, Comparable<Pair<L, R>>, Serializable {\n" +
+			"    public static <L, R> Pair<L, R> of(final L left, final R right) {\n" +
+			"        return null;\n" +
+			"    }\n" +
+			"    public final L getKey() {\n" +
+			"        return null;\n" +
+			"    }\n" +
+			"    public R getValue() {\n" +
+		"        return null;\n" +
+			"    }\n" +
+			"}\n"
+		},
+		"");
+}
+// Test allocation expression boxing compatibility
+public void testAllocationBoxingCompatibility() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"public class X  {\n" +
+			"    static <T> int m(T o1, byte o2) {return 1;}       \n" +
+			"    static boolean call() {\n" +
+			"        return m(new Long(12l), new Byte((byte)1)) == 1;\n" +
+			"    }\n" +
+			"\n" +
+			"    public static void main(String argv[]) {\n" +
+			"       System.out.println(call());\n" +
+			"    }\n" +
+			"}\n",
+		}, "true");
+}
+// NPE while building JRE8: https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c113
+public void test437444_c113() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.util.List;\n" +
+			"public class X {\n" +
+			"	final List<String>[] ls = Util.cast(new List<>[] { null });\n" +
+			"	\n" +
+			"}\n" +
+			"class Util {\n" +
+			"	@SuppressWarnings(\"unchecked\")\n" +
+			"	public static <T> T cast(Object x) {\n" +
+			"		return (T) x;\n" +
+			"	}\n" +
+			"}\n",
+		}, 
+		"----------\n" + 
+		"1. ERROR in X.java (at line 3)\n" + 
+		"	final List<String>[] ls = Util.cast(new List<>[] { null });\n" + 
+		"	                                        ^^^^\n" + 
+		"Incorrect number of arguments for type List<E>; it cannot be parameterized with arguments <>\n" + 
+		"----------\n");
+}
+// Error while building JRE8: https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c113
+public void test437444_c113a() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.util.List;\n" +
+			"public class X {\n" +
+			"	final List<String>[] ls = Util.cast(new List<?>[] { null });\n" +
+			"	\n" +
+			"}\n" +
+			"class Util {\n" +
+			"	@SuppressWarnings(\"unchecked\")\n" +
+			"	public static <T> T cast(Object x) {\n" +
+			"		return (T) x;\n" +
+			"	}\n" +
+			"}\n",
+		}, 
+		"");
+}
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
index c878db3..1b2dd9a 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/LambdaExpressionsTest.java
@@ -4163,7 +4163,7 @@ public void test432619a() throws Exception {
 		"OK");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=432682, [1.8][compiler] Type mismatch error with lambda expression
-public void _test432682() throws Exception {
+public void test432682() throws Exception {
 	this.runConformTest(
 		new String[] {
 			"X.java",
@@ -4181,7 +4181,7 @@ public void _test432682() throws Exception {
 			"	}\n" +
 			"}\n"
 		},
-		"OK");
+		"true");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=432520, compiler "duplicate method" bug with lamdas and generic interfaces 
 public void test432520() throws Exception {
@@ -4290,13 +4290,18 @@ public void test430766a() {
 			"----------\n" + 
 			"1. ERROR in X.java (at line 21)\n" + 
 			"	persons.sort(Comparator.comparing(Comparator.nullsLast(Person::<Runnable>isRunnable)));\n" + 
-			"	                                             ^^^^^^^^^\n" + 
-			"The method nullsLast(Comparator<? super T>) in the type Comparator is not applicable for the arguments (Person::<Runnable>isRunnable)\n" + 
+			"	                        ^^^^^^^^^\n" + 
+			"The method comparing(Function<? super T,? extends U>) in the type Comparator is not applicable for the arguments (Comparator<Object>)\n" + 
 			"----------\n" + 
 			"2. ERROR in X.java (at line 21)\n" + 
 			"	persons.sort(Comparator.comparing(Comparator.nullsLast(Person::<Runnable>isRunnable)));\n" + 
+			"	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Type mismatch: cannot convert from Comparator<Object> to Function<? super T,? extends U>\n" + 
+			"----------\n" + 
+			"3. ERROR in X.java (at line 21)\n" + 
+			"	persons.sort(Comparator.comparing(Comparator.nullsLast(Person::<Runnable>isRunnable)));\n" + 
 			"	                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
-			"The type X.Person does not define isRunnable(T, T) that is applicable here\n" + 
+			"The type X.Person does not define isRunnable(Object, Object) that is applicable here\n" + 
 			"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=431190, [1.8] VerifyError when using a method reference
@@ -5048,6 +5053,86 @@ public void test447119e() {
 			},
 			"");
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=432605, [1.8] Incorrect error "The type ArrayList<T> does not define add(ArrayList<T>, Object) that is applicable here"
+public void test432605() {
+	this.runConformTest(
+		new String[] {
+			"X.java", 
+			"import java.util.ArrayList;\n" +
+			"import java.util.HashMap;\n" +
+			"import java.util.function.Function;\n" +
+			"import java.util.function.Supplier;\n" +
+			"import java.util.stream.Collector;\n" +
+			"import java.util.stream.Collectors;\n" +
+			"import java.util.stream.Stream;\n" +
+			"public class X {\n" +
+			"static <T, E extends Exception, K, L, M> M terminalAsMapToList(\n" +
+			"    Function<? super T, ? extends K> classifier,\n" +
+			"    Function<HashMap<K, L>, M> intoMap,\n" +
+			"    Function<ArrayList<T>, L> intoList,\n" +
+			"    Supplier<Stream<T>> supplier,\n" +
+			"    Class<E> classOfE) throws E {\n" +
+			"  	return terminalAsCollected(\n" +
+			"  	  classOfE,\n" +
+			"  	  Collectors.collectingAndThen(\n" +
+			"  	    Collectors.groupingBy(\n" +
+			"  	      classifier,\n" +
+			"  	      HashMap<K, L>::new,\n" +
+			"  	      Collectors.collectingAndThen(\n" +
+			"  	      	// The type ArrayList<T> does not define add(ArrayList<T>, Object) that is applicable here\n" +
+			"  	      	// from ArrayList<T>::add:\n" +
+			"  	        Collector.of(ArrayList<T>::new, ArrayList<T>::add, (ArrayList<T> left, ArrayList<T> right) -> { \n" +
+			"  		        left.addAll(right);\n" +
+			"  		        return left;\n" +
+			"  	        }),\n" +
+			"  	        intoList)),\n" +
+			"  	    intoMap),\n" +
+			"  	  supplier);\n" +
+			"  }\n" +
+			"	static <E extends Exception, T, M> M terminalAsCollected(\n" +
+			"    Class<E> class1,\n" +
+			"    Collector<T, ?, M> collector,\n" +
+			"    Supplier<Stream<T>> supplier) throws E {\n" +
+			"  	try(Stream<T> s = supplier.get()) {\n" +
+			"  		return s.collect(collector);\n" +
+			"  	} catch(RuntimeException e) {\n" +
+			"  		throw unwrapCause(class1, e);\n" +
+			"  	}\n" +
+			"  }\n" +
+			"	static <E extends Exception> E unwrapCause(Class<E> classOfE, RuntimeException e) throws E {\n" +
+			"		Throwable cause = e.getCause();\n" +
+			"		if(classOfE.isInstance(cause) == false) {\n" +
+			"			throw e;\n" +
+			"		}\n" +
+			"		throw classOfE.cast(cause);\n" +
+			"}\n" +
+			"}\n"
+	},
+	"");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=432605, [1.8] Incorrect error "The type ArrayList<T> does not define add(ArrayList<T>, Object) that is applicable here"
+public void testreduced432605() {
+	this.runConformTest(
+		new String[] {
+			"X.java", 
+			"import java.util.ArrayList;\n" +
+			"import java.util.HashMap;\n" +
+			"import java.util.function.Function;\n" +
+			"import java.util.stream.Collector;\n" +
+			"import java.util.stream.Collectors;\n" +
+			"public class X {\n" +
+			"    static <T, K, L, M> void foo() {\n" +
+			"	Collector<T, ?, M> cat = \n" +
+			"            Collectors.collectingAndThen(\n" +
+			"		Collectors.groupingBy((Function<? super T, ? extends K>) null, \n" +
+			"				HashMap<K, L>::new, \n" +
+			"				(Collector<T, ArrayList<T>, L>) null), \n" +
+			"				(Function<HashMap<K, L>, M>) null);\n" +
+			"	}\n" +
+			"}\n"
+	},
+	"");
+}
 public static Class testClass() {
 	return LambdaExpressionsTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
index ebd8049..ead8f60 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NegativeLambdaExpressionsTest.java
@@ -9118,11 +9118,12 @@ public void test442983() {
 			"	}	\n" +
 			"}\n"
 		},
+		// Note: new message aligns better with javac 8u20.
 		"----------\n" + 
 		"1. ERROR in X.java (at line 7)\n" + 
 		"	Function<CL<Integer>, String> v5 = CL::method1;\n" + 
 		"	                                   ^^^^^^^^^^^\n" + 
-		"The type CL does not define method1(CL<Integer>) that is applicable here\n" + 
+		"Cannot make a static reference to the non-static method method1(CL) from the type CL\n" + 
 		"----------\n" + 
 		"2. ERROR in X.java (at line 8)\n" + 
 		"	v5 = t -> t.method1();	\n" + 
@@ -9641,7 +9642,7 @@ public void test444665() {
 	"----------\n");
 }
 // https://bugs.eclipse.org/bugs/show_bug.cgi?id=442446, [1.8][compiler] compiler unable to infer lambda's generic argument types
-public void _test442446() {
+public void test442446() {
 	this.runNegativeTest(
 		new String[] {
 			"X.java", 
@@ -9707,6 +9708,72 @@ public void test432759() {
 	},
 	"");
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c36,  NPE in broken code
+public void test437444() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java", 
+			"import java.util.ArrayList;\n" +
+			"import java.util.List;\n" +
+			"import java.util.stream.Collectors;\n" +
+			"public class X {\n" +
+			"	public static void main(String[] args) {\n" +
+			"		List<Person> roster = new ArrayList<>();\n" +
+			"        Map<String, Person> map = \n" +
+			"            roster\n" +
+			"                .stream()\n" +
+			"                .collect(\n" +
+			"                    Collectors.toMap(\n" +
+			"                        Person::getLast,\n" +
+			"                        Function.identity() \n" +
+			"                    ));\n" +
+			"	}\n" +
+			"}\n" +
+			"class Person {\n" +
+			"}\n" 
+	},
+	"----------\n" + 
+	"1. ERROR in X.java (at line 7)\n" + 
+	"	Map<String, Person> map = \n" + 
+	"	^^^\n" + 
+	"Map cannot be resolved to a type\n" + 
+	"----------\n" + 
+	"2. ERROR in X.java (at line 13)\n" + 
+	"	Function.identity() \n" + 
+	"	^^^^^^^^\n" + 
+	"Function cannot be resolved\n" + 
+	"----------\n");
+}
+// test ground target type with wildcards left in non parameter positions.
+public void testGroundTargetTypeWithWithWildcards() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"class A {}\n" +
+			"class B {}\n" +
+			"class C {}\n" +
+			"class Y extends C {}\n" +
+			"interface I<R, S, T> {\n" +
+			"    T m(R r, S s);\n" +
+			"}\n" +
+			"public class X extends A {\n" +
+			"    Object m(I<? extends A, ? extends B, ? extends C> i) {\n" +
+			"    	return m((X x1, X x2) -> { return new Y(); });\n" +
+			"    }\n" +
+			"}\n",
+		}, 
+		"----------\n" + 
+		"1. ERROR in X.java (at line 10)\n" + 
+		"	return m((X x1, X x2) -> { return new Y(); });\n" + 
+		"	       ^\n" + 
+		"The method m(I<? extends A,? extends B,? extends C>) in the type X is not applicable for the arguments ((X x1, X x2) -> {})\n" + 
+		"----------\n" + 
+		"2. ERROR in X.java (at line 10)\n" + 
+		"	return m((X x1, X x2) -> { return new Y(); });\n" + 
+		"	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+		"Type mismatch: cannot convert from I<X,X,? extends C> to I<? extends A,? extends B,? extends C>\n" + 
+		"----------\n");
+}
 public static Class testClass() {
 	return NegativeLambdaExpressionsTest.class;
 }
diff --git a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
index 1c00cf7..4d3ea1c 100644
--- a/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
+++ b/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullTypeAnnotationTest.java
@@ -6750,6 +6750,7 @@ public void test443467() throws Exception {
 			"}\n" +
 			"}\n",
 		},
+		// Note: we used to emit a duplicate message of 2. Fixed.
 		"----------\n" + 
 		"1. ERROR in BuildIdeMain.java (at line 9)\n" + 
 		"	filter2.map(p -> new Pair<>(updateToFile.get(p), p->ideFiles.get(p)));\n" + 
@@ -6760,11 +6761,6 @@ public void test443467() throws Exception {
 		"	filter2.map(p -> new Pair<>(updateToFile.get(p), p->ideFiles.get(p)));\n" + 
 		"	                                                 ^^^^^^^^^^^^^^^^^^\n" + 
 		"The target type of this expression must be a functional interface\n" + 
-		"----------\n" + 
-		"3. ERROR in BuildIdeMain.java (at line 9)\n" + 
-		"	filter2.map(p -> new Pair<>(updateToFile.get(p), p->ideFiles.get(p)));\n" + 
-		"	                                                 ^^^^^^^^^^^^^^^^^^\n" + 
-		"The target type of this expression must be a functional interface\n" + 
 		"----------\n",
 		new String[]{jfxJar});
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index e7b534a..79fd3b7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -60,10 +60,7 @@ import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PackageBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
 import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;
@@ -655,120 +652,41 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	/**
 	 * After method lookup has produced 'methodBinding' but when poly expressions have been seen as arguments,
 	 * inspect the arguments to trigger another round of resolving with improved target types from the methods parameters.
-	 * If this resolving produces better types for any arguments, update the 'argumentTypes' array in-place as an
-	 * intended side effect that will feed better type information in checkInvocationArguments() and others.
 	 * @param invocation the outer invocation which is being resolved
-	 * @param methodBinding the method produced by lookup (possibly involving type inference).
-	 * @param argumentTypes the argument types as collected from first resolving the invocation arguments and as used for
-	 * 	the method lookup.
-	 * @param scope scope for error reporting
+	 * @param method the method produced by lookup (possibly involving type inference).
+	 * @param argumentTypes the argument types as collected from first resolving the invocation arguments and as used for the method lookup.
+	 * @param scope scope for resolution.
 	 */
-	public static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes, Scope scope) {
-		if (!invocation.innersNeedUpdate())
+	public static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding method, TypeBinding[] argumentTypes, BlockScope scope) {
+		MethodBinding candidateMethod = method.isValidBinding() ? method : method instanceof ProblemMethodBinding ? ((ProblemMethodBinding) method).closestMatch : null;
+		if (candidateMethod == null)
 			return;
-		int problemReason = 0;
-		MethodBinding candidateMethod;
-		if (methodBinding.isValidBinding()) {
-			candidateMethod = methodBinding;
-		} else if (methodBinding instanceof ProblemMethodBinding) {
-			problemReason = methodBinding.problemId();
-			candidateMethod = ((ProblemMethodBinding) methodBinding).closestMatch;
-		} else {
-			candidateMethod = null;
-		}
-		if (candidateMethod != null) {
-			boolean variableArity = candidateMethod.isVarargs();
-			InferenceContext18 infCtx = null;
-			if (candidateMethod instanceof ParameterizedMethodBinding) {
-				infCtx = invocation.getInferenceContext((ParameterizedMethodBinding) candidateMethod);
-				if (infCtx != null) {
-					if (infCtx.stepCompleted != InferenceContext18.TYPE_INFERRED) {
-						// only work in the exact state of TYPE_INFERRED
-						// - below we're not yet ready
-						// - above we're already done-done
-						return;
-					}
-					variableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?
-				}
-			} else if (invocation instanceof AllocationExpression) {
-				if (((AllocationExpression)invocation).suspendedResolutionState != null)
-					return; // not yet ready
+		boolean variableArity = candidateMethod.isVarargs();
+		final TypeBinding[] parameters = candidateMethod.parameters;
+		Expression[] arguments = invocation.arguments();
+		if (variableArity && arguments != null && parameters.length == arguments.length) {
+			if (arguments[arguments.length-1].isCompatibleWith(parameters[parameters.length-1], scope)) {
+				variableArity = false;
 			}
-			
-			final TypeBinding[] parameters = candidateMethod.parameters;
-			Expression[] innerArguments = invocation.arguments();
-			Expression [] arguments = innerArguments;
-			if (infCtx == null && variableArity && arguments != null && parameters.length == arguments.length) { // re-check
-				TypeBinding lastParam = parameters[parameters.length-1];
-				Expression lastArg = arguments[arguments.length-1];
-				if (lastArg.isCompatibleWith(lastParam, null)) {
-					variableArity = false;
-				}
-			}
-			for (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {
-				Expression argument = arguments[i];
-				TypeBinding updatedArgumentType = null;
-				TypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);
-				if (parameterType == null && problemReason != ProblemReasons.NoError)
-					continue; // not much we can do without a target type, assume it only happens after some resolve error
-
-				if (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())
-					continue; // don't update if inner poly has errors
-
-				if (argument instanceof Invocation) {
-					Invocation innerInvocation = (Invocation)argument;
-					MethodBinding binding = innerInvocation.binding(parameterType, true, scope);
-					if (binding instanceof ParameterizedGenericMethodBinding) {
-						ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;
-						InferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);
-						if (innerContext != null) {
-							if (!innerContext.hasResultFor(parameterType)) {
-								argument.setExpectedType(parameterType);
-								MethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);
-								if (!improvedBinding.isValidBinding()) {
-									innerContext.reportInvalidInvocation(innerInvocation, improvedBinding);
-								}
-								if (innerInvocation.updateBindings(improvedBinding, parameterType)) {
-									resolvePolyExpressionArguments(innerInvocation, improvedBinding, scope);
-								}
-							} else if (innerContext.stepCompleted < InferenceContext18.BINDINGS_UPDATED) {
-								innerContext.rebindInnerPolies(parameterizedMethod, innerInvocation);
-							}
-						}
-						continue; // otherwise these have been dealt with during inner method lookup
-					}
-				}
-
-				if (argument.isPolyExpression()) {
-					// poly expressions in an invocation context may need to be resolved now:
-					if (infCtx != null && infCtx.stepCompleted == InferenceContext18.BINDINGS_UPDATED)
-						updatedArgumentType = argument.resolvedType; // in this case argument was already resolved via InferenceContext18.acceptPendingPolyArguments()
-					else
-						updatedArgumentType = argument.checkAgainstFinalTargetType(parameterType, scope);
-
-					if (problemReason == ProblemReasons.NoError // preserve errors
-							&& updatedArgumentType != null					// do we have a relevant update? ...
-							&& !(updatedArgumentType instanceof PolyTypeBinding))
-					{
-						// update the argumentTypes array (supposed to be owned by the calling method)
-						// in order to give better information for subsequent checks
-						argumentTypes[i] = updatedArgumentType;
-					}
+		}
+		for (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {
+			Expression argument = arguments[i];
+			TypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);
+			if (parameterType == null)
+				continue; // not much we can do without a target type, assume it only happens after some resolve error
+			if (argumentTypes[i].isPolyType()) {
+				argument.setExpectedType(parameterType);
+				TypeBinding updatedArgumentType = argument.resolveType(scope); 
+				if (argument instanceof LambdaExpression) {
+					// LE.resolveType may return a valid binding because resolve does not detect structural errors at this point.
+					LambdaExpression lambda = (LambdaExpression) argument;
+					if (!lambda.isCompatibleWith(parameterType, scope) || lambda.hasErrors())
+						continue;
 				}
+				if (updatedArgumentType != null && updatedArgumentType.kind() != Binding.POLY_TYPE)
+					argumentTypes[i] = updatedArgumentType;
 			}
 		}
-		invocation.innerUpdateDone();
-	}
-
-	public static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, Scope scope) {
-		TypeBinding[] argumentTypes = null;
-		Expression[] innerArguments = invocation.arguments();
-		if (innerArguments != null) {
-			argumentTypes = new TypeBinding[innerArguments.length];
-			for (int i = 0; i < innerArguments.length; i++)
-				argumentTypes[i] = innerArguments[i].resolvedType;
-		}
-		resolvePolyExpressionArguments(invocation, methodBinding, argumentTypes, scope);
 	}
 
 	public static void resolveAnnotations(BlockScope scope, Annotation[] sourceAnnotations, Binding recipient) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index 00a4712..f2da510 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -77,30 +77,10 @@ public class AllocationExpression extends Expression implements Invocation {
 
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PMB,IC18>*/ inferenceContexts;
-	protected InnerInferenceHelper innerInferenceHelper;
+	private boolean argsContainCast;
 	public TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	public boolean argumentsHaveErrors;
-
-	/** Record to keep state between different parts of resolution. */
-	ResolutionState suspendedResolutionState;
-	class ResolutionState {
-		BlockScope scope;
-		boolean isDiamond;
-		boolean diamondNeedsDeferring;
-		boolean argsContainCast;
-		boolean cannotInferDiamond; // request the an error be reported in due time
-		boolean hasReportedError;
-
-		ResolutionState(BlockScope scope, boolean isDiamond, boolean diamonNeedsDeferring,
-				boolean argsContainCast, TypeBinding[] argumentTypes)
-		{
-			this.scope = scope;
-			this.isDiamond = isDiamond;
-			this.diamondNeedsDeferring = diamonNeedsDeferring;
-			this.argsContainCast = argsContainCast;
-		}
-	}
-
+	public boolean argumentsHaveErrors = false;
+	
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
 	// check captured variables are initialized in current context (26134)
 	checkCapturedLocalInitializationIfNecessary((ReferenceBinding)this.binding.declaringClass.erasure(), currentScope, flowInfo);
@@ -341,7 +321,6 @@ public TypeBinding resolveType(BlockScope scope) {
 	// Propagate the type checking to the arguments, and check if the constructor is defined.
 	final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
 	final CompilerOptions compilerOptions = scope.compilerOptions();
-	boolean diamondNeedsDeferring = false;
 	long sourceLevel = compilerOptions.sourceLevel;
 	if (this.constant != Constant.NotAConstant) {
 		this.constant = Constant.NotAConstant;
@@ -350,178 +329,155 @@ public TypeBinding resolveType(BlockScope scope) {
 			this.resolvedType = scope.enclosingReceiverType();
 		} else {
 			this.resolvedType = this.type.resolveType(scope, true /* check bounds*/);
-			if (isDiamond && this.typeExpected == null && this.expressionContext == INVOCATION_CONTEXT && sourceLevel >= ClassFileConstants.JDK1_8) {
-				if (this.resolvedType != null && this.resolvedType.isValidBinding())
-					diamondNeedsDeferring = true;
-			}
 		}
-	} else {
-		this.resolvedType = this.type.resolvedType;
-	}
-
-	if (this.type != null) {
-		checkIllegalNullAnnotation(scope, this.resolvedType);
-		checkParameterizedAllocation: {
-			if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
-				ReferenceBinding currentType = (ReferenceBinding)this.resolvedType;
-				if (currentType == null) return currentType;
-				do {
-					// isStatic() is answering true for toplevel types
-					if ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;
-					if (currentType.isRawType()) break checkParameterizedAllocation;
-				} while ((currentType = currentType.enclosingType())!= null);
-				ParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;
-				for (int i = qRef.typeArguments.length - 2; i >= 0; i--) {
-					if (qRef.typeArguments[i] != null) {
-						scope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);
-						break;
+		if (this.type != null) {
+			checkIllegalNullAnnotation(scope, this.resolvedType);
+			checkParameterizedAllocation: {
+				if (this.type instanceof ParameterizedQualifiedTypeReference) { // disallow new X<String>.Y<Integer>()
+					ReferenceBinding currentType = (ReferenceBinding)this.resolvedType;
+					if (currentType == null) return currentType;
+					do {
+						// isStatic() is answering true for toplevel types
+						if ((currentType.modifiers & ClassFileConstants.AccStatic) != 0) break checkParameterizedAllocation;
+						if (currentType.isRawType()) break checkParameterizedAllocation;
+					} while ((currentType = currentType.enclosingType())!= null);
+					ParameterizedQualifiedTypeReference qRef = (ParameterizedQualifiedTypeReference) this.type;
+					for (int i = qRef.typeArguments.length - 2; i >= 0; i--) {
+						if (qRef.typeArguments[i] != null) {
+							scope.problemReporter().illegalQualifiedParameterizedTypeAllocation(this.type, this.resolvedType);
+							break;
+						}
 					}
 				}
 			}
 		}
-	}
-	// will check for null after args are resolved
+		// will check for null after args are resolved
 
-	// resolve type arguments (for generic constructor call)
-	if (this.typeArguments != null) {
-		int length = this.typeArguments.length;
-		this.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;
-		this.genericTypeArguments = new TypeBinding[length];
-		for (int i = 0; i < length; i++) {
-			TypeReference typeReference = this.typeArguments[i];
-			if ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {
-				this.argumentsHaveErrors = true;
+		// resolve type arguments (for generic constructor call)
+		if (this.typeArguments != null) {
+			int length = this.typeArguments.length;
+			this.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5;
+			this.genericTypeArguments = new TypeBinding[length];
+			for (int i = 0; i < length; i++) {
+				TypeReference typeReference = this.typeArguments[i];
+				if ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {
+					this.argumentsHaveErrors = true;
+				}
+				if (this.argumentsHaveErrors && typeReference instanceof Wildcard) {
+					scope.problemReporter().illegalUsageOfWildcard(typeReference);
+				}
 			}
-			if (this.argumentsHaveErrors && typeReference instanceof Wildcard) {
-				scope.problemReporter().illegalUsageOfWildcard(typeReference);
+			if (isDiamond) {
+				scope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);
+				return null;
 			}
-		}
-		if (isDiamond) {
-			scope.problemReporter().diamondNotWithExplicitTypeArguments(this.typeArguments);
-			return null;
-		}
-		if (this.argumentsHaveErrors) {
-			if (this.arguments != null) { // still attempt to resolve arguments
-				for (int i = 0, max = this.arguments.length; i < max; i++) {
-					this.arguments[i].resolveType(scope);
+			if (this.argumentsHaveErrors) {
+				if (this.arguments != null) { // still attempt to resolve arguments
+					for (int i = 0, max = this.arguments.length; i < max; i++) {
+						this.arguments[i].resolveType(scope);
+					}
 				}
+				return null;
 			}
-			return null;
 		}
-	}
 
-	// buffering the arguments' types
-	boolean argsContainCast = false;
-	if (this.arguments != null) {
-		this.argumentsHaveErrors = false;
-		int length = this.arguments.length;
-		this.argumentTypes = new TypeBinding[length];
-		for (int i = 0; i < length; i++) {
-			Expression argument = this.arguments[i];
-			if (argument instanceof CastExpression) {
-				argument.bits |= DisableUnnecessaryCastCheck; // will check later on
-				argsContainCast = true;
-			}
-			argument.setExpressionContext(INVOCATION_CONTEXT);
-			if (this.arguments[i].resolvedType != null) 
-				scope.problemReporter().genericInferenceError("Argument was unexpectedly found resolved", this); //$NON-NLS-1$
-			if ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {
-				this.argumentsHaveErrors = true;
-			}
-			if (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || ((argument instanceof Invocation) && ((Invocation) argument).usesInference()))) {
-				if (this.innerInferenceHelper == null)
-					this.innerInferenceHelper = new InnerInferenceHelper();
+		// buffering the arguments' types
+		if (this.arguments != null) {
+			this.argumentsHaveErrors = false;
+			int length = this.arguments.length;
+			this.argumentTypes = new TypeBinding[length];
+			for (int i = 0; i < length; i++) {
+				Expression argument = this.arguments[i];
+				if (argument instanceof CastExpression) {
+					argument.bits |= DisableUnnecessaryCastCheck; // will check later on
+					this.argsContainCast = true;
+				}
+				argument.setExpressionContext(INVOCATION_CONTEXT);
+				if (this.arguments[i].resolvedType != null) 
+					scope.problemReporter().genericInferenceError("Argument was unexpectedly found resolved", this); //$NON-NLS-1$
+				if ((this.argumentTypes[i] = argument.resolveType(scope)) == null) {
+					this.argumentsHaveErrors = true;
+				}
 			}
-		}
-		if (this.argumentsHaveErrors) {
-			/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.
+			if (this.argumentsHaveErrors) {
+				/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=345359, if arguments have errors, completely bail out in the <> case.
 			   No meaningful type resolution is possible since inference of the elided types is fully tied to argument types. Do
 			   not return the partially resolved type.
-			 */
-			if (isDiamond) {
-				return null; // not the partially cooked this.resolvedType
-			}
-			if (this.resolvedType instanceof ReferenceBinding) {
-				// record a best guess, for clients who need hint about possible constructor match
-				TypeBinding[] pseudoArgs = new TypeBinding[length];
-				for (int i = length; --i >= 0;) {
-					pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
+				 */
+				if (isDiamond) {
+					return null; // not the partially cooked this.resolvedType
 				}
-				this.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);
-				if (this.binding != null && !this.binding.isValidBinding()) {
-					MethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;
-					// record the closest match, for clients who may still need hint about possible method match
-					if (closestMatch != null) {
-						if (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
-							// shouldn't return generic method outside its context, rather convert it to raw method (175409)
-							closestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);
-						}
-						this.binding = closestMatch;
-						MethodBinding closestMatchOriginal = closestMatch.original();
-						if (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {
-							// ignore cases where method is used from within inside itself (e.g. direct recursions)
-							closestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;
+				if (this.resolvedType instanceof ReferenceBinding) {
+					// record a best guess, for clients who need hint about possible constructor match
+					TypeBinding[] pseudoArgs = new TypeBinding[length];
+					for (int i = length; --i >= 0;) {
+						pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
+					}
+					this.binding = scope.findMethod((ReferenceBinding) this.resolvedType, TypeConstants.INIT, pseudoArgs, this, false);
+					if (this.binding != null && !this.binding.isValidBinding()) {
+						MethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;
+						// record the closest match, for clients who may still need hint about possible method match
+						if (closestMatch != null) {
+							if (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
+								// shouldn't return generic method outside its context, rather convert it to raw method (175409)
+								closestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);
+							}
+							this.binding = closestMatch;
+							MethodBinding closestMatchOriginal = closestMatch.original();
+							if (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {
+								// ignore cases where method is used from within inside itself (e.g. direct recursions)
+								closestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;
+							}
 						}
 					}
 				}
+				return this.resolvedType;
 			}
-			return this.resolvedType;
 		}
-	}
-	if (this.resolvedType == null || !this.resolvedType.isValidBinding()) {
-		return null;
-	}
-
-	// null type denotes fake allocation for enum constant inits
-	if (this.type != null && !this.resolvedType.canBeInstantiated()) {
-		scope.problemReporter().cannotInstantiate(this.type, this.resolvedType);
-		return this.resolvedType;
-	}
-	ResolutionState state = new ResolutionState(scope, isDiamond, diamondNeedsDeferring, argsContainCast, this.argumentTypes);
-	if (diamondNeedsDeferring) {
-		this.suspendedResolutionState = state; // resolving to be continued later (via binding(TypeBinding targetType)).
-		return new PolyTypeBinding(this);
-	}
+		if (this.resolvedType == null || !this.resolvedType.isValidBinding()) {
+			return null;
+		}
 
-	if (!resolvePart2(state))
-		return null;
-	return resolvePart3(state);
-}
-
-/** Second part of resolving that may happen multiple times during overload resolution. */
-boolean resolvePart2(ResolutionState state) {
-	// TODO: all information persisted during this method may need to be stored per targetType?
-	if (state.isDiamond) {
-		ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
-		TypeBinding [] inferredTypes = inferElidedTypes((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, state.scope);
-		if (inferredTypes == null) {
-			if (!state.diamondNeedsDeferring) {
-				state.scope.problemReporter().cannotInferElidedTypes(this);
-				state.hasReportedError = true;
-				this.resolvedType = null;
-			} else {
-				state.cannotInferDiamond = true; // defer reporting
+		// null type denotes fake allocation for enum constant inits
+		if (this.type != null && !this.resolvedType.canBeInstantiated()) {
+			scope.problemReporter().cannotInstantiate(this.type, this.resolvedType);
+			return this.resolvedType;
+		}
+		if (isDiamond) {
+			ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
+			ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());
+			if (this.typeExpected == null && compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.expressionContext.definesTargetType()) {
+				this.binding = inferConstructorOfElidedParameterizedType(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
+				if (this.binding == null) {
+					scope.problemReporter().cannotInferElidedTypes(this);
+					return this.resolvedType = null;
+				}
+				return new PolyTypeBinding(this);
+			}
+			TypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
+			if (inferredTypes == null) {
+				scope.problemReporter().cannotInferElidedTypes(this);
+				return this.resolvedType = null;
 			}
-			return false;
+			ReferenceBinding allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
+			this.resolvedType = this.type.resolvedType = allocationType; 
+		}
+	} else {
+		if (isDiamond) {
+			ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
+			ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());
+			TypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
+			if (inferredTypes == null) {
+				scope.problemReporter().cannotInferElidedTypes(this);
+				return this.resolvedType = null;
+			}
+			this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
 		}
-		this.resolvedType = this.type.resolvedType = state.scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
-		state.cannotInferDiamond = false;
- 	}
-	ReferenceBinding receiverType = (ReferenceBinding) this.resolvedType;
-	this.binding = findConstructorBinding(state.scope, this, receiverType, this.argumentTypes);
-	return true;
-}
-
-/** Final part of resolving (once): check and report various error conditions. */
-TypeBinding resolvePart3(ResolutionState state) {
-	if (this.suspendedResolutionState != null && this.suspendedResolutionState.hasReportedError)
-		return this.resolvedType;
-	this.suspendedResolutionState = null;
-	if (state.cannotInferDiamond) {
-		state.scope.problemReporter().cannotInferElidedTypes(this);
-		return this.resolvedType = null;
 	}
+	
 	ReferenceBinding allocationType = (ReferenceBinding) this.resolvedType;
+	this.binding = findConstructorBinding(scope, this, allocationType, this.argumentTypes);
+		
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
 			this.binding.declaringClass = allocationType;
@@ -529,30 +485,29 @@ TypeBinding resolvePart3(ResolutionState state) {
 		if (this.type != null && !this.type.resolvedType.isValidBinding()) {
 			return null;
 		}
-		state.scope.problemReporter().invalidConstructor(this, this.binding);
+		scope.problemReporter().invalidConstructor(this, this.binding);
 		return this.resolvedType;
 	}
 	if ((this.binding.tagBits & TagBits.HasMissingType) != 0) {
-		state.scope.problemReporter().missingTypeInConstructor(this, this.binding);
+		scope.problemReporter().missingTypeInConstructor(this, this.binding);
 	}
-	if (isMethodUseDeprecated(this.binding, state.scope, true)) {
-		state.scope.problemReporter().deprecatedMethod(this.binding, this);
+	if (isMethodUseDeprecated(this.binding, scope, true)) {
+		scope.problemReporter().deprecatedMethod(this.binding, this);
 	}
-	if (checkInvocationArguments(state.scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, state.argsContainCast, this)) {
+	if (checkInvocationArguments(scope, null, allocationType, this.binding, this.arguments, this.argumentTypes, this.argsContainCast, this)) {
 		this.bits |= ASTNode.Unchecked;
 	}
 	if (this.typeArguments != null && this.binding.original().typeVariables == Binding.NO_TYPE_VARIABLES) {
-		state.scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
+		scope.problemReporter().unnecessaryTypeArgumentsForMethodInvocation(this.binding, this.genericTypeArguments, this.typeArguments);
 	}
-	if (!state.isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {
- 		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, state.scope);
+	if (!isDiamond && this.resolvedType.isParameterizedTypeWithActualArguments()) {
+ 		checkTypeArgumentRedundancy((ParameterizedTypeBinding) this.resolvedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
  	}
-	CompilerOptions compilerOptions = state.scope.compilerOptions();
 	if (compilerOptions.isAnnotationBasedNullAnalysisEnabled && (this.binding.tagBits & TagBits.IsNullnessKnown) == 0) {
-		new ImplicitNullAnnotationVerifier(state.scope.environment(), compilerOptions.inheritNullAnnotations)
-				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, state.scope);
+		new ImplicitNullAnnotationVerifier(scope.environment(), compilerOptions.inheritNullAnnotations)
+				.checkImplicitNullAnnotations(this.binding, null/*srcMethod*/, false, scope);
 	}
-	recordExceptionsForEnclosingLambda(state.scope, this.binding.thrownExceptions);
+	recordExceptionsForEnclosingLambda(scope, this.binding.thrownExceptions);
 	return allocationType;
 }
 
@@ -571,7 +526,43 @@ void checkIllegalNullAnnotation(BlockScope scope, TypeBinding allocationType) {
 	}
 }
 
-public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final BlockScope scope) {
+// For allocation expressions, boxing compatibility is same as vanilla compatibility, since java.lang's wrapper types are not generic.
+public boolean isBoxingCompatibleWith(TypeBinding targetType, Scope scope) {
+	return isPolyExpression() ? false : isCompatibleWith(scope.boxing(targetType), scope);
+}
+
+public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {
+	if (this.argumentsHaveErrors || this.binding == null || !this.binding.isValidBinding() || targetType == null || scope == null)
+		return false;
+	TypeBinding allocationType = this.resolvedType;
+	if (isPolyExpression()) {
+		TypeBinding originalExpectedType = this.typeExpected;
+		try {
+			this.typeExpected = targetType;
+			ReferenceBinding genericType = ((ParameterizedTypeBinding) this.resolvedType).genericType();
+			ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType, genericType.typeVariables(), genericType.enclosingType());
+			TypeBinding [] inferredTypes = inferElidedTypes(parameterizedType, this.resolvedType.enclosingType(), this.argumentTypes, scope);
+			if (inferredTypes == null)
+				return false;
+			allocationType = scope.environment().createParameterizedType(genericType, inferredTypes, ((ParameterizedTypeBinding) this.resolvedType).enclosingType());
+		} finally {
+			this.typeExpected = originalExpectedType;
+		}
+	}
+	return allocationType != null && allocationType.isCompatibleWith(targetType, scope);
+}
+
+public MethodBinding inferConstructorOfElidedParameterizedType(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final Scope scope) {
+	// Given the allocation type and the arguments to the constructor, see if we can infer the constructor of the elided parameterized type.
+	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTyps, this);
+	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
+		SyntheticFactoryMethodBinding original = (SyntheticFactoryMethodBinding) factory.original();
+		return original.applyTypeArgumentsOnConstructor(((ParameterizedTypeBinding)factory.returnType).arguments);
+	}
+	return null;
+}
+
+public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTyps, final Scope scope) {
 	/* Given the allocation type and the arguments to the constructor, see if we can synthesize a generic static factory
 	   method that would, given the argument types and the invocation site, manufacture a parameterized object of type allocationType.
 	   If we are successful then by design and construction, the parameterization of the return type of the factory method is identical
@@ -581,17 +572,6 @@ public TypeBinding[] inferElidedTypes(ParameterizedTypeBinding allocationType, R
 	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
 		ParameterizedGenericMethodBinding genericFactory = (ParameterizedGenericMethodBinding) factory;
 		this.inferredReturnType = genericFactory.inferredReturnType;
-		// this is our last chance to inspect the result of the inference that is connected to the throw-away factory binding
-		InferenceContext18 infCtx18 = getInferenceContext(genericFactory);
-		if (infCtx18 != null && infCtx18.stepCompleted == InferenceContext18.BINDINGS_UPDATED) {
-			// refresh argumentTypes from updated bindings in arguments:
-			// (this shouldn't be strictly necessary, as FunctionExpression.isCompatibleWith() should give the same result,
-			//  but it's probably be a good idea to avoid the necessity to call isCompatibleWith() in the first place). 
-			for (int i = 0; i < argumentTyps.length; i++) {
-				if (argumentTyps[i] instanceof PolyTypeBinding)
-					argumentTyps[i] = this.arguments[i].resolvedType;
-			}
-		}
 		return ((ParameterizedTypeBinding)factory.returnType).arguments;
 	}
 	return null;
@@ -699,102 +679,23 @@ public boolean statementExpression() {
 }
 
 //-- interface Invocation: --
-public MethodBinding binding(TypeBinding targetType, boolean reportErrors, Scope scope) {
-	if (this.suspendedResolutionState != null && targetType != null) {
-		setExpectedType(targetType);
-		if (!resolvePart2(this.suspendedResolutionState)) {
-			if (reportErrors && !this.suspendedResolutionState.hasReportedError) {
-				if (this.suspendedResolutionState.cannotInferDiamond)
-					scope.problemReporter().cannotInferElidedTypes(this);
-				else
-					scope.problemReporter().genericInferenceError("constructor is unexpectedly unresolved", this); //$NON-NLS-1$
-				this.suspendedResolutionState.hasReportedError = true;
-			}
-			return null;
-		}
-	}
-	if (reportErrors && this.binding != null && !this.binding.isValidBinding()) {
-		if (this.binding.declaringClass == null)
-			this.binding.declaringClass = (ReferenceBinding) this.resolvedType;
-		if (this.suspendedResolutionState != null) {
-			scope.problemReporter().invalidConstructor(this, this.binding);
-			this.suspendedResolutionState.hasReportedError = true;
-		}
-	}
+public MethodBinding binding(TypeBinding targetType, Scope scope) {
 	return this.binding;
 }
-public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {
-	this.typeExpected = targetType;
-	boolean needsUpdate = this.binding == null || 																// not yet resolved
-			(this.resolvedType != null && targetType != null && !this.resolvedType.isCompatibleWith(targetType));	// previous attempt was wrong
-	if (needsUpdate && this.suspendedResolutionState != null && !this.suspendedResolutionState.hasReportedError) {
-		// Attempt to resolve half resolved diamond
-		resolvePart2(this.suspendedResolutionState);
-	}
-	// confer MessageSend.checkAgainstFinalTargetType(,,):
-	if (this.binding instanceof ParameterizedGenericMethodBinding) {
-		InferenceContext18 ctx = getInferenceContext((ParameterizedMethodBinding) this.binding);
-		if (ctx != null && ctx.stepCompleted < InferenceContext18.TYPE_INFERRED) {
-			this.typeExpected = targetType;
-			MethodBinding updatedBinding = ctx.inferInvocationType(this, (ParameterizedGenericMethodBinding) this.binding);
-			if (updateBindings(updatedBinding, targetType)) {
-				ASTNode.resolvePolyExpressionArguments(this, updatedBinding, scope);
-			}
-		}
-	}
-	if (this.suspendedResolutionState != null) {
-		return resolvePart3(this.suspendedResolutionState);
-	}
-	return this.resolvedType;
-}
 public Expression[] arguments() {
 	return this.arguments;
 }
 
-public boolean updateBindings(MethodBinding updatedBinding, TypeBinding targetType) {
-	boolean hasUpdate = this.binding != updatedBinding;
-	if (this.inferenceContexts != null && this.binding.original() == updatedBinding.original()) {
-		InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.get(this.binding);
-		if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
-			this.inferenceContexts.put(updatedBinding, ctx);
-			// solution may have come from an outer inference, mark now that this (inner) is done (but not deep inners):
-			hasUpdate |= ctx.registerSolution(targetType, updatedBinding);
-		}
-	}
-	this.binding = updatedBinding;
-	this.resolvedType = updatedBinding.declaringClass;
-	return hasUpdate;
-}
 public void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18) {
 	if (this.inferenceContexts == null)
 		this.inferenceContexts = new SimpleLookupTable();
 	this.inferenceContexts.put(method, infCtx18);
-	MethodBinding original = method.original();
-	if (original instanceof SyntheticFactoryMethodBinding) {
-		SyntheticFactoryMethodBinding synthOriginal = (SyntheticFactoryMethodBinding)original;
-		ParameterizedMethodBinding parameterizedCtor = synthOriginal.applyTypeArgumentsOnConstructor(method.typeArguments);
-		this.inferenceContexts.put(parameterizedCtor, infCtx18);
-	}
-}
-public boolean usesInference() {
-	return (this.binding instanceof ParameterizedGenericMethodBinding) 
-			&& getInferenceContext((ParameterizedGenericMethodBinding) this.binding) != null;
 }
 public InferenceContext18 getInferenceContext(ParameterizedMethodBinding method) {
 	if (this.inferenceContexts == null)
 		return null;
 	return (InferenceContext18) this.inferenceContexts.get(method);
 }
-public boolean innersNeedUpdate() {
-	return this.innerInferenceHelper != null;
-}
-public void innerUpdateDone() {
-	this.innerInferenceHelper = null;
-}
-public InnerInferenceHelper innerInferenceHelper() {
-	return this.innerInferenceHelper;
-}
-
 //-- interface InvocationSite: --
 public ExpressionContext getExpressionContext() {
 	return this.expressionContext;
@@ -802,4 +703,4 @@ public ExpressionContext getExpressionContext() {
 public InferenceContext18 freshInferenceContext(Scope scope) {
 	return new InferenceContext18(scope, this.arguments, this);
 }
-}
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index ee31086..7f0ccbf 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -57,7 +57,6 @@ public class ConditionalExpression extends OperatorExpression {
 	private boolean isPolyExpression = false;
 	private TypeBinding originalValueIfTrueType;
 	private TypeBinding originalValueIfFalseType;
-	private BlockScope polyExpressionScope;
 	private boolean use18specifics;
 	public ConditionalExpression(
 		Expression condition,
@@ -464,31 +463,25 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 			if (this.valueIfFalse instanceof CastExpression) this.valueIfFalse.bits |= DisableUnnecessaryCastCheck; // will check later on
 			this.originalValueIfFalseType = this.valueIfFalse.resolveType(scope);
 
-			if (isPolyExpression()) {
-				if (this.expectedType == null) {
-					this.polyExpressionScope = scope; // preserve for eventual resolution/error reporting.
-				}
-			}
-
 			if (conditionType == null || this.originalValueIfTrueType == null || this.originalValueIfFalseType == null)
 				return null;
 		} else {
-			/* Not reached as of now as we don't evaluate conditional expressions multiple times, left in for now.
-			   If in future, we change things so control reaches here, a precondition is that this.expectedType is
-			   the final target type.
-			*/
+
 			if (this.originalValueIfTrueType.kind() == Binding.POLY_TYPE)
 				this.originalValueIfTrueType = this.valueIfTrue.resolveType(scope);
 			if (this.originalValueIfFalseType.kind() == Binding.POLY_TYPE)
 				this.originalValueIfFalseType = this.valueIfFalse.resolveType(scope);
+			
+			if (this.originalValueIfTrueType == null || !this.originalValueIfTrueType.isValidBinding())
+				return this.resolvedType = null;
+			if (this.originalValueIfFalseType == null || !this.originalValueIfFalseType.isValidBinding())
+				return this.resolvedType = null;
 		}
 		if (isPolyExpression()) {
 			if (this.expectedType == null) {
-				this.polyExpressionScope = scope; // preserve for eventual resolution/error reporting.
 				return new PolyTypeBinding(this);
 			}
-			computeConversions(scope, this.expectedType);
-			return this.resolvedType = this.expectedType;
+			return this.resolvedType = computeConversions(scope, this.expectedType) ? this.expectedType : null;
 		}
 		TypeBinding valueIfTrueType = this.originalValueIfTrueType;
 		TypeBinding valueIfFalseType = this.originalValueIfFalseType;
@@ -661,7 +654,8 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return null;
 	}
 
-	protected void computeConversions(BlockScope scope, TypeBinding targetType) {
+	protected boolean computeConversions(BlockScope scope, TypeBinding targetType) {
+		boolean ok = true;
 		if (this.originalValueIfTrueType != null && this.originalValueIfTrueType.isValidBinding()) {
 			if (this.valueIfTrue.isConstantValueOfTypeAssignableToType(this.originalValueIfTrueType, targetType)
 					|| this.originalValueIfTrueType.isCompatibleWith(targetType)) {
@@ -682,6 +676,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				}
 			} else {
 				scope.problemReporter().typeMismatchError(this.originalValueIfTrueType, targetType, this.valueIfTrue, null);
+				ok = false;
 			}
 		}
 		if (this.originalValueIfFalseType != null && this.originalValueIfFalseType.isValidBinding()) {
@@ -704,8 +699,10 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				}
 			} else {
 				scope.problemReporter().typeMismatchError(this.originalValueIfFalseType, targetType, this.valueIfFalse, null);
+				ok = false;
 			}
 		}
+		return ok;
 	}
 
 	public void setExpectedType(TypeBinding expectedType) {
@@ -720,16 +717,9 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 		return this.expressionContext;
 	}
 	
-	public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {
-		// in 1.8 if treated as a poly expression:
-		if (isPolyExpression()) {
-			targetType = targetType.uncapture(this.polyExpressionScope);
-			this.originalValueIfTrueType = this.valueIfTrue.checkAgainstFinalTargetType(targetType, scope);
-			this.originalValueIfFalseType = this.valueIfFalse.checkAgainstFinalTargetType(targetType, scope);
-			computeConversions(this.polyExpressionScope, targetType);
-			this.resolvedType = targetType;
-		}
-		return this.resolvedType;
+	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
+		return this.valueIfTrue.isPertinentToApplicability(typeVariable, method) 
+				&& this.valueIfFalse.isPertinentToApplicability(typeVariable, method); // not perfect.
 	}
 	
 	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
@@ -737,6 +727,11 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 				&& this.valueIfFalse.isPertinentToApplicability(targetType, method);
 	}
 	
+	@Override
+	public boolean isFunctionalType() {
+		return this.valueIfTrue.isFunctionalType() || this.valueIfFalse.isFunctionalType();
+	}
+	
 	public boolean isPolyExpression() throws UnsupportedOperationException {
 		
 		if (!this.use18specifics)
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
index 2434915..a16132a 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java
@@ -56,7 +56,6 @@ import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.TypeConstants;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
-import org.eclipse.jdt.internal.compiler.util.SimpleLookupTable;
 
 public class ExplicitConstructorCall extends Statement implements Invocation {
 
@@ -77,10 +76,6 @@ public class ExplicitConstructorCall extends Statement implements Invocation {
 	// TODO Remove once DOMParser is activated
 	public int typeArgumentsSourceStart;
 
-	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
-	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
-	private InnerInferenceHelper innerInferenceHelper;
-
 	public ExplicitConstructorCall(int accessMode) {
 		this.accessMode = accessMode;
 	}
@@ -394,10 +389,6 @@ public class ExplicitConstructorCall extends Statement implements Invocation {
 					if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
 						argHasError = true;
 					}
-					if (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || ((argument instanceof Invocation) && ((Invocation) argument).usesInference()))) {
-						if (this.innerInferenceHelper == null)
-							this.innerInferenceHelper = new InnerInferenceHelper();
-					}
 				}
 				if (argHasError) {
 					if (receiverType == null) {
@@ -498,56 +489,22 @@ public class ExplicitConstructorCall extends Statement implements Invocation {
 		visitor.endVisit(this, scope);
 	}
 
-	// -- interface Invocation: --
-	public MethodBinding binding(TypeBinding targetType, boolean reportErrors, Scope scope) {
-		if (reportErrors) {
-			if (this.binding == null)
-				scope.problemReporter().genericInferenceError("constructor is unexpectedly unresolved", this); //$NON-NLS-1$
-			else if (!this.binding.isValidBinding())
-				scope.problemReporter().invalidConstructor(this, this.binding);
-		}
+	// -- interface Invocation
+	public MethodBinding binding(TypeBinding targetType, Scope scope) {
 		return this.binding;
 	}
-	public Expression[] arguments() {
-		return this.arguments;
-	}
-	public boolean updateBindings(MethodBinding updatedBinding, TypeBinding targetType) {
-		boolean hasUpdate = this.binding != updatedBinding;
-		if (this.inferenceContexts != null) {
-			InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.removeKey(this.binding);
-			if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
-				this.inferenceContexts.put(updatedBinding, ctx);
-				// solution may have come from an outer inference, mark now that this (inner) is done (but not deep inners):
-				hasUpdate |= ctx.registerSolution(targetType, updatedBinding);
-			}
-		}
-		this.binding = updatedBinding;
-		return hasUpdate;
-	}
+
 	public void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18) {
-		if (this.inferenceContexts == null)
-			this.inferenceContexts = new SimpleLookupTable();
-		this.inferenceContexts.put(method, infCtx18);
+		// Nothing to do.
 	}
+	
 	public InferenceContext18 getInferenceContext(ParameterizedMethodBinding method) {
-		if (this.inferenceContexts == null)
-			return null;
-		return (InferenceContext18) this.inferenceContexts.get(method);
-	}
-	public boolean usesInference() {
-		return (this.binding instanceof ParameterizedGenericMethodBinding) 
-				&& getInferenceContext((ParameterizedGenericMethodBinding) this.binding) != null;
-	}
-	public boolean innersNeedUpdate() {
-		return this.innerInferenceHelper != null;
-	}
-	public void innerUpdateDone() {
-		this.innerInferenceHelper = null;
+		return null;
 	}
-	public InnerInferenceHelper innerInferenceHelper() {
-		return this.innerInferenceHelper;
+	
+	public Expression[] arguments() {
+		return this.arguments;
 	}
-
 	// -- interface InvocationSite: --
 	public InferenceContext18 freshInferenceContext(Scope scope) {
 		return new InferenceContext18(scope, this.arguments, this);
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
index 918b1b4..4068ae0 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java
@@ -959,6 +959,10 @@ public Constant optimizedBooleanConstant() {
 	return this.constant;
 }
 
+public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
+	return true;
+}
+
 public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
 	return true;
 }
@@ -1063,16 +1067,6 @@ public TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTy
 }
 
 /**
- * Once outer contexts have finalized the target type for this expression,
- * perform any checks that might have been delayed previously.
- * @param targetType the final target type (aka expectedType) for this expression.
- * @param scope scope for error reporting
- */
-public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {
-	return this.resolvedType; // subclasses may choose to do real stuff here
-}
-
-/**
  * Returns true if the receiver is forced to be of raw type either to satisfy the contract imposed
  * by a super type or because it *is* raw and the current type has no control over it (i.e the rawness
  * originates from some other file.)
@@ -1164,7 +1158,7 @@ public boolean isCompatibleWith(TypeBinding left, Scope scope) {
 }
 
 public boolean isBoxingCompatibleWith(TypeBinding left, Scope scope) {
-	return isBoxingCompatible(this.resolvedType, left, this, scope);
+	return this.resolvedType != null && isBoxingCompatible(this.resolvedType, left, this, scope);
 }
 
 public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t, Scope scope) {
@@ -1250,4 +1244,8 @@ public boolean statementExpression() {
 public VariableBinding nullAnnotatedVariableBinding(boolean supportTypeAnnotations) {
 	return null;
 }
+
+public boolean isFunctionalType() {
+	return false;
 }
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
index 5ac14f2..52f3ab2 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FunctionalExpression.java
@@ -74,9 +74,8 @@ public abstract class FunctionalExpression extends Expression {
 		super();
 	}
 	
-	// for lambda's and reference expressions boxing compatibility is same as vanilla compatibility.
 	public boolean isBoxingCompatibleWith(TypeBinding targetType, Scope scope) {
-		return isCompatibleWith(targetType, scope);
+		return false;
 	}
 	
 	public void setCompilationResult(CompilationResult compilationResult) {
@@ -107,21 +106,29 @@ public abstract class FunctionalExpression extends Expression {
 		return true; // always as per introduction of part D, JSR 335
 	}
 
-	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
-		if (targetType instanceof TypeVariableBinding) {
-			if (method != null) { // when called from type inference
-				if (((TypeVariableBinding)targetType).declaringElement == method)
-					return false;
-				if (method.isConstructor() && ((TypeVariableBinding)targetType).declaringElement == method.declaringClass)
-					return false;
-			} else { // for internal calls
-				TypeVariableBinding typeVariable = (TypeVariableBinding) targetType;
-				if (typeVariable.declaringElement instanceof MethodBinding)
-					return false;
-			}
+	@Override
+	public boolean isFunctionalType() {
+		return true;
+	}
+	
+	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
+		if (method != null) { // when called from type inference
+			if (typeVariable.declaringElement == method)
+				return false;
+			if (method.isConstructor() && typeVariable.declaringElement == method.declaringClass)
+				return false;
+		} else { // for internal calls
+			if (typeVariable.declaringElement instanceof MethodBinding)
+				return false;
 		}
 		return true;
 	}
+	
+	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
+		if (targetType instanceof TypeVariableBinding)
+			return isPertinentToApplicability((TypeVariableBinding) targetType, method);
+		return true;
+	}
 
 	public TypeBinding invocationTargetType() {
 		if (this.expectedType == null) return null;
@@ -205,11 +212,6 @@ public abstract class FunctionalExpression extends Expression {
 		return null;
 	}
 
-	public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {
-		targetType = targetType.uncapture(this.enclosingScope);
-		return resolveTypeExpecting(this.enclosingScope, targetType);
-	}
-
 	class VisibilityInspector extends TypeBindingVisitor {
 
 		private Scope scope;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InnerInferenceHelper.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InnerInferenceHelper.java
deleted file mode 100644
index 8381b5c..0000000
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/InnerInferenceHelper.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2014 GK Software AG.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     Stephan Herrmann - initial API and implementation
- *******************************************************************************/
-package org.eclipse.jdt.internal.compiler.ast;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
-import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
-
-public class InnerInferenceHelper {
-
-	/** For each candidate method store here the array of argument types if inner inference has improved any during Invocation Type Inference. */
-	private Map<MethodBinding,TypeBinding[]> argTypesPerCandidate = new HashMap<MethodBinding,TypeBinding[]>();
-
-	public void registerInnerResult(MethodBinding method, TypeBinding resolvedType, int argCount, int argIdx) {
-		TypeBinding[] argTypes = this.argTypesPerCandidate.get(method);
-		if (argTypes == null)
-			this.argTypesPerCandidate.put(method, argTypes = new TypeBinding[argCount]);
-		argTypes[argIdx] = resolvedType;
-	}
-	
-	public TypeBinding[] getArgumentTypesForCandidate(MethodBinding candidate, TypeBinding[] plainArgTypes) {
-		TypeBinding[] argTypes = this.argTypesPerCandidate.get(candidate);
-		if (argTypes == null)
-			return plainArgTypes;
-		// fill in any blanks now:
-		for (int i = 0; i < argTypes.length; i++) {
-			if (argTypes[i] == null)
-				argTypes[i] = plainArgTypes[i];
-		}
-		return argTypes;
-	}
-}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
index ac5447f..38dc9dc 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Invocation.java
@@ -19,12 +19,8 @@ import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
 
 /**
- * Abstraction for invocation AST nodes that can trigger 
- * <ul>
- * <li>Invocation Applicability Inferences (18.5.1), and</li> 
- * <li>Invocation Type Inference (18.5.2).</li>
- * </ul>
- */
+ * Abstraction for invocation AST nodes that can trigger overload resolution possibly involving type inference
+*/
 public interface Invocation extends InvocationSite {
 
 	Expression[] arguments();
@@ -33,57 +29,24 @@ public interface Invocation extends InvocationSite {
 	 * Answer the resolved method binding of this invocation.
 	 * If a target type is given, the invocation gets a chance to do repeated method lookup.
 	 * @param targetType the target type of this invocation or null if not yet known
-	 * @param reportErrors if true then this is the last call, if no valid binding can be answered we should report an error
-	 * @param scope if reportErrors is true then this scope can be used for error reporting
+	 * @param scope the scope to use for lookup.
 	 * 
 	 */
-	MethodBinding binding(TypeBinding targetType, boolean reportErrors, Scope scope);
-
+	MethodBinding binding(TypeBinding targetType, Scope scope);
+	
 	/**
 	 * Register the given inference context, which produced the given method as its intermediate result.
 	 * Later when the same method is selected as the most specific method, the inference context
-	 * for this pair (Invocation x MethodBinding) can be looked up using {@link #getExpressionContext()}
+	 * for this pair (Invocation x MethodBinding) can be looked up using {@link #getInferenceContext(ParameterizedMethodBinding)}
 	 * to continue the type inference.
 	 */
 	void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18);
-	
+
 	/**
-	 * Retrieve an inference context for the given method which must have been registered
-	 * using {@link #registerInferenceContext(ParameterizedGenericMethodBinding, InferenceContext18)}.
+	 * Retrieve an inference context for the given method.
 	 * @param method an intermediate resolved candidate for this invocation
-	 * return a suspended inference context or null if none was registered for this method.
+	 * return the associated inference context.
 	 */
 	InferenceContext18 getInferenceContext(ParameterizedMethodBinding method);
 
-	/**
-	 * Answer true if this invocation has determined its binding using inference.
-	 */
-	boolean usesInference();
-	
-	/**
-	 * Where the AST node may hold references to the results of Invocation Applicability Inference,
-	 * this method allows to update those references to the result of Invocation Type Inference.
-	 * Note that potentially more than just the method binding is updated.
-	 * @param updatedBinding the final method binding after full inference
-	 * @param targetType the target type used during Invocation Type Inference
-	 * @return true if an update has happened
-	 */
-	boolean updateBindings(MethodBinding updatedBinding, TypeBinding targetType);
-	
-	/**
-	 * Answer whether the current invocation has inner expressions that still need updating after inference.
-	 */
-	boolean innersNeedUpdate();
-
-	/**
-	 * Mark that updating (the need for which is signaled via {@link #innersNeedUpdate()}) has been done.
-	 */
-	void innerUpdateDone();
-
-	/**
-	 * If this invocation has any poly expressions as arguments, this method answers an inference helper 
-	 * that mediates during overload resolution, even if no actual inference happens for this invocation.
-	 */
-	InnerInferenceHelper innerInferenceHelper();
-	
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
index 58faea9..51cc847 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/LambdaExpression.java
@@ -41,6 +41,7 @@ package org.eclipse.jdt.internal.compiler.ast;
 import static org.eclipse.jdt.internal.compiler.ast.ExpressionContext.INVOCATION_CONTEXT;
 
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -244,6 +245,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				this.argumentTypes[i] = this.arguments[i].type.resolveType(blockScope, true /* check bounds*/);
 		}
 		if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
+			this.resolvedCopies = new HashMap<TypeBinding, LambdaExpression>();
 			return new PolyTypeBinding(this);
 		} 
 		
@@ -321,11 +323,18 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 				expectedSAMType = (ReferenceBinding) this.expectedType;
 			if (expectedSAMType != null)
 				groundType = findGroundTargetType(blockScope, expectedSAMType, argumentsTypeElided);
+			
 			if (groundType != null) {
 				this.descriptor = groundType.getSingleAbstractMethod(blockScope, true);
 				if (!this.descriptor.isValidBinding()) {
 					reportSamProblem(blockScope, this.descriptor);
 				} else {
+					if (groundType != expectedSAMType) { //$IDENTITY-COMPARISON$
+						if (!groundType.isCompatibleWith(expectedSAMType, this.scope)) { // the ground has shifted, are we still on firm grounds ? 
+							blockScope.problemReporter().typeMismatchError(groundType, this.expectedType, this, null); // report deliberately against block scope so as not to blame the lambda.
+							return this.resolvedType = null;
+						}
+					}
 					this.resolvedType = groundType;
 				}
 				// TODO: in which cases do we have to assign this.resolvedType & this.descriptor (with problem bindings) to prevent NPE downstream??
@@ -414,6 +423,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		if (this.body instanceof Expression) {
 			Expression expression = (Expression) this.body;
 			new ReturnStatement(expression, expression.sourceStart, expression.sourceEnd, true).resolve(this.scope); // :-) ;-)
+			this.voidCompatible = this.original.voidCompatible = expression.statementExpression();
 		} else {
 			this.body.resolve(this.scope);
 		}
@@ -730,7 +740,6 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		if (!(left instanceof ReferenceBinding))
 			return false;
 
-		left = left.uncapture(this.enclosingScope);
 		shapeAnalysis: if (!this.shapeAnalysisComplete) {
 			IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
 			final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
@@ -833,6 +842,8 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		return true;
 	}
 
+	private HashMap<TypeBinding, LambdaExpression> resolvedCopies;
+	
 	/**
 	 * Get a resolved copy of this lambda for use by type inference, as to avoid spilling any premature
 	 * type results into the original lambda.
@@ -841,12 +852,21 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 	 * @return a resolved copy of 'this' or null if significant errors where encountered
 	 */
 	public LambdaExpression getResolvedCopyForInferenceTargeting(TypeBinding targetType) {
+		LambdaExpression lambda = this.resolvedCopies.get(targetType);
+		if (lambda == null) {
+			lambda = getResolvedCopyForInferenceTargeting0(targetType);
+			if (lambda != null) {
+				this.resolvedCopies.put(targetType, lambda);
+			}
+		}
+		return lambda;
+	}
+	
+	public LambdaExpression getResolvedCopyForInferenceTargeting0(TypeBinding targetType) {
 		// note: this is essentially a simplified extract from isCompatibleWith(TypeBinding,Scope).
 		if (this.shapeAnalysisComplete && this.binding != null)
 			return this;
 		
-		targetType = targetType.uncapture(this.enclosingScope);
-		// TODO: caching
 		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
 		final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
 		boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
@@ -968,6 +988,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 
 		if (copy != null) { // ==> syntax errors == null
 			copy.original = this;
+			copy.enclosingScope = this.enclosingScope;
 		}
 		return copy;
 	}
@@ -976,7 +997,7 @@ public class LambdaExpression extends FunctionalExpression implements ReferenceC
 		if (this.original == this) // not in overload resolution context.
 			return;
 		if (this.body instanceof Expression) {
-			this.original.valueCompatible = resultType != null && resultType.id != TypeIds.T_void;
+			this.original.valueCompatible = resultType != null && resultType.id == TypeIds.T_void ? false : true;
 			this.original.resultExpressions = new Expression[1];
 			this.original.resultExpressions[0] = expression;
 			return; // void compatibility determined via statementExpression()
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
index 4c4eea2..72952f8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java
@@ -80,6 +80,8 @@ import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.PolyParameterizedGenericMethodBinding;
+import org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;
 import org.eclipse.jdt.internal.compiler.lookup.PolymorphicMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ProblemReasons;
@@ -115,11 +117,10 @@ public class MessageSend extends Expression implements Invocation {
 
 	 // hold on to this context from invocation applicability inference until invocation type inference (per method candidate):
 	private SimpleLookupTable/*<PGMB,InferenceContext18>*/ inferenceContexts;
-	protected InnerInferenceHelper innerInferenceHelper;
 	private boolean receiverIsType;
 	protected boolean argsContainCast;
 	public TypeBinding[] argumentTypes = Binding.NO_PARAMETERS;
-	public boolean argumentsHaveErrors;
+	public boolean argumentsHaveErrors = false;
 	
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
@@ -593,115 +594,112 @@ public StringBuffer printExpression(int indent, StringBuffer output){
 }
 
 public TypeBinding resolveType(BlockScope scope) {
-	// Answer the signature return type
+	// Answer the signature return type, answers PolyTypeBinding if there is at least one generic overloaded candidate that encoded type variables in return type and there is no target type  
 	// Base type promotion
-
-	this.constant = Constant.NotAConstant;
-	long sourceLevel = scope.compilerOptions().sourceLevel;
-	boolean receiverCast = false;
-	if (this.receiver instanceof CastExpression) {
-		this.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
-		receiverCast = true;
-	}
-	if (this.receiver.resolvedType != null)
-		scope.problemReporter().genericInferenceError("Receiver was unexpectedly found resolved", this); //$NON-NLS-1$
-	this.actualReceiverType = this.receiver.resolveType(scope);
-	this.receiverIsType = this.receiver instanceof NameReference && (((NameReference) this.receiver).bits & Binding.TYPE) != 0;
-	if (receiverCast && this.actualReceiverType != null) {
-		 // due to change of declaring class with receiver type, only identity cast should be notified
-		if (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {
-			scope.problemReporter().unnecessaryCast((CastExpression)this.receiver);
+	if (this.constant != Constant.NotAConstant) {
+		this.constant = Constant.NotAConstant;
+		long sourceLevel = scope.compilerOptions().sourceLevel;
+		boolean receiverCast = false;
+		if (this.receiver instanceof CastExpression) {
+			this.receiver.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
+			receiverCast = true;
 		}
-	}
-	// resolve type arguments (for generic constructor call)
-	if (this.typeArguments != null) {
-		int length = this.typeArguments.length;
-		this.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5; // typeChecks all arguments
-		this.genericTypeArguments = new TypeBinding[length];
-		for (int i = 0; i < length; i++) {
-			TypeReference typeReference = this.typeArguments[i];
-			if ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {
-				this.argumentsHaveErrors = true;
-			}
-			if (this.argumentsHaveErrors && typeReference instanceof Wildcard) {
-				scope.problemReporter().illegalUsageOfWildcard(typeReference);
+		this.actualReceiverType = this.receiver.resolveType(scope);
+		this.receiverIsType = this.receiver instanceof NameReference && (((NameReference) this.receiver).bits & Binding.TYPE) != 0;
+		if (receiverCast && this.actualReceiverType != null) {
+			// due to change of declaring class with receiver type, only identity cast should be notified
+			if (TypeBinding.equalsEquals(((CastExpression)this.receiver).expression.resolvedType, this.actualReceiverType)) {
+				scope.problemReporter().unnecessaryCast((CastExpression)this.receiver);
 			}
 		}
-		if (this.argumentsHaveErrors) {
-			if (this.arguments != null) { // still attempt to resolve arguments
-				for (int i = 0, max = this.arguments.length; i < max; i++) {
-					this.arguments[i].resolveType(scope);
+		// resolve type arguments (for generic constructor call)
+		if (this.typeArguments != null) {
+			int length = this.typeArguments.length;
+			this.argumentsHaveErrors = sourceLevel < ClassFileConstants.JDK1_5; // typeChecks all arguments
+			this.genericTypeArguments = new TypeBinding[length];
+			for (int i = 0; i < length; i++) {
+				TypeReference typeReference = this.typeArguments[i];
+				if ((this.genericTypeArguments[i] = typeReference.resolveType(scope, true /* check bounds*/)) == null) {
+					this.argumentsHaveErrors = true;
+				}
+				if (this.argumentsHaveErrors && typeReference instanceof Wildcard) {
+					scope.problemReporter().illegalUsageOfWildcard(typeReference);
 				}
 			}
-			return null;
-		}
-	}
-	// will check for null after args are resolved
-	if (this.arguments != null) {
-		this.argumentsHaveErrors = false; // typeChecks all arguments
-		int length = this.arguments.length;
-		this.argumentTypes = new TypeBinding[length];
-		for (int i = 0; i < length; i++){
-			Expression argument = this.arguments[i];
-			if (this.arguments[i].resolvedType != null) 
-				scope.problemReporter().genericInferenceError("Argument was unexpectedly found resolved", this); //$NON-NLS-1$
-			if (argument instanceof CastExpression) {
-				argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
-				this.argsContainCast = true;
-			}
-			argument.setExpressionContext(INVOCATION_CONTEXT);
-			if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
-				this.argumentsHaveErrors = true;
-			}
-			if (sourceLevel >= ClassFileConstants.JDK1_8) {
-				if (argument.isPolyExpression()
-					|| (argument instanceof Invocation && ((Invocation)argument).usesInference())) {
-					if (this.innerInferenceHelper == null)
-						this.innerInferenceHelper = new InnerInferenceHelper();
+			if (this.argumentsHaveErrors) {
+				if (this.arguments != null) { // still attempt to resolve arguments
+					for (int i = 0, max = this.arguments.length; i < max; i++) {
+						this.arguments[i].resolveType(scope);
+					}
 				}
+				return null;
 			}
 		}
-		if (this.argumentsHaveErrors) {
-			if (this.actualReceiverType instanceof ReferenceBinding) {
-				//  record a best guess, for clients who need hint about possible method match
-				TypeBinding[] pseudoArgs = new TypeBinding[length];
-				for (int i = length; --i >= 0;)
-					pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
-				this.binding =
-					this.receiver.isImplicitThis()
-						? scope.getImplicitMethod(this.selector, pseudoArgs, this)
-						: scope.findMethod((ReferenceBinding) this.actualReceiverType, this.selector, pseudoArgs, this, false);
-				if (this.binding != null && !this.binding.isValidBinding()) {
-					MethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;
-					// record the closest match, for clients who may still need hint about possible method match
-					if (closestMatch != null) {
-						if (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
-							// shouldn't return generic method outside its context, rather convert it to raw method (175409)
-							closestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);
-						}
-						this.binding = closestMatch;
-						MethodBinding closestMatchOriginal = closestMatch.original();
-						if (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {
-							// ignore cases where method is used from within inside itself (e.g. direct recursions)
-							closestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;
+		// will check for null after args are resolved
+		if (this.arguments != null) {
+			this.argumentsHaveErrors = false; // typeChecks all arguments
+			int length = this.arguments.length;
+			this.argumentTypes = new TypeBinding[length];
+			for (int i = 0; i < length; i++){
+				Expression argument = this.arguments[i];
+				if (this.arguments[i].resolvedType != null) 
+					scope.problemReporter().genericInferenceError("Argument was unexpectedly found resolved", this); //$NON-NLS-1$
+				if (argument instanceof CastExpression) {
+					argument.bits |= ASTNode.DisableUnnecessaryCastCheck; // will check later on
+					this.argsContainCast = true;
+				}
+				argument.setExpressionContext(INVOCATION_CONTEXT);
+				if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
+					this.argumentsHaveErrors = true;
+				}
+			}
+			if (this.argumentsHaveErrors) {
+				if (this.actualReceiverType instanceof ReferenceBinding) {
+					//  record a best guess, for clients who need hint about possible method match
+					TypeBinding[] pseudoArgs = new TypeBinding[length];
+					for (int i = length; --i >= 0;)
+						pseudoArgs[i] = this.argumentTypes[i] == null ? TypeBinding.NULL : this.argumentTypes[i]; // replace args with errors with null type
+
+					this.binding = this.receiver.isImplicitThis() ?
+								scope.getImplicitMethod(this.selector, pseudoArgs, this) :
+									scope.findMethod((ReferenceBinding) this.actualReceiverType, this.selector, pseudoArgs, this, false);
+
+					if (this.binding != null && !this.binding.isValidBinding()) {
+						MethodBinding closestMatch = ((ProblemMethodBinding)this.binding).closestMatch;
+						// record the closest match, for clients who may still need hint about possible method match
+						if (closestMatch != null) {
+							if (closestMatch.original().typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
+								// shouldn't return generic method outside its context, rather convert it to raw method (175409)
+								closestMatch = scope.environment().createParameterizedGenericMethod(closestMatch.original(), (RawTypeBinding)null);
+							}
+							this.binding = closestMatch;
+							MethodBinding closestMatchOriginal = closestMatch.original();
+							if (closestMatchOriginal.isOrEnclosedByPrivateType() && !scope.isDefinedInMethod(closestMatchOriginal)) {
+								// ignore cases where method is used from within inside itself (e.g. direct recursions)
+								closestMatchOriginal.modifiers |= ExtraCompilerModifiers.AccLocallyUsed;
+							}
 						}
 					}
 				}
+				return null;
 			}
+		}
+		if (this.actualReceiverType == null) {
+			return null;
+		}
+		// base type cannot receive any message
+		if (this.actualReceiverType.isBaseType()) {
+			scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
 			return null;
 		}
 	}
-	if (this.actualReceiverType == null) {
-		return null;
-	}
-	// base type cannot receive any message
-	if (this.actualReceiverType.isBaseType()) {
-		scope.problemReporter().errorNoMethodFor(this, this.actualReceiverType, this.argumentTypes);
-		return null;
+	
+	TypeBinding methodType = findMethodBinding(scope);
+	if (methodType != null && methodType.isPolyType()) {
+		this.resolvedType = this.binding.returnType.capture(scope, this.sourceEnd);
+		return methodType;
 	}
 
-	findMethodBinding(scope);
-
 	if (!this.binding.isValidBinding()) {
 		if (this.binding.declaringClass == null) {
 			if (this.actualReceiverType instanceof ReferenceBinding) {
@@ -723,6 +721,12 @@ public TypeBinding resolveType(BlockScope scope) {
 		switch (this.binding.problemId()) {
 			case ProblemReasons.Ambiguous :
 				break; // no resilience on ambiguous
+			case ProblemReasons.InferredApplicableMethodInapplicable:
+			case ProblemReasons.InvocationTypeInferenceFailure:
+				// Grabbing the closest match improves error reporting in nested invocation contexts
+				if (this.expressionContext != INVOCATION_CONTEXT)
+					break;
+				//$FALL-THROUGH$
 			case ProblemReasons.NotVisible :
 			case ProblemReasons.NonStaticReferenceInConstructorInvocation :
 			case ProblemReasons.NonStaticReferenceInStaticContext :
@@ -860,16 +864,20 @@ public TypeBinding resolveType(BlockScope scope) {
 				? this.resolvedType
 				: null;
 }
-/**
- * Find the method binding; 
- * if this.innersNeedUpdate allow for two attempts where the first round may stop
- * after applicability checking (18.5.1) to include more information into the final
- * invocation type inference (18.5.2).
- */
-protected void findMethodBinding(BlockScope scope) {
-	this.binding = this.receiver.isImplicitThis()
-			? scope.getImplicitMethod(this.selector, this.argumentTypes, this)
+
+protected TypeBinding findMethodBinding(BlockScope scope) {
+	
+	
+	this.binding = this.receiver.isImplicitThis() ? 
+			scope.getImplicitMethod(this.selector, this.argumentTypes, this) 
 			: scope.getMethod(this.actualReceiverType, this.selector, this.argumentTypes, this);
+
+	if (this.binding == null) // can't happen ? I think we always get a problem binding, anyways.
+		return null;
+	
+	if (this.binding instanceof PolyParameterizedGenericMethodBinding)
+		return new PolyTypeBinding(this);
+	
 	resolvePolyExpressionArguments(this, this.binding, this.argumentTypes, scope);
 	
 	/* There are embedded assumptions in the JLS8 type inference scheme that a successful solution of the type equations results in an
@@ -884,11 +892,8 @@ protected void findMethodBinding(BlockScope scope) {
 	final CompilerOptions compilerOptions = scope.compilerOptions();
 	if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && this.binding instanceof ParameterizedGenericMethodBinding && this.binding.isValidBinding()) {
 		if (!compilerOptions.postResolutionRawTypeCompatibilityCheck)
-			return;
+			return this.binding.returnType;
 		ParameterizedGenericMethodBinding pgmb = (ParameterizedGenericMethodBinding) this.binding;
-		InferenceContext18 ctx = getInferenceContext(pgmb);
-		if (ctx == null || ctx.stepCompleted < InferenceContext18.BINDINGS_UPDATED)
-			return;
 		int length = pgmb.typeArguments == null ? 0 : pgmb.typeArguments.length;
 		boolean sawRawType = false;
 		for (int i = 0;  i < length; i++) {
@@ -897,40 +902,26 @@ protected void findMethodBinding(BlockScope scope) {
 			   does not appear fully hooked up into isCompatibleWith and isEquivalent to everywhere. At the moment, bail out if we see capture.
 			*/   
 			if (pgmb.typeArguments[i].isCapture())
-				return;
+				return this.binding.returnType;
 			if (pgmb.typeArguments[i].isRawType())
 				sawRawType = true;
 		}
 		if (!sawRawType)
-			return;
+			return this.binding.returnType;
 		length = this.arguments == null ? 0 : this.arguments.length;
 		if (length == 0)
-			return;
+			return this.binding.returnType;
 		TypeBinding [] finalArgumentTypes = new TypeBinding[length];
 		for (int i = 0; i < length; i++) {
 			TypeBinding finalArgumentType = this.arguments[i].resolvedType;
 			if (finalArgumentType == null || !finalArgumentType.isValidBinding())  // already sided with the devil.
-				return;
+				return this.binding.returnType;
 			finalArgumentTypes[i] = finalArgumentType; 
 		}
-		if (scope.parameterCompatibilityLevel(this.binding, finalArgumentTypes, false, false) == Scope.NOT_COMPATIBLE)
+		if (scope.parameterCompatibilityLevel(this.binding, finalArgumentTypes, false) == Scope.NOT_COMPATIBLE)
 			this.binding = new ProblemMethodBinding(this.binding.original(), this.binding.selector, finalArgumentTypes, ProblemReasons.NotFound);
 	}
-}
-
-@Override
-public TypeBinding checkAgainstFinalTargetType(TypeBinding targetType, Scope scope) {
-	if (this.binding instanceof ParameterizedGenericMethodBinding) {
-		InferenceContext18 ctx = getInferenceContext((ParameterizedMethodBinding) this.binding);
-		if (ctx != null && ctx.stepCompleted < InferenceContext18.TYPE_INFERRED) {
-			this.expectedType = targetType;
-			MethodBinding updatedBinding = ctx.inferInvocationType(this, (ParameterizedGenericMethodBinding) this.binding);
-			if (updateBindings(updatedBinding, targetType)) {
-				ASTNode.resolvePolyExpressionArguments(this, updatedBinding, scope);
-			}
-		}
-	}
-	return this.resolvedType;
+	return this.binding.returnType;
 }
 
 public void setActualReceiverType(ReferenceBinding receiverType) {
@@ -966,6 +957,44 @@ public boolean isPolyExpression() {
 	 */
 	return isPolyExpression(this.binding);
 }
+
+public boolean isBoxingCompatibleWith(TypeBinding targetType, Scope scope) {
+	if (this.argumentsHaveErrors || this.binding == null || !this.binding.isValidBinding() || targetType == null || scope == null)
+		return false;
+	if (isPolyExpression() && !targetType.isPrimitiveOrBoxedPrimitiveType()) // i.e it is dumb to trigger inference, checking boxing compatibility against say Collector<? super T, A, R>.
+		return false;
+	TypeBinding originalExpectedType = this.expectedType;
+	try {
+		this.expectedType = targetType;
+		// No need to tunnel through overload resolution. this.binding is the MSMB.
+		MethodBinding method = isPolyExpression() ? ParameterizedGenericMethodBinding.computeCompatibleMethod18(this.binding.shallowOriginal(), this.argumentTypes, scope, this) : this.binding;
+		if (method == null || !method.isValidBinding() || method.returnType == null || !method.returnType.isValidBinding())
+			return false;
+		return super.isBoxingCompatible(method.returnType.capture(scope, this.sourceEnd), targetType, this, scope);
+	} finally {
+		this.expectedType = originalExpectedType;
+	}
+}
+
+public boolean isCompatibleWith(TypeBinding targetType, final Scope scope) {
+	if (this.argumentsHaveErrors || this.binding == null || !this.binding.isValidBinding() || targetType == null || scope == null)
+		return false;
+	TypeBinding originalExpectedType = this.expectedType;
+	try {
+		this.expectedType = targetType;
+		// No need to tunnel through overload resolution. this.binding is the MSMB.
+		MethodBinding method = isPolyExpression() ? ParameterizedGenericMethodBinding.computeCompatibleMethod18(this.binding.shallowOriginal(), this.argumentTypes, scope, this) : this.binding;
+		TypeBinding returnType;
+		if (method == null || !method.isValidBinding() || (returnType = method.returnType) == null || !returnType.isValidBinding())
+			return false;
+		if (method == scope.environment().arrayClone)
+			returnType = this.actualReceiverType;
+		return returnType != null && returnType.capture(scope, this.sourceEnd).isCompatibleWith(targetType, scope);
+	} finally {
+		this.expectedType = originalExpectedType;
+	}
+}
+
 /** Variant of isPolyExpression() to be used during type inference, when a resolution candidate exists. */
 public boolean isPolyExpression(MethodBinding resolutionCandidate) {
 	if (this.expressionContext != ASSIGNMENT_CONTEXT && this.expressionContext != INVOCATION_CONTEXT)
@@ -1029,21 +1058,10 @@ public boolean receiverIsImplicitThis() {
 	return this.receiver.isImplicitThis();
 }
 // -- interface Invocation: --
-public MethodBinding binding(TypeBinding targetType, boolean reportErrors, Scope scope) {
-	if (reportErrors) {
-		if (this.binding == null)
-			scope.problemReporter().genericInferenceError("method is unexpectedly unresolved", this); //$NON-NLS-1$
-		else if (!this.binding.isValidBinding())
-			scope.problemReporter().invalidMethod(this, this.binding);
-	}
+public MethodBinding binding(TypeBinding targetType, Scope scope) {
 	return this.binding;
 }
-public Expression[] arguments() {
-	return this.arguments;
-}
-public ExpressionContext getExpressionContext() {
-	return this.expressionContext;
-}
+
 public void registerInferenceContext(ParameterizedGenericMethodBinding method, InferenceContext18 infCtx18) {
 	if (this.inferenceContexts == null)
 		this.inferenceContexts = new SimpleLookupTable();
@@ -1054,32 +1072,11 @@ public InferenceContext18 getInferenceContext(ParameterizedMethodBinding method)
 		return null;
 	return (InferenceContext18) this.inferenceContexts.get(method);
 }
-public boolean usesInference() {
-	return (this.binding instanceof ParameterizedGenericMethodBinding) 
-			&& getInferenceContext((ParameterizedGenericMethodBinding) this.binding) != null;
-}
-public boolean updateBindings(MethodBinding updatedBinding, TypeBinding targetType) {
-	boolean hasUpdate = this.binding != updatedBinding;
-	if (this.inferenceContexts != null) {
-		InferenceContext18 ctx = (InferenceContext18)this.inferenceContexts.removeKey(this.binding);
-		if (ctx != null && updatedBinding instanceof ParameterizedGenericMethodBinding) {
-			this.inferenceContexts.put(updatedBinding, ctx);
-			// solution may have come from an outer inference, mark now that this (inner) is done (but not deep inners):
-			hasUpdate |= ctx.registerSolution(targetType, updatedBinding);
-		}
-	}
-	this.binding = updatedBinding;
-	this.resolvedType = updatedBinding.returnType;
-	return hasUpdate;
-}
-public boolean innersNeedUpdate() {
-	return this.innerInferenceHelper != null;
-}
-public void innerUpdateDone() {
-	this.innerInferenceHelper = null;
+public Expression[] arguments() {
+	return this.arguments;
 }
-public InnerInferenceHelper innerInferenceHelper() {
-	return this.innerInferenceHelper;
+public ExpressionContext getExpressionContext() {
+	return this.expressionContext;
 }
 // -- Interface InvocationSite: --
 public InferenceContext18 freshInferenceContext(Scope scope) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
index 59ffb20..b2fbd3b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/QualifiedAllocationExpression.java
@@ -410,10 +410,6 @@ public class QualifiedAllocationExpression extends AllocationExpression {
 				if ((this.argumentTypes[i] = argument.resolveType(scope)) == null){
 					hasError = true;
 				}
-				if (sourceLevel >= ClassFileConstants.JDK1_8 && (argument.isPolyExpression() || (argument instanceof Invocation && ((Invocation)argument).usesInference()))) {
-					if (this.innerInferenceHelper == null)
-						this.innerInferenceHelper = new InnerInferenceHelper();
-				}
 			}
 		}
 
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index e9465f3..1db2668 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -727,18 +727,6 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 		}
 	}
 
-	public MethodBinding prepareForInferenceResult(Scope scope) {
-		try {
-			setExpressionContext(INVOCATION_CONTEXT);
-			this.binding = null;
-			this.trialResolution = true;
-			resolveType(this.enclosingScope);
-			return this.binding;
-		} finally {
-			this.trialResolution = false;
-		}
-	}
-
 	public boolean isConstructorReference() {
 		return CharOperation.equals(this.selector,  ConstantPool.Init);
 	}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
index d618563..1fc78f1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BlockScope.java
@@ -1034,11 +1034,7 @@ public String toString(int tab) {
 private List trackingVariables; // can be null if no resources are tracked
 /** Used only during analyseCode and only for checking if a resource was closed in a finallyBlock. */
 public FlowInfo finallyInfo;
-public boolean shouldConsultShadowOriginal;
 
-public boolean shouldConsultShadowOriginal() {
-	return this.shouldConsultShadowOriginal;
-}
 /**
  * Register a tracking variable and compute its id.
  */
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 5290623..2110b8b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -104,7 +104,7 @@ class BoundSet {
 				}
 			}
 			if (i == 0)
-				return Binding.NO_TYPES;
+				return simpleUpper != null ? new TypeBinding[] { simpleUpper } : Binding.NO_TYPES;
 			if (i == 1 && simpleUpper != null)
 				return new TypeBinding[] { simpleUpper }; // no nullHints since not a reference type
 			if (i < rights.length)
@@ -469,8 +469,6 @@ class BoundSet {
 			if (!incorporate(context, freshBounds, freshBounds))
 				return false;
 
-			this.captures.clear();
-			
 			// Merge the bounds into one incorporated generation.
 			final int incorporatedLength = this.incorporatedBounds.length;
 			final int unincorporatedLength = freshBounds.length;
@@ -596,7 +594,9 @@ class BoundSet {
 		while (captIter.hasNext()) {
 			Entry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();
 			ParameterizedTypeBinding gAlpha = capt.getKey();
-			ParameterizedTypeBinding gA = capt.getValue();
+			// We come in with capture(gA), we need to work with gA below. It was necessary to establish capture at the call site.
+			ParameterizedTypeBinding cgA = capt.getValue();
+			ParameterizedTypeBinding gA = (ParameterizedTypeBinding) cgA.uncapture(context.scope);
 			ReferenceBinding g = (ReferenceBinding) gA.original();
 			final TypeVariableBinding[] parameters = g.typeVariables();
 			// construct theta = [P1:=alpha1,...]
@@ -615,6 +615,7 @@ class BoundSet {
 				addBounds(pi.getTypeBounds(alpha, theta), context.environment);
 
 				TypeBinding ai = gA.arguments[i];
+				TypeBinding cai = cgA.arguments[i];
 				if (ai instanceof WildcardBinding) {
 					WildcardBinding wildcardBinding = (WildcardBinding)ai;
 					TypeBinding t = wildcardBinding.bound;
@@ -626,7 +627,14 @@ class BoundSet {
 							it = three.sameBounds.iterator();
 							while (it.hasNext()) {
 								TypeBound bound = it.next();
-								if (!(bound.right instanceof InferenceVariable))
+								/* With the expected type's declared type being Collector<? super T, A, R> and gAlpha being Collector<T#0,?#1,List<T#0>#2> and cgA being
+								   Collector<T#0,capture#1-of ?,List<T#0>>, without the constraint reduction below - we will never discover A to be capture#1-of ? and
+								   claim A is jlO. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c24 - #27
+								*/
+								if (!reduceOneConstraint(context, ConstraintTypeFormula.create(bound.right, cai, ReductionResult.SAME)))
+									return false;
+								// Our = reduction transitively adds a new bound that necessitates the check below for capture. 
+								if (!(bound.right instanceof InferenceVariable) && !bound.right.isCapture())
 									return false;
 							}
 						}
@@ -681,6 +689,7 @@ class BoundSet {
 				}
 			}
 		}
+		this.captures.clear();
 		return true;
 	}
 
@@ -970,6 +979,20 @@ class BoundSet {
 		return three.findSingleWrapperType();
 	}
 
+	private TypeBinding applyInstantiations(TypeBinding type) {
+		if (type.isProperType(true))
+			return type;
+	
+		Iterator<InferenceVariable> variableIt = this.boundsPerVariable.keySet().iterator();
+		while (variableIt.hasNext()) {
+			InferenceVariable inferenceVariable = variableIt.next();
+			TypeBinding instantiation = getInstantiation(inferenceVariable, null);
+			if (instantiation != null)
+				type = type.substituteInferenceVariable(inferenceVariable, instantiation);
+		}
+		return type;
+	}
+	
 	// this condition is just way too complex to check it in-line:
 	public boolean condition18_5_2_bullet_3_3_1(InferenceVariable alpha, TypeBinding targetType) {
 		// T is a reference type, but is not a wildcard-parameterized type, and either 
@@ -1005,8 +1028,16 @@ class BoundSet {
 				for (int j=i+1; j<len; j++) {
 					TypeBinding s2 = superBounds.get(j).right;
 					TypeBinding[] supers = superTypesWithCommonGenericType(s1, s2);
-					if (supers != null && !TypeBinding.equalsEquals(supers[0], supers[1]))
-						return true;
+					if (supers != null) {
+						/* HashMap<K#8,V#9> and HashMap<K#8,ArrayList<T>> with an instantiation for V9 = ArrayList<T> already in the 
+						   bound set should not be seen as two different parameterizations of the same generic class or interface.
+						   See https://bugs.eclipse.org/bugs/show_bug.cgi?id=432626 for a test that triggers this condition.
+						*/
+						supers[0] = applyInstantiations(supers[0]);
+						supers[1] = applyInstantiations(supers[1]);
+						if (!TypeBinding.equalsEquals(supers[0], supers[1]))
+							return true;
+					}
 				}
 			}
 		}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 620f466..2820638 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -17,18 +17,13 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import org.eclipse.jdt.internal.compiler.ASTVisitor;
-import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.ExpressionContext;
-import org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
 import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
 import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
-import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;
-import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.SuspendedInferenceRecord;
 
 /**
@@ -56,41 +51,8 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 
 	public Object reduce(InferenceContext18 inferenceContext) throws InferenceFailureException {
 		// JLS 18.2.1
-		proper:
 		if (this.right.isProperType(true)) {
-			TypeBinding exprType = this.left.resolvedType;
-			if (exprType == null) {
-				// if we get here for some kinds of poly expressions (incl. ConditionalExpression),
-				// then other ways for checking compatibility are needed:
-                if (this.left instanceof FunctionalExpression) {
-                    if (this.left instanceof LambdaExpression) {
-                        // cf. NegativeLambdaExpressionTest.test412453()
-                        LambdaExpression copy = ((LambdaExpression) this.left).getResolvedCopyForInferenceTargeting(this.right);
-                        return (copy != null && copy.resolvedType != null && copy.resolvedType.isValidBinding()) ? TRUE : FALSE;
-                    }
-                }
-                return this.left.isCompatibleWith(this.right, inferenceContext.scope) ? TRUE : FALSE;
-			} else if (!exprType.isValidBinding()) {
-				return FALSE;
-			}
-			if (isCompatibleWithInLooseInvocationContext(exprType, this.right, inferenceContext)) {
-				return TRUE;
-			} else if (this.left instanceof AllocationExpression && this.left.isPolyExpression()) {
-				// half-resolved diamond has a resolvedType, but that may not be the final word, try one more step of resolution:
-            	MethodBinding binding = ((AllocationExpression) this.left).binding(this.right, false, null);
-            	return (binding != null && binding.declaringClass.isCompatibleWith(this.right, inferenceContext.scope)) ? TRUE : FALSE;
-            } else if (this.left instanceof Invocation && this.left.isPolyExpression()) {
-            	Invocation invoc = (Invocation) this.left;
-            	MethodBinding binding = invoc.binding(this.right, false, null);
-            	if (binding instanceof ParameterizedGenericMethodBinding) {
-            		ParameterizedGenericMethodBinding method = (ParameterizedGenericMethodBinding) binding;
-					InferenceContext18 leftCtx = invoc.getInferenceContext(method);
-            		if (leftCtx.stepCompleted < InferenceContext18.TYPE_INFERRED) {
-            			break proper; // fall through into nested inference below (not explicit in the spec!)
-            		}
-            	}
-            }
-			return FALSE;
+			return this.left.isCompatibleWith(this.right, inferenceContext.scope) || this.left.isBoxingCompatibleWith(this.right, inferenceContext.scope) ? TRUE : FALSE;
 		}
 		if (!canBePolyExpression(this.left)) {
 			TypeBinding exprType = this.left.resolvedType;
@@ -102,7 +64,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			// - parenthesized expression : these are transparent in our AST
 			if (this.left instanceof Invocation) {
 				Invocation invocation = (Invocation) this.left;
-				MethodBinding previousMethod = invocation.binding(this.right, false, null);
+				MethodBinding previousMethod = invocation.binding(this.right, inferenceContext.scope);
 				if (previousMethod == null)  	// can happen, e.g., if inside a copied lambda with ignored errors
 					return null; 				// -> proceed with no new constraints
 				MethodBinding method = previousMethod;
@@ -127,8 +89,11 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 								return FALSE;
 							return ConstraintTypeFormula.create(exprType, this.right, COMPATIBLE, this.isSoft);
 						}
+						if (innerCtx.stepCompleted >= InferenceContext18.TYPE_INFERRED) {
+							// The constraints and initial bounds that would effectively reduce to b3 are already transferred to current context during C Set construction.
+							return TRUE;
+						}
 						inferenceContext.inferenceKind = innerCtx.inferenceKind;
-						innerCtx.outerContext = inferenceContext;
 					}
 					boolean isDiamond = method.isConstructor() && this.left.isPolyExpression(method);
 					inferInvocationApplicability(inferenceContext, method, argumentTypes, isDiamond, inferenceContext.inferenceKind);
@@ -188,13 +153,8 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				}
 				if (functionType.returnType != TypeBinding.VOID) {
 					TypeBinding r = functionType.returnType;
-					Expression[] exprs;
-					if (lambda.body() instanceof Expression) {
-						exprs = new Expression[] {(Expression)lambda.body()};
-					} else {
-						exprs = lambda.resultExpressions();
-					}
-					for (int i = 0; i < exprs.length; i++) {
+					Expression[] exprs = lambda.resultExpressions();
+					for (int i = 0, length = exprs == null ? 0 : exprs.length; i < length; i++) {
 						Expression expr = exprs[i];
 						if (r.isProperType(true) && expr.resolvedType != null) {
 							TypeBinding exprType = expr.resolvedType;
@@ -217,7 +177,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		return FALSE;
 	}
 
-	public ReferenceBinding findGroundTargetType(InferenceContext18 inferenceContext, BlockScope scope,
+	public static ReferenceBinding findGroundTargetType(InferenceContext18 inferenceContext, BlockScope scope,
 													LambdaExpression lambda, ParameterizedTypeBinding targetTypeWithWildCards)
 	{
 		if (lambda.argumentsTypeElided()) {
@@ -254,11 +214,9 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		MethodBinding functionType = t.getSingleAbstractMethod(inferenceContext.scope, true);
 		if (functionType == null)
 			return FALSE;
-		// potentially-applicable method for the method reference when targeting T (15.13.1),
-		MethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope);
-		if (potentiallyApplicable == null)
-			return FALSE;
+
 		if (reference.isExactMethodReference()) {
+			MethodBinding potentiallyApplicable = reference.getExactMethod(); 
 			List<ConstraintFormula> newConstraints = new ArrayList<ConstraintFormula>();
 			TypeBinding[] p = functionType.parameters;
 			int n = p.length;
@@ -268,6 +226,8 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			if (n == k+1) {
 				newConstraints.add(ConstraintTypeFormula.create(p[0], reference.lhs.resolvedType, COMPATIBLE));
 				offset = 1;
+			} else if (n != k) {
+				return FALSE;
 			}
 			for (int i = offset; i < n; i++)
 				newConstraints.add(ConstraintTypeFormula.create(p[i], pPrime[i-offset], COMPATIBLE));
@@ -276,11 +236,15 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				TypeBinding rAppl = potentiallyApplicable.isConstructor() && !reference.isArrayConstructorReference() ? potentiallyApplicable.declaringClass : potentiallyApplicable.returnType;
 				if (rAppl == TypeBinding.VOID)
 					return FALSE;
-				TypeBinding rPrime = rAppl.capture(inferenceContext.scope, 14); // FIXME capture position??
+				TypeBinding rPrime = rAppl.capture(inferenceContext.scope, reference.sourceEnd);
 				newConstraints.add(ConstraintTypeFormula.create(rPrime, r, COMPATIBLE));
 			}
 			return newConstraints.toArray(new ConstraintFormula[newConstraints.size()]);
 		} else { // inexact
+			MethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope); // // potentially-applicable method for the method reference when targeting T (15.13.1),
+			if (potentiallyApplicable == null)
+				return FALSE;
+			
 			int n = functionType.parameters.length;
 			for (int i = 0; i < n; i++)
 				if (!functionType.parameters[i].isProperType(true))
@@ -299,7 +263,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			TypeBinding compileTypeReturn = original.isConstructor() ? original.declaringClass : original.returnType;
 			if (reference.typeArguments == null
 					&& ((original.typeVariables() != Binding.NO_TYPE_VARIABLES && compileTypeReturn.mentionsAny(original.typeVariables(), -1))
-						|| (original.isConstructor() && original.declaringClass.typeVariables() != Binding.NO_TYPE_VARIABLES)))
+						|| (original.isConstructor() && compileTimeDecl.declaringClass.isRawType())))
 							// not checking r.mentionsAny for constructors, because A::new resolves to the raw type
 							// whereas in fact the type of all expressions of this shape depends on their type variable (if any)
 			{
@@ -321,7 +285,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					inferenceContext.resumeSuspendedInference(prevInvocation);
 				}
 			}
-			TypeBinding rPrime = compileTimeDecl.isConstructor() ? compileTimeDecl.declaringClass : compileTimeDecl.returnType;
+			TypeBinding rPrime = compileTimeDecl.isConstructor() ? compileTimeDecl.declaringClass : compileTimeDecl.returnType.capture(inferenceContext.scope, reference.sourceEnd());
 			if (rPrime.id == TypeIds.T_void)
 				return FALSE;
 			return ConstraintTypeFormula.create(rPrime, r, COMPATIBLE, this.isSoft);
@@ -384,7 +348,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				InferenceVariable[] betas = inferenceContext.addTypeVariableSubstitutions(arguments);
 				ParameterizedTypeBinding gbeta = inferenceContext.environment.createParameterizedType(
 						parameterizedType.genericType(), betas, parameterizedType.enclosingType(), parameterizedType.getTypeAnnotations());
-				inferenceContext.currentBounds.captures.put(gbeta, parameterizedType); // established: both types have nonnull arguments
+				inferenceContext.currentBounds.captures.put(gbeta, parameterizedType.capture(inferenceContext.scope, invocationSite.sourceEnd())); // established: both types have nonnull arguments
 				ConstraintTypeFormula newConstraint = ConstraintTypeFormula.create(gbeta, targetType, COMPATIBLE);
 				return inferenceContext.reduceAndIncorporate(newConstraint);
 			}
@@ -404,7 +368,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					BoundSet solution = inferenceContext.solve(new InferenceVariable[]{alpha});
 					if (solution == null)
 						return false;
-					TypeBinding u = solution.getInstantiation(alpha, null).capture(inferenceContext.scope, invocationSite.sourceStart()); // TODO make position unique?
+					TypeBinding u = solution.getInstantiation(alpha, null).capture(inferenceContext.scope, invocationSite.sourceEnd());
 					ConstraintTypeFormula newConstraint = ConstraintTypeFormula.create(u, targetType, COMPATIBLE);
 					return inferenceContext.reduceAndIncorporate(newConstraint);
 				}
@@ -437,17 +401,9 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					// ii)
 					final TypeBinding r = sam.returnType;
 					LambdaExpression resolved = lambda.getResolvedCopyForInferenceTargeting(this.right);
-					Statement body = resolved != null ? resolved.body() : lambda.body();
-					if (body instanceof Expression) {
-						variables.addAll(new ConstraintExpressionFormula((Expression) body, r, COMPATIBLE).inputVariables(context));
-					} else {
-						// TODO: should I use LambdaExpression.resultExpressions? (is currently private).
-						body.traverse(new ASTVisitor() {
-							public boolean visit(ReturnStatement returnStatement, BlockScope scope) {
-								variables.addAll(new ConstraintExpressionFormula(returnStatement.expression, r, COMPATIBLE).inputVariables(context));
-								return false;
-							}
-						}, (BlockScope)null);
+					Expression[] resultExpressions = resolved != null ? resolved.resultExpressions() : null;
+					for (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {
+						variables.addAll(new ConstraintExpressionFormula(resultExpressions[i], r, COMPATIBLE).inputVariables(context));
 					}
 				}
 				return variables;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
index ca3cc0f..20ba95e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintTypeFormula.java
@@ -13,6 +13,7 @@ package org.eclipse.jdt.internal.compiler.lookup;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.eclipse.jdt.internal.compiler.ast.Invocation;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 
 /**
@@ -311,6 +312,13 @@ class ConstraintTypeFormula extends ConstraintFormula {
 					result[i] = ConstraintTypeFormula.create(subCandidate, intersectingTypes[i], SUBTYPE, this.isSoft);
 				}
 				return result;
+			case Binding.POLY_TYPE:
+				PolyTypeBinding poly = (PolyTypeBinding) superCandidate;
+				Invocation invocation = (Invocation) poly.expression;
+				MethodBinding binding = invocation.binding(subCandidate, scope);
+				if (binding == null || !binding.isValidBinding())
+					return FALSE;
+				return reduceSubType(scope, subCandidate, binding.returnType.capture(scope, invocation.sourceEnd()));
 		}
 		throw new IllegalStateException("Unexpected RHS "+superCandidate); //$NON-NLS-1$
 	}
@@ -347,7 +355,7 @@ class ConstraintTypeFormula extends ConstraintFormula {
 			return true;
 		if (!(cb instanceof ParameterizedTypeBinding)) {
 			// if C is parameterized with its own type variables, there're no more constraints to be created here, otherwise let's fail
-			return isInsignificantParameterized(ca);
+			return ca.isParameterizedWithOwnVariables();
 		}
 		TypeBinding[] bi = ((ParameterizedTypeBinding) cb).arguments;
 		if (cb.isRawType() || bi == null || bi.length == 0)
@@ -357,20 +365,6 @@ class ConstraintTypeFormula extends ConstraintFormula {
 		return true;
 	}
 
-	private boolean isInsignificantParameterized(ParameterizedTypeBinding ca) {
-		TypeVariableBinding[] typeVariables = ca.original().typeVariables();
-		TypeBinding[] typeArguments = ca.arguments;
-		if (typeVariables == null || typeArguments == null)
-			return typeVariables == typeArguments;
-		if (typeVariables.length != typeArguments.length)
-			return false;
-		for (int i = 0; i < typeArguments.length; i++) {
-			if (TypeBinding.notEquals(typeVariables[i], typeArguments[i]))
-				return false;
-		}
-		return true;
-	}
-
 	public boolean equalsEquals (ConstraintTypeFormula that) {
 		return (that != null && this.relation == that.relation && this.isSoft == that.isSoft && 
 					TypeBinding.equalsEquals(this.left, that.left) && TypeBinding.equalsEquals(this.right, that.right));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index 61fbcc0..d4015ed 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -23,16 +23,12 @@ import java.util.Map;
 import java.util.Set;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.FunctionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.Invocation;
 import org.eclipse.jdt.internal.compiler.ast.LambdaExpression;
-import org.eclipse.jdt.internal.compiler.ast.MessageSend;
-import org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching;
 import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
-import org.eclipse.jdt.internal.compiler.ast.Statement;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.util.Sorting;
 
@@ -95,41 +91,9 @@ import org.eclipse.jdt.internal.compiler.util.Sorting;
  * <dt>18.5.4 More Specific Method Inference</dt>
  * <dd><em>Not Yet Implemented</em></dd>
  * </dl>
- * For 18.5.1 and 18.5.2 some high-level control is implemented in
- *  {@link ParameterizedGenericMethodBinding#computeCompatibleMethod(MethodBinding, TypeBinding[], Scope, InvocationSite, int)}.
+ * For 18.5.1 and 18.5.2 high-level control is implemented in
+ *  {@link ParameterizedGenericMethodBinding#computeCompatibleMethod(MethodBinding, TypeBinding[], Scope, InvocationSite)}.
  * <h2>Inference Lifecycle</h2>
- * The separation into 18.5.1 and 18.5.2 causes some complexity:
- * <ul>
- * <li>Calling both parts of inference is directly interwoven with overload resolution. See 
- * {@link ParameterizedGenericMethodBinding#computeCompatibleMethod(MethodBinding, TypeBinding[], Scope, InvocationSite, int)
- * 		PGMB#computeCompatibleMethod()} for the basic <b>protocol</b>.</li>
- * <li>Intermediate <b>state</b> regarding inference must be stored between both phases. Inference is performed with different
- *   inputs for each pair of {@link Invocation} x {@link ParameterizedGenericMethodBinding},
- *    see {@link Invocation#registerInferenceContext(ParameterizedGenericMethodBinding, InferenceContext18) Invocation.registerInferenceContext()} and
- *    {@link Invocation#getInferenceContext(ParameterizedMethodBinding) getInferenceContext()}.<br/>
- *    As part of the lifecycle state, each instance of InferenceContext18 remembers the current {@link #inferenceKind}
- *    and {@link #stepCompleted}.</li>
- * <li><b>Nested inference/resolving</b>: If an invocation argument is a poly expression itself, final resolving of the argument can only happened
- *    after Invocation Type Inference regarding the outer invocation. Outer inference must produce the <b>target type</b> that drives
- *    the inner inference / resolving. Two different protocols are applied:
- *    <ul>
- *    <li>If the inner poly expression is an invocation, inner inference is directly incorporated into
- *      the {@link #currentBounds}, see block inside {@link ConstraintExpressionFormula#reduce(InferenceContext18)}.<br/>
- *      In this case the results of the combined inference need to be applied to all contained inner invocations,
- *      which happens in {@link #rebindInnerPolies(BoundSet, TypeBinding[])}, which must be called whenever
- *      18.5.2 finishes.</li>
- *    <li>If the inner poly expression is a functional expression or a conditional expression no inference variables
- *      exist representing the inner. In this case the final target type is pushed into the inner using
- *      {@link Expression#checkAgainstFinalTargetType(TypeBinding, Scope)}, which, too, is called from 
- *      {@link #rebindInnerPolies(BoundSet, TypeBinding[])}.</li>
- *    <li>For recursively pushing target types into arguments of an invocation
- *    	method {@link ASTNode#resolvePolyExpressionArguments(Invocation, MethodBinding, TypeBinding[], Scope)} exists,
- *    	which is called in two situations: (1) for non-generic outer invocations from MessageSend#findMethodBinding() and
- *    	Statement#findConstructorBinding(); (2) for generic outer invocations from {@link #rebindInnerPolies(BoundSet, TypeBinding[])}.</li>
- *    <li>In some situations invocation arguments that are poly invocations need to be resolved in the middle of overload resolution
- *    	to answer {@link Scope#parameterCompatibilityLevel18} (where the outer invocation did not involve any inference).<br/>
- *    </ul>
- *    Pushing inference results into an inner invocation happens using {@link Invocation#updateBindings(MethodBinding,TypeBinding)}.</li>
  * <li>Decision whether or not an invocation is a <b>variable-arity</b> invocation is made by first attempting
  * 		to solve 18.5.1 in mode {@link #CHECK_LOOSE}. Only if that fails, another attempt is made in mode {@link #CHECK_VARARG}.
  * 		Which of these two attempts was successful is stored in {@link #inferenceKind}.
@@ -165,9 +129,6 @@ public class InferenceContext18 {
 	/** The accumulated type bounds etc. */
 	BoundSet currentBounds;
 
-	/** solution of applicability inference, stored for use as fallback, if invocation type inference fails. */
-	BoundSet storedSolution;
-
 	/** For each candidate target type imposed from the outside store the solution of invocation type inference. */
 	Map<TypeBinding,Solution> solutionsPerTargetType = new HashMap<TypeBinding, Solution>();
 
@@ -187,14 +148,6 @@ public class InferenceContext18 {
 	/** Signals whether any type compatibility makes use of unchecked conversion. */
 	public List<ConstraintFormula> constraintsWithUncheckedConversion;
 
-	// ---
-
-	/** Inner poly invocations which have been included in this inference. */
-	List<InvocationSite> innerPolies = new ArrayList<InvocationSite>();
-	/** Link to an outer inference context, used for bundled error reporting. */
-	public InferenceContext18 outerContext;
-	private ArrayList<MethodBinding> problemMethods;
-
 	Scope scope;
 	LookupEnvironment environment;
 	ReferenceBinding object; // java.lang.Object
@@ -372,7 +325,6 @@ public class InferenceContext18 {
 	}
 
 	/** JLS 18.5.2 Invocation Type Inference 
-	 * <p>Callers are responsible for any post-processing (see {@link #rebindInnerPolies(BoundSet, TypeBinding[])}).</p>
 	 * @param b1 "the bound set produced by reduction in order to demonstrate that m is applicable in 18.5.1"
 	 */
 	public BoundSet inferInvocationType(BoundSet b1, TypeBinding expectedType, InvocationSite invocationSite, MethodBinding method)
@@ -398,9 +350,9 @@ public class InferenceContext18 {
 			}
 			// 4. bullet: assemble C:
 			Set<ConstraintFormula> c = new HashSet<ConstraintFormula>();
-			if (!addConstraintsToC(this.invocationArguments, c, method, this.inferenceKind))
+			if (!addConstraintsToC(this.invocationArguments, c, method, this.inferenceKind, false))
 				return null;
-			// 5. bullet: determine B3 from C
+			// 5. bullet: determine B4 from C
 			while (!c.isEmpty()) {
 				// *
 				Set<ConstraintFormula> bottomSet = findBottomSet(c, allOutputVariables(c));
@@ -450,7 +402,7 @@ public class InferenceContext18 {
 		}
 	}
 
-	private boolean addConstraintsToC(Expression[] exprs, Set<ConstraintFormula> c, MethodBinding method, int inferenceKindForMethod) {
+	private boolean addConstraintsToC(Expression[] exprs, Set<ConstraintFormula> c, MethodBinding method, int inferenceKindForMethod, boolean interleaved) throws InferenceFailureException {
 		TypeBinding[] fs;
 		if (exprs != null) {
 			int k = exprs.length;
@@ -471,127 +423,98 @@ public class InferenceContext18 {
 			for (int i = 0; i < k; i++) {
 				TypeBinding fsi = fs[Math.min(i, p-1)];
 				TypeBinding substF = substitute(fsi);
-				if (!addConstraintsToC_OneExpr(exprs[i], c, fsi, substF, method))
+				if (!addConstraintsToC_OneExpr(exprs[i], c, fsi, substF, method, interleaved))
 					return false;
 	        }
 		}
 		return true;
 	}
 
-	private boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method) {
+	private boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException {
+		
+		// See https://bugs.openjdk.java.net/browse/JDK-8052325 for exclusion of poly expressions targeting proper types. CEF.reduce validates 
+		// that they are compatible in a loose invocation context against the target type. They contribute nothing further to solving the formulas.
+		if (substF.isProperType(true))
+			return true;
+		
 		// For all i (1  i  k), if ei is not pertinent to applicability, the set contains ei   Fi.
 		if (!expri.isPertinentToApplicability(fsi, method)) {
 			c.add(new ConstraintExpressionFormula(expri, substF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT));
 		}
 		if (expri instanceof FunctionalExpression) {
 			c.add(new ConstraintExceptionFormula((FunctionalExpression) expri, substF));
+			if (expri instanceof LambdaExpression) {
+				LambdaExpression lambda = (LambdaExpression) expri;
+				BlockScope skope = lambda.enclosingScope;
+				if (substF.isFunctionalInterface(skope)) { // could be an inference variable.
+					ReferenceBinding t = (ReferenceBinding) substF;
+					ParameterizedTypeBinding withWildCards = InferenceContext18.parameterizedWithWildcard(t);
+					if (withWildCards != null) {
+						t = ConstraintExpressionFormula.findGroundTargetType(this, skope, lambda, withWildCards);
+					}
+					MethodBinding functionType;
+					if (t != null && (functionType = t.getSingleAbstractMethod(skope, true)) != null && (lambda = lambda.getResolvedCopyForInferenceTargeting(t)) != null) {
+						TypeBinding r = functionType.returnType;
+						Expression[] resultExpressions = lambda.resultExpressions();
+						for (int i = 0, length = resultExpressions == null ? 0 : resultExpressions.length; i < length; i++) {
+							Expression resultExpression = resultExpressions[i];
+							if (!addConstraintsToC_OneExpr(resultExpression, c, r.original(), r, method, true))
+								return false;
+						}
+					}
+				}
+			}
 		} else if (expri instanceof Invocation && expri.isPolyExpression()) {
 			Invocation invocation = (Invocation) expri;
-			MethodBinding innerMethod = invocation.binding(null, false, null);
+			MethodBinding innerMethod = invocation.binding(substF, this.scope);
+			if (innerMethod == null)
+				return true; 		  // -> proceed with no new C set elements.
+			
+			if (interleaved) {
+				MethodBinding shallowMethod = innerMethod.shallowOriginal();
+				SuspendedInferenceRecord prevInvocation = enterPolyInvocation(invocation, invocation.arguments());
+				try {
+					Expression[] arguments = invocation.arguments();
+					TypeBinding[] argumentTypes = arguments == null ? Binding.NO_PARAMETERS : new TypeBinding[arguments.length];
+					for (int i = 0; i < argumentTypes.length; i++)
+						argumentTypes[i] = arguments[i].resolvedType;
+					if (innerMethod instanceof ParameterizedGenericMethodBinding) {
+						InferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) innerMethod);
+						this.inferenceKind = innerCtx.inferenceKind;
+					}
+					inferInvocationApplicability(shallowMethod, argumentTypes, shallowMethod.isConstructor());
+					if (!ConstraintExpressionFormula.inferPolyInvocationType(this, invocation, substF, shallowMethod))
+						return false;
+				} finally {
+					resumeSuspendedInference(prevInvocation);
+				}
+			}
+			int applicabilityKind = CHECK_LOOSE;  // FIXME, for <> resolving to a non-generic method, this need to be computed.
 			if (innerMethod instanceof ParameterizedGenericMethodBinding) {
 				InferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedMethodBinding) innerMethod);
-				if (innerCtx != null) { // otherwise innerMethod does not participate in inference
-					return addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), innerCtx.inferenceKind);
+				if (innerCtx != null) {
+					applicabilityKind = innerCtx.inferenceKind;
 				}
 			}
+			return addConstraintsToC(invocation.arguments(), c, innerMethod.genericMethod(), applicabilityKind, interleaved);
 		} else if (expri instanceof ConditionalExpression) {
 			ConditionalExpression ce = (ConditionalExpression) expri;
-			return addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method)
-				 && addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method);
+			return addConstraintsToC_OneExpr(ce.valueIfTrue, c, fsi, substF, method, interleaved)
+					&& addConstraintsToC_OneExpr(ce.valueIfFalse, c, fsi, substF, method, interleaved);
 		}
 		return true;
 	}
 
-	/**
-	 * Simplified API to perform Invocation Type Inference (JLS 18.5.2)
-	 * and perform subsequent steps: bound check, rebinding of inner poly expressions,
-	 * and creating of a problem method binding if needed.
-	 * Should only be called if the inference has not yet finished.
-	 * @param invocation invocation being inferred
-	 * @param argumentTypes arguments being passed into the invocation
-	 * @param method current candidate method binding for this invocation
-	 * @return a valid method binding with updated type parameters,
-	 * 	or a problem method binding signaling either inference failure or a bound mismatch.
-	 */
-	/*@NonNull*/ MethodBinding inferInvocationType(Invocation invocation, TypeBinding[] argumentTypes, ParameterizedGenericMethodBinding method) {
-		// TODO optimize: if outerContext exists and is resolved, we probably don't need to infer again.
-		TypeBinding targetType = invocation.invocationTargetType();
-		ParameterizedGenericMethodBinding finalMethod = null;
-		ParameterizedGenericMethodBinding methodToCheck = method;
-		
-		boolean haveProperTargetType = targetType != null && targetType.isProperType(true);
-		if (haveProperTargetType || !invocation.getExpressionContext().definesTargetType()) {
-			MethodBinding original = method.originalMethod;
-			Solution solution = this.solutionsPerTargetType.get(targetType);
-			BoundSet result = solution != null ? solution.bounds : null;
-			if (result == null) {
-				// start over from a previous candidate but discard its type variable instantiations
-				// TODO: should we retain any instantiations of type variables not owned by the method? 
-				try {
-					result = inferInvocationType(this.currentBounds, targetType, invocation, original);
-				} catch (InferenceFailureException e) {
-					// no solution, but do more checks below
-				}
-			}
-			if (result != null) {
-				TypeBinding[] solutions = getSolutions(original.typeVariables(), invocation, result);
-				if (solutions != null) {
-					finalMethod = this.environment.createParameterizedGenericMethod(original, solutions);
-					if (this.scope.compilerOptions().isAnnotationBasedNullAnalysisEnabled)
-						NullAnnotationMatching.checkForContraditions(finalMethod, invocation, this.scope);
-					invocation.registerInferenceContext(finalMethod, this);
-					this.solutionsPerTargetType.put(targetType, new Solution(finalMethod, result));
-				}
-			}
-			if (finalMethod != null)
-				methodToCheck = finalMethod;
-		} else {
-			finalMethod = method;
-		}
-		
-		MethodBinding problemMethod = methodToCheck.boundCheck18(this.scope, argumentTypes);
-		if (problemMethod != null)
-			return problemMethod;
-
-		if (!haveProperTargetType && invocation.getExpressionContext().definesTargetType())
-			return method; // still not ready!
-
-		if (finalMethod != null) {
-			if (rebindInnerPolies(finalMethod, invocation))
-				return finalMethod;
-		}
-		return getReturnProblemMethodIfNeeded(targetType, method);
-	}
-
-	/**
-	 * Simplified API to perform Invocation Type Inference (JLS 18.5.2)
-	 * and perform subsequent steps: bound check, rebinding of inner poly expressions,
-	 * and creating of a problem method binding if needed.
-	 * Should only be called if the inference has not yet finished.
-	 * Version used for inner invocations, where argument types need to be extracted
-	 * from actual invocation arguments.
-	 * @param invocation invocation being inferred
-	 * @param method current candidate method binding for this invocation
-	 * @return a valid method binding with updated type parameters,
-	 * 	or a problem method binding signaling either inference failure or a bound mismatch.
-	 */
-	public /*@NonNull*/ MethodBinding inferInvocationType(Invocation invocation, ParameterizedGenericMethodBinding method) {
-		TypeBinding[] argumentTypes = null;
-		Expression[] arguments = invocation.arguments();
-		if (arguments != null) {
-			argumentTypes = new TypeBinding[arguments.length];
-			for (int i = 0; i < arguments.length; i++)
-				argumentTypes[i] = arguments[i].resolvedType;
-		}
-		return inferInvocationType(invocation, argumentTypes, method);
-	}
-
 	public boolean hasResultFor(TypeBinding targetType) {
 		if (targetType == null)
 			return this.stepCompleted >= TYPE_INFERRED;
 		else
 			return this.solutionsPerTargetType.containsKey(targetType);
 	}
+	
+	public Solution getResultFor(TypeBinding targetType) {
+		return this.solutionsPerTargetType.get(targetType);
+	}
 
 	public boolean registerSolution(TypeBinding targetType, MethodBinding updatedBinding) {
 		Solution solution = this.solutionsPerTargetType.get(targetType);
@@ -1366,8 +1289,6 @@ public class InferenceContext18 {
 		this.invocationArguments = innerArguments;
 		this.currentInvocation = invocation;
 		
-		// schedule for re-binding the inner after inference success:
-		this.innerPolies.add(invocation);
 		return record;
 	}
 	
@@ -1397,145 +1318,6 @@ public class InferenceContext18 {
 		this.inferenceKind = record.inferenceKind;
 	}
 
-	public boolean rebindInnerPolies(MethodBinding method, InvocationSite site) {
-		BoundSet bounds = this.currentBounds;
-		TypeBinding targetType = site.invocationTargetType();
-		if (targetType == null || !targetType.isProperType(true)) {
-			if (!site.getExpressionContext().definesTargetType()) {
-				// in this case we may not yet have the solution(?, get or compute it now:
-				Solution solution = this.solutionsPerTargetType.get(targetType);
-				try {
-					if (solution != null && solution.bounds != null)
-						bounds = solution.bounds;
-					else
-						bounds = inferInvocationType(this.currentBounds, null, site, method.shallowOriginal());
-				} catch (InferenceFailureException e) {
-					return false;
-				}
-				if (bounds == null)
-					return false;
-			}
-		} else {
-			Solution solution = this.solutionsPerTargetType.get(targetType);
-			if (solution != null && solution.bounds != null)
-				bounds = solution.bounds;
-		}
-		rebindInnerPolies(bounds, method.parameters);
-		return true;
-	}
-
-	/**
-	 * After inference has finished, iterate all inner poly expressions (Invocations), that
-	 * have been included in the inference. For each of these update some type information
-	 * from the inference result and perhaps trigger follow-up resolving as needed.
-	 * Similar for poly expressions that did not directly participate in the inference
-	 * but are direct arguments of the current invocation (FunctionalExpression, ConditionalExpression).
-	 */
-	public void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes) {
-		// This updates all remaining poly expressions that are direct arguments of the current invocation:
-		// (handles FunctionalExpression & ConditionalExpression)
-		if (this.currentInvocation instanceof ReferenceExpression)
-			return; // no inner expressions
-		boolean isVarargs = this.inferenceKind == CHECK_VARARG;
-		acceptPendingPolyArguments(bounds, parameterTypes, isVarargs);
-		// This loops over all poly expressions for which a sub-inference was triggered:
-		// (handles generic invocations)
-		int len = this.innerPolies.size();
-		for (int i = 0; i < len; i++) {
-			Expression inner = (Expression) this.innerPolies.get(i);
-			if (inner instanceof ReferenceExpression) {
-				ReferenceExpression referenceExpression = (ReferenceExpression) inner;
-				MethodBinding compileTimeDecl = referenceExpression.prepareForInferenceResult(this.scope);
-				if	(compileTimeDecl != null) {
-	  				TypeVariableBinding[] variables = compileTimeDecl.typeVariables;
-					if (variables != Binding.NO_TYPE_VARIABLES) {
-						TypeBinding[] arguments = getSolutions(variables, (InvocationSite) inner, bounds);
-						referenceExpression.binding = this.environment.createParameterizedGenericMethod(compileTimeDecl, arguments);
-					}
-				}
-			} else if (inner instanceof Invocation) {
-				Invocation innerMessage = (Invocation) inner;
-				TypeBinding innerTargetType = inner.expectedType(); // may be set from acceptPendingPolyArguments
-				if (innerTargetType != null && !innerTargetType.isProperType(true))
-					innerTargetType = null;
-				MethodBinding binding = innerMessage.binding(innerTargetType, innerTargetType != null, this.scope);
-				if (binding == null)
-					continue;
-				MethodBinding original = binding.shallowOriginal();
-
-				// apply inference results onto the allocation type of inner diamonds:
-				if (original.isConstructor() && inner.isPolyExpression()) {
-					ReferenceBinding declaringClass = original.declaringClass;
-					TypeBinding[] arguments = getSolutions(declaringClass.typeVariables(), innerMessage, bounds);
-					declaringClass = this.environment.createParameterizedType(declaringClass, arguments, declaringClass.enclosingType());
-					original = ((ParameterizedTypeBinding)declaringClass).createParameterizedMethod(original);
-					inner.checkAgainstFinalTargetType(innerTargetType, this.scope);	
-					if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
-						NullAnnotationMatching.checkForContraditions(original, innerMessage, this.scope);
-				}
-				
-				// apply results of the combined inference onto the binding of the inner invocation:
-				TypeBinding[] solutions = getSolutions(original.typeVariables(), innerMessage, bounds);
-				if (solutions == null) {
-					if (binding instanceof ParameterizedGenericMethodBinding) {
-						InferenceContext18 innerCtx = innerMessage.getInferenceContext((ParameterizedGenericMethodBinding) binding);
-						if (innerCtx != null && !binding.isValidBinding()) {
-							innerCtx.reportInvalidInvocation(innerMessage, binding);
-						}
-					}
-					continue; // inner inference not requested -> not a problem
-				}
-				ParameterizedGenericMethodBinding innerBinding = this.environment.createParameterizedGenericMethod(original, solutions);
-				
-				if (innerMessage.updateBindings(innerBinding, innerTargetType)) { // only if we are actually improving anything
-					ASTNode.resolvePolyExpressionArguments(innerMessage, innerBinding, this.scope);
-				}
-			}
-		}
-		this.stepCompleted = BINDINGS_UPDATED; // we're done-done
-	}
-
-	private void acceptPendingPolyArguments(BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs) {
-		if (acceptedResult == null || this.invocationArguments == null) return;
-		Substitution substitution = getResultSubstitution(acceptedResult);
-		for (int i = 0; i < this.invocationArguments.length; i++) {
-			TypeBinding targetType = getParameter(parameterTypes, i, isVarArgs);
-			if (!targetType.isProperType(true))
-				targetType = Scope.substitute(substitution, targetType);
-			Expression expression = this.invocationArguments[i];
-			if (expression instanceof Invocation) {
-				Invocation invocation = (Invocation) expression;
-				if (!this.innerPolies.contains(invocation)) {
-					MethodBinding method = invocation.binding(targetType, true, this.scope);
-					if (method instanceof ParameterizedGenericMethodBinding) {
-						ParameterizedGenericMethodBinding previousBinding = (ParameterizedGenericMethodBinding) method;
-						InferenceContext18 innerCtx = invocation.getInferenceContext(previousBinding);
-						if (innerCtx != null) {
-							// we have a non-poly generic invocation, which needs inference but is not connected via innerPolis.
-							// Finish that inner inference now (incl. binding updates):
-							MethodBinding innerBinding = innerCtx.inferInvocationType(invocation, previousBinding);
-							if (!innerBinding.isValidBinding()) {
-								innerCtx.reportInvalidInvocation(invocation, innerBinding);
-							}
-							if (invocation.updateBindings(innerBinding, targetType)) { // only if we are actually improving anything
-								ASTNode.resolvePolyExpressionArguments(invocation, innerBinding, this.scope);
-							}
-						}
-					} else if(method instanceof ParameterizedMethodBinding){
-						expression.checkAgainstFinalTargetType(targetType, this.scope);
-					}
-				} else {
-					expression.setExpectedType(targetType);
-				}
-			} else {
-				if (this.innerPolies.contains(expression)) // may get here for ReferenceExpressions ...
-					expression.setExpectedType(targetType); // ... prepare for final inference via rebindInnerPolies
-				else
-					expression.checkAgainstFinalTargetType(targetType, this.scope);
-			}
-		}
-	}
-
 	private Substitution getResultSubstitution(final BoundSet result) {
 		return new Substitution() {
 			public LookupEnvironment environment() { 
@@ -1581,21 +1363,16 @@ public class InferenceContext18 {
 			if (method.returnType.erasure().isCompatibleWith(expectedType))
 				return method; // don't count as problem.
 		}
-		if (expectedType == null)
-			return method; // assume inference failure concerned another expression
-		ProblemMethodBinding problemMethod = new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.ParameterizedMethodExpectedTypeProblem);
+		/* We used to check if expected type is null and if so return method, but that is wrong - it injects an incompatible method into overload resolution.
+		   if we get here with expected type set to null at all, the target context does not define a target type (vanilla context), so inference has done its
+		   best and nothing more to do than to signal error. 
+		 */
+		ProblemMethodBinding problemMethod = new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.InvocationTypeInferenceFailure);
 		problemMethod.returnType = expectedType;
 		problemMethod.inferenceContext = this;
 		return problemMethod;
 	}
 
-	public void reportInvalidInvocation(Invocation invocation, MethodBinding binding) {
-		if (invocation instanceof MessageSend)
-			this.scope.problemReporter().invalidMethod((MessageSend) invocation, binding);
-		else
-			this.scope.problemReporter().invalidConstructor((Statement)invocation, binding);
-	}
-
 	// debugging:
 	public String toString() {
 		StringBuffer buf = new StringBuffer("Inference Context"); //$NON-NLS-1$
@@ -1635,12 +1412,6 @@ public class InferenceContext18 {
 		return buf.toString();
 	}
 
-	public void addProblemMethod(ProblemMethodBinding problemMethod) {
-		if (this.problemMethods == null)
-			this.problemMethods = new ArrayList<MethodBinding>();
-		this.problemMethods.add(problemMethod);
-	}
-
 	/**
 	 * If 'type' is a parameterized type and one of its arguments is a wildcard answer the casted type, else null.
 	 * A nonnull answer is ensured to also have nonnull arguments.
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 2e96a4b..f3703e5 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -31,6 +31,7 @@ import org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;
 import org.eclipse.jdt.internal.compiler.ast.Wildcard;
 import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
 import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.Solution;
 
 /**
  * Binding denoting a generic method after type parameter substitutions got performed.
@@ -41,7 +42,7 @@ import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
 public class ParameterizedGenericMethodBinding extends ParameterizedMethodBinding implements Substitution {
 
     public TypeBinding[] typeArguments;
-    private LookupEnvironment environment;
+    protected LookupEnvironment environment;
     public boolean inferredReturnType;
     public boolean wasInferred; // only set to true for instances resulting from method invocation inferrence
     public boolean isRaw; // set to true for method behaving as raw for substitution purpose
@@ -50,31 +51,11 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 	/**
 	 * Perform inference of generic method type parameters and/or expected type
 	 * <p>
-	 * In 1.8+ the following discipline has to be observed by callers:
-	 * Each invocation must be subjected to two levels of inference:
-	 * </p>
-	 * <ul>
-	 * <li> {@link Scope#APPLICABILITY Invocation Applicability Inference}, which may be applied
-	 *     multiple times for the same invocation</li>
-	 * <li> {@link Scope#INVOCATION_TYPE Invocation Type Inference}, which is finally performed
-	 *     for the selected method and which adds information from the "target type".</li>
-	 * </ul>
-	 * <p>
-	 * Clients can control which parts of the inference should be performed by passing the appropriate
-	 * flags into argument 'inferenceLevel'. On each call path it must be ensured that one or more
-	 * invocation applicability inferences are always followed by exactly one invocation type inference
-	 * (unless errors have been detected).
-	 * </p>
-	 * <p>
-	 * Initial clients are the direct callers of
-	 * {@link Scope#computeCompatibleMethod(MethodBinding,TypeBinding[],InvocationSite,int)},
-	 * which should either invoke both levels of inference <em>or</em> delegate the second part to
-	 * {@link Scope#mostSpecificMethodBinding(MethodBinding[],int,TypeBinding[],InvocationSite,ReferenceBinding)},
-	 * which is intended to ensure completing the inference on all non-error exits.
+	 * In 1.8+ if the expected type is not yet available due to this call being an argument to an outer call which is not overload-resolved yet,
+	 * the returned method binding will be a PolyParameterizedGenericMethodBinding.
 	 * </p>  
 	 */
-	public static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,
-			InvocationSite invocationSite, int inferenceLevel)
+	public static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,	InvocationSite invocationSite)
 	{
 		ParameterizedGenericMethodBinding methodSubstitute;
 		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
@@ -95,126 +76,36 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 			// initializes the map of substitutes (var --> type[][]{ equal, extends, super}
 			TypeBinding[] parameters = originalMethod.parameters;
 
-// ==== 1.8: The main driver for inference of generic methods: ====
-			InferenceContext18 infCtx18 = null;
 			CompilerOptions compilerOptions = scope.compilerOptions();
-			if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8) {
-				if ((inferenceLevel & Scope.APPLICABILITY) != 0)
-					infCtx18 = invocationSite.freshInferenceContext(scope);
-				else if (invocationSite instanceof Invocation && originalMethod instanceof ParameterizedGenericMethodBinding)
-					infCtx18 = ((Invocation) invocationSite).getInferenceContext((ParameterizedGenericMethodBinding) originalMethod);
-				if (infCtx18 == null)
-					return originalMethod;
-			}
-			if (infCtx18 != null) {
-				try {
-					BoundSet provisionalResult = null;
-					BoundSet result = null;
-					if ((inferenceLevel & Scope.APPLICABILITY) != 0) {
+			if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8)
+				return computeCompatibleMethod18(originalMethod, arguments, scope, invocationSite);
 
-						// ---- 18.5.1 (Applicability): ----
-						boolean isDiamond = originalMethod.isConstructor()
-								&& invocationSite instanceof Expression
-								&& ((Expression)invocationSite).isPolyExpression(originalMethod);
-						if (arguments.length == parameters.length) {
-							infCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.
-							infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
-							provisionalResult = infCtx18.solve();
-						}
-						if (provisionalResult == null && originalMethod.isVarargs()) {
-							// check for variable-arity applicability
-							infCtx18 = invocationSite.freshInferenceContext(scope); // start over
-							infCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;
-							infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
-							provisionalResult = infCtx18.solve();
-						}
-						if (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {
-							infCtx18.storedSolution = provisionalResult;
-							infCtx18.stepCompleted = InferenceContext18.APPLICABILITY_INFERRED;
-							if (invocationSite instanceof ReferenceExpression)
-								((ReferenceExpression) invocationSite).inferenceKind = infCtx18.inferenceKind;
-						}
-					} else {
-						provisionalResult = infCtx18.storedSolution;
-					}
-					result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()
+			// 1.7- only.
+			inferenceContext = new InferenceContext(originalMethod);
+			methodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, inferenceContext);
+			if (methodSubstitute == null)
+				return null;
 
+			// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method
+			// 15.12.2.8 - inferring unresolved type arguments
+			if (inferenceContext.hasUnresolvedTypeArgument()) {
+				if (inferenceContext.isUnchecked) { // only remember unchecked status post 15.12.2.7
+					int length = inferenceContext.substitutes.length;
+					System.arraycopy(inferenceContext.substitutes, 0, uncheckedArguments = new TypeBinding[length], 0, length);
+				}
+				if (methodSubstitute.returnType != TypeBinding.VOID) {
 					TypeBinding expectedType = invocationSite.invocationTargetType();
-					boolean hasReturnProblem = false;
-					boolean invocationTypeInferred = false;
-					if ((inferenceLevel & Scope.INVOCATION_TYPE) != 0 // requested?
-							&& (expectedType != null || !invocationSite.getExpressionContext().definesTargetType())) { // possible?
-
-						// ---- 18.5.2 (Invocation type): ----
-						result = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod);
-						invocationTypeInferred = true;
-						hasReturnProblem |= result == null;
-						if (hasReturnProblem)
-							result = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all
+					if (expectedType != null) {
+						// record it was explicit from context, as opposed to assumed by default (see below)
+						inferenceContext.hasExplicitExpectedType = true;
 					} else {
-						// we're not yet ready for invocation type inference
-						result = provisionalResult;
+						expectedType = scope.getJavaLangObject(); // assume Object by default
 					}
-
-					if (result != null) {
-						// assemble the solution etc:
-						TypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);
-						if (solutions != null) {
-							
-							methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
-							if (hasReturnProblem) { // illegally working from the provisional result?
-								MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
-								if (problemMethod instanceof ProblemMethodBinding)
-									return problemMethod;
-							}
-							if (invocationTypeInferred) {
-								if (compilerOptions.isAnnotationBasedNullAnalysisEnabled)
-									NullAnnotationMatching.checkForContraditions(methodSubstitute, invocationSite, scope);
-								infCtx18.rebindInnerPolies(result, methodSubstitute.parameters);
-								MethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments);
-								if (problemMethod != null)
-									return problemMethod;
-							} else {
-								if (invocationSite instanceof Invocation)
-									((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later
-							}
-							return methodSubstitute;
-						}
-					}
-					return null;
-				} catch (InferenceFailureException e) {
-					// FIXME stop-gap measure
-					scope.problemReporter().genericInferenceError(e.getMessage(), invocationSite);
-					return null;
+					inferenceContext.expectedType = expectedType;
 				}
-			} else {
-// ==== 1.8 ====
-				inferenceContext = new InferenceContext(originalMethod);
-				methodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, inferenceContext);
+				methodSubstitute = methodSubstitute.inferFromExpectedType(scope, inferenceContext);
 				if (methodSubstitute == null)
 					return null;
-				
-				// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method
-				// 15.12.2.8 - inferring unresolved type arguments
-				if (inferenceContext.hasUnresolvedTypeArgument()) {
-					if (inferenceContext.isUnchecked) { // only remember unchecked status post 15.12.2.7
-						int length = inferenceContext.substitutes.length;
-						System.arraycopy(inferenceContext.substitutes, 0, uncheckedArguments = new TypeBinding[length], 0, length);
-					}
-					if (methodSubstitute.returnType != TypeBinding.VOID) {
-						TypeBinding expectedType = invocationSite.invocationTargetType();
-						if (expectedType != null) {
-							// record it was explicit from context, as opposed to assumed by default (see below)
-							inferenceContext.hasExplicitExpectedType = true;
-						} else {
-							expectedType = scope.getJavaLangObject(); // assume Object by default
-						}
-						inferenceContext.expectedType = expectedType;
-					}
-					methodSubstitute = methodSubstitute.inferFromExpectedType(scope, inferenceContext);
-					if (methodSubstitute == null)
-						return null;
-				}
 			}
 		}
 
@@ -266,6 +157,93 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 		return methodSubstitute;
 	}
 
+	public static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite) {
+		
+		ParameterizedGenericMethodBinding methodSubstitute = null;
+		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
+		InferenceContext18 infCtx18 = null;
+		TypeBinding[] parameters = originalMethod.parameters;
+		infCtx18 = invocationSite.freshInferenceContext(scope);
+		CompilerOptions compilerOptions = scope.compilerOptions();
+		boolean invocationTypeInferred = false;
+		
+		try {
+			BoundSet provisionalResult = null;
+			BoundSet result = null;
+			// ---- 18.5.1 (Applicability): ----
+			final boolean isPolyExpression = invocationSite instanceof Expression && ((Expression)invocationSite).isPolyExpression(originalMethod);
+			boolean isDiamond = isPolyExpression && originalMethod.isConstructor();
+			if (arguments.length == parameters.length) {
+				infCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.
+				infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
+				result = infCtx18.solve();
+			}
+			if (result == null && originalMethod.isVarargs()) {
+				// check for variable-arity applicability
+				infCtx18 = invocationSite.freshInferenceContext(scope); // start over
+				infCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;
+				infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
+				result = infCtx18.solve();
+			}
+			if (result == null)
+				return null;
+			if (infCtx18.isResolved(result)) {
+				infCtx18.stepCompleted = InferenceContext18.APPLICABILITY_INFERRED;
+				if (invocationSite instanceof ReferenceExpression)
+					((ReferenceExpression) invocationSite).inferenceKind = infCtx18.inferenceKind;   // CHECK
+			} else {
+				return null;
+			}
+			// Applicability succeeded, proceed to infer invocation type, if possible.
+			TypeBinding expectedType = invocationSite.invocationTargetType();
+			boolean hasReturnProblem = false;
+			if (expectedType != null || !invocationSite.getExpressionContext().definesTargetType()) {
+				// ---- 18.5.2 (Invocation type): ----
+				provisionalResult = result;
+				result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()
+				result = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod);
+				invocationTypeInferred = true;
+				hasReturnProblem |= result == null;
+				if (hasReturnProblem)
+					result = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all
+			}
+			if (result != null) {
+				// assemble the solution etc:
+				TypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);
+				if (solutions != null) {
+					methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
+					if (hasReturnProblem) { // illegally working from the provisional result?
+						MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
+						if (problemMethod instanceof ProblemMethodBinding) {
+							methodSubstitute = null;
+							return problemMethod;
+						}
+					}
+					if (invocationTypeInferred) {
+						if (compilerOptions.isAnnotationBasedNullAnalysisEnabled)
+							NullAnnotationMatching.checkForContraditions(methodSubstitute, invocationSite, scope);
+						MethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments);
+						if (problemMethod != null) {
+							methodSubstitute = null;
+							return problemMethod;
+						}
+						infCtx18.solutionsPerTargetType.put(expectedType, new Solution(methodSubstitute, result));
+					} else {
+						methodSubstitute = new PolyParameterizedGenericMethodBinding(methodSubstitute);
+					}
+					if (invocationSite instanceof Invocation)
+						((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later
+					return methodSubstitute; 
+				}
+			}
+			return null;
+		} catch (InferenceFailureException e) {
+			// FIXME stop-gap measure
+			scope.problemReporter().genericInferenceError(e.getMessage(), invocationSite);
+			return null;
+		}
+	}
+	
 	MethodBinding boundCheck18(Scope scope, TypeBinding[] arguments) {
 		Substitution substitution = this;
 		ParameterizedGenericMethodBinding methodSubstitute = this;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
new file mode 100644
index 0000000..5aaae89
--- /dev/null
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyParameterizedGenericMethodBinding.java
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2014 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.lookup;
+
+public class PolyParameterizedGenericMethodBinding extends ParameterizedGenericMethodBinding { // confused citizen.
+
+	public PolyParameterizedGenericMethodBinding(ParameterizedGenericMethodBinding applicableMethod) {
+		super(applicableMethod.originalMethod, applicableMethod.typeArguments, applicableMethod.environment);
+	}
+}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
index 5c75b90..fdbd2f1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/PolyTypeBinding.java
@@ -51,6 +51,11 @@ public class PolyTypeBinding extends TypeBinding {
 	public boolean isPolyType() {
 		return true;
 	}
+	
+	@Override
+	public boolean isFunctionalType() {
+		return this.expression.isFunctionalType();
+	}
 
 	public char[] qualifiedSourceName() {
 		return readableName();
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
index b3d6005..21d07eb 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ProblemReasons.java
@@ -40,10 +40,10 @@ public interface ProblemReasons {
 	final int NonStaticOrAlienTypeReceiver = 20;
 	final int AttemptToBypassDirectSuper = 21; // super access within default method
 	final int DefectiveContainerAnnotationType = 22;
-	final int ParameterizedMethodExpectedTypeProblem = 23;
+	final int InvocationTypeInferenceFailure = 23;
 	final int ApplicableMethodOverriddenByInapplicable = 24;
 	final int ContradictoryNullAnnotations = 25;
 	final int NoSuchMethodOnArray = 26;
-	final int InferredAppliableMethodInapplicable = 27; // 18.5.1 ignores arguments not pertinent to applicability. When these are taken into consideration method could fail applicability
+	final int InferredApplicableMethodInapplicable = 27; // 18.5.1 ignores arguments not pertinent to applicability. When these are taken into consideration method could fail applicability
 	final int NoProperEnclosingInstance = 28;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
index e14c75f..31700af 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
@@ -205,6 +205,11 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 		}
 		this.arguments = typeArguments;
 	}
+		
+	@Override 
+	public TypeBinding uncapture(Scope scope) {
+		return this;
+	}
 	
 	@Override
 	TypeBinding substituteInferenceVariable(InferenceVariable var, TypeBinding substituteType) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
index f0c5681..3f91c48 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java
@@ -87,19 +87,9 @@ public abstract class Scope {
 	public static final int NOT_RELATED = 0;
 	public static final int MORE_GENERIC = 1;
 
-	/*
-	 * Flags for PGMB.computeCompatibleMethod() and its callers, to request
-	 * which of two levels of inference should be performed (or both).
-	 */
-	/** Request Invocation Applicability Inference (18.5.1). */
-	public static final int APPLICABILITY = 1;
-	/** Request Invocation Type Inference (18.5.2). */
-	public static final int INVOCATION_TYPE = 2;
-	/** Request both {@link #APPLICABILITY} and {@link #INVOCATION_TYPE} inference. */
-	public static final int FULL_INFERENCE = APPLICABILITY | INVOCATION_TYPE;
-
 	public int kind;
 	public Scope parent;
+	
 
 	protected Scope(int kind, Scope parent) {
 		this.kind = kind;
@@ -691,10 +681,10 @@ public abstract class Scope {
 	 * Internal use only
 	 * Given a method, returns null if arguments cannot be converted to parameters.
 	 * Will answer a substituted method in case the method was generic and type inference got triggered;
-	 * in case the method was originally compatible, then simply answer it back.
+	 * in case the method was originally compatible, then simply answer it back. 
 	 */
-	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, int inferenceLevel) {
-		return computeCompatibleMethod(method, arguments, invocationSite, inferenceLevel, false);
+	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite) {
+		return computeCompatibleMethod(method, arguments, invocationSite, false);
 	}	
 	/**
 	 * Internal use only
@@ -702,8 +692,7 @@ public abstract class Scope {
 	 * Will answer a substituted method in case the method was generic and type inference got triggered;
 	 * in case the method was originally compatible, then simply answer it back.
 	 */
-	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments,
-			InvocationSite invocationSite, int inferenceLevel, boolean tiebreakingVarargsMethods)
+	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, boolean tiebreakingVarargsMethods)
 	{
 		TypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();
 		TypeBinding[] parameters = method.parameters;
@@ -738,9 +727,15 @@ public abstract class Scope {
 				arguments = newArgs;
 			else  // ensure that computeCompatibleMethod() below can update arguments without harming our caller: (TODO: always copy before the loop? only in 1.8?)
 				System.arraycopy(arguments, 0, arguments=new TypeBinding[argLength], 0, argLength);
-			method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite, inferenceLevel);
+			method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite);
 			if (method == null) return null; // incompatible
 			if (!method.isValidBinding()) return method; // bound check issue is taking precedence
+			if (compilerOptions.sourceLevel >= ClassFileConstants.JDK1_8 && method instanceof ParameterizedGenericMethodBinding && invocationSite instanceof Invocation) {
+				Invocation invocation = (Invocation) invocationSite;
+				InferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);
+				if (infCtx != null)
+					return method; // inference is responsible, no need to recheck, actually we could check functional arguments, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c125
+			}
 		} else if (genericTypeArguments != null && compilerOptions.complianceLevel < ClassFileConstants.JDK1_7) {
 			if (method instanceof ParameterizedGenericMethodBinding) {
 				if (!((ParameterizedGenericMethodBinding) method).wasInferred)
@@ -755,7 +750,7 @@ public abstract class Scope {
 			if (CompilerOptions.tolerateIllegalAmbiguousVarargsInvocation && compilerOptions.complianceLevel < ClassFileConstants.JDK1_7)
 				tiebreakingVarargsMethods = false;
 		}
-		if ((parameterCompatibilityLevel18(method, arguments, tiebreakingVarargsMethods, invocationSite)) > NOT_COMPATIBLE) {
+		if ((parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods)) > NOT_COMPATIBLE) {
 			if ((method.tagBits & TagBits.AnnotationPolymorphicSignature) != 0) {
 				// generate polymorphic method
 				return this.environment().createPolymorphicMethod(method, arguments);
@@ -767,152 +762,12 @@ public abstract class Scope {
 		// in which case this problem category will be bogus
 		if (genericTypeArguments != null && typeVariables != Binding.NO_TYPE_VARIABLES)
 			return new ProblemMethodBinding(method, method.selector, arguments, ProblemReasons.ParameterizedMethodTypeMismatch);
+		// 18.5.1 ignores arguments not pertinent to applicability. When these are taken into consideration method could fail applicability (e.g, lambda shape/arity mismatch ...)
+		if (method instanceof PolyParameterizedGenericMethodBinding) // Not reached, but left in for now.
+			return new ProblemMethodBinding(method, method.selector, method.parameters, ProblemReasons.InferredApplicableMethodInapplicable);
 		return null; // incompatible
 	}
 
-	private int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {
-		jdk18checks:
-		if (site instanceof Invocation && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_8) {
-			Invocation invocation = (Invocation) site;
-			if (method instanceof ParameterizedGenericMethodBinding) {
-				InferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);
-				if (infCtx != null) {
-					// inference is responsible, no need to recheck
-					if (infCtx.isVarArgs())
-						return VARARGS_COMPATIBLE;
-					return COMPATIBLE;
-				}
-			}
-			// collect inner invocations where the outer did not involve any inference:
-			Expression[] invocationArguments = invocation.arguments();
-			if (invocationArguments != null) {
-				InnerInferenceHelper innerInferenceHelper = invocation.innerInferenceHelper();
-				int argLen = invocationArguments.length;
-				boolean isVarArgs[] = new boolean[1]; // emulate an in-out parameter for compatibilityLevel18FromInner(..)
-				isVarArgs[0] = method.isVarargs() && argLen != method.parameters.length; // if same lengths, isVarArgs can still be updated below
-				int level = COMPATIBLE;
-				for (int i = 0; i < argLen; i++) {
-					TypeBinding argumentType = i < arguments.length ? arguments[i] : null; // length mismatch may happen from CodeSnippetMessageSend.resolveType() in the if (argHasError) block.
-					int nextLevel = compatibilityLevel18FromInner(method, innerInferenceHelper, invocationArguments[i], argumentType, argLen, i, isVarArgs);
-					if (nextLevel == NOT_COMPATIBLE)
-						return nextLevel;
-					if (nextLevel == -2)
-						break jdk18checks;
-					level = Math.max(level,  nextLevel);
-				}
-				return level; // neither NOT_COMPATIBLE nor unknown(-2) seen
-			}
-		}
-		// fall back to old method:
-		boolean tolerateInferenceVariables = ((site instanceof ReferenceExpression) && ((ReferenceExpression) site).trialResolution);
-		return parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods, tolerateInferenceVariables);
-	}
-
-	private int compatibilityLevel18FromInner(MethodBinding method, InnerInferenceHelper innerInferenceHelper, Expression invocArg, TypeBinding argType, int argLen, int i, boolean[] isVarArgs)
-	{
-		int compatible = isVarArgs[0] ? VARARGS_COMPATIBLE : COMPATIBLE;
-		TypeBinding resolvedType = invocArg.resolvedType;
-		TypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, isVarArgs[0]);
-		if (!isVarArgs[0] && shouldTryVarargs(method, resolvedType, targetType)) {
-			isVarArgs[0] = true;
-			targetType = InferenceContext18.getParameter(method.parameters, i, true);
-		}
-		if (targetType == null)
-			return NOT_COMPATIBLE; // mismatching number of args or other severe problem inside method binding
-		int level = -2; // don't know
-		if (invocArg instanceof Invocation && resolvedType != null) {
-			Invocation innerPoly = (Invocation) invocArg;
-			level = parameterCompatibilityLevel(resolvedType, targetType);
-			if (level != NOT_COMPATIBLE) {
-				if (TypeBinding.notEquals(argType, resolvedType) && innerInferenceHelper != null)
-					innerInferenceHelper.registerInnerResult(method, resolvedType, argLen, i);
-				return Math.max(compatible, level);
-			} else {
-				MethodBinding innerBinding = innerPoly.binding(null, false, null); // 1. try without update
-				if (innerBinding instanceof ParameterizedGenericMethodBinding) {
-					ParameterizedGenericMethodBinding innerParameterized = (ParameterizedGenericMethodBinding) innerBinding;
-					InferenceContext18 infCtx18 = innerPoly.getInferenceContext(innerParameterized);
-					if (infCtx18 != null && !infCtx18.hasResultFor(targetType)) {
-						// not detected as compatible, because inference still needs to complete?
-						invocArg.setExpectedType(targetType);
-						MethodBinding solution = infCtx18.inferInvocationType(innerPoly, innerParameterized);
-						if (solution != null && solution.isValidBinding()) {
-							if (innerPoly.updateBindings(solution, targetType)) {
-								if (innerInferenceHelper != null)
-									innerInferenceHelper.registerInnerResult(method, invocArg.resolvedType, argLen, i);
-							}
-							if (solution.returnType != null) {
-								level = parameterCompatibilityLevel(solution.returnType, targetType);
-								if (level != NOT_COMPATIBLE)
-									return Math.max(compatible, level);
-							}
-						}
-						invocArg.setExpectedType(null);
-						return NOT_COMPATIBLE;
-					} else if (innerPoly instanceof AllocationExpression) {
-						// not detected as compatible, because its a diamond whose type hasn't yet been inferred?
-						TypeBinding[] typeArguments = resolvedType.typeArguments();
-						if (typeArguments != null && typeArguments.length == 0) {
-							AllocationExpression alloc = (AllocationExpression) innerPoly;
-							if ((alloc.type.bits & ASTNode.IsDiamond) != 0) {
-								// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference
-								if (resolvedType.isCompatibleWith(targetType.erasure(), this))
-									return compatible;
-								return NOT_COMPATIBLE;
-							}
-						}
-					}
-				} else if (innerPoly instanceof AllocationExpression) {
-					MethodBinding updatedMethod = innerPoly.binding(targetType, false, null); // 2. try with updating
-					if (updatedMethod != innerBinding && updatedMethod != null) {
-						if (updatedMethod.isValidBinding()) {
-						if (updatedMethod.declaringClass.isCompatibleWith(targetType))
-							return compatible;
-						return NOT_COMPATIBLE;
-						} else if (updatedMethod.problemId() == ProblemReasons.Ambiguous) {
-							level = -2; // neither good nor bad, answer "unknown"
-						}
-					}
-				}
-			}
-		} else if (invocArg.isPolyExpression()) {
-			if (invocArg instanceof ConditionalExpression) {
-				ConditionalExpression ce = (ConditionalExpression) invocArg;
-				int level1 = compatibilityLevel18FromInner(method, innerInferenceHelper, ce.valueIfTrue, argType, argLen, i, isVarArgs);
-				if (level1 == NOT_COMPATIBLE)
-					return NOT_COMPATIBLE;
-				int level2 = compatibilityLevel18FromInner(method, innerInferenceHelper, ce.valueIfFalse, argType, argLen, i, isVarArgs);
-				if (level2 == NOT_COMPATIBLE)
-					return NOT_COMPATIBLE;
-				return Math.max(level1, level2);
-			}
-			// LE or RE:
-			if (invocArg.isCompatibleWith(targetType, this))
-				return COMPATIBLE;
-			if (!isVarArgs[0] && method.isVarargs()) { // can't use shouldTryVarargs without a resolvedType, so just try it:
-				isVarArgs[0] = true;
-				targetType = InferenceContext18.getParameter(method.parameters, i, true);
-				if (targetType != null && invocArg.isCompatibleWith(targetType, this))
-					return VARARGS_COMPATIBLE;
-			}
-			return NOT_COMPATIBLE;
-		} else if (resolvedType != null && resolvedType.isValidBinding()) {
-			// need to handle "normal" expressions too, since mixed poly/standalone argument lists must be fully analyzed.
-			return parameterCompatibilityLevel(resolvedType, targetType);
-		}
-		return level;
-	}
-
-	private boolean shouldTryVarargs(MethodBinding method, TypeBinding resolvedType, TypeBinding targetType) {
-		if (!method.isVarargs())
-			return false;
-		if (targetType == null)
-			return true;	// off range
-		if (targetType.isArrayType() && resolvedType != null && !resolvedType.isCompatibleWith(targetType, this))
-			return true;	// not a direct match but hope to improve
-		return false;
-	}
-
 	/**
 	 * Connect type variable supertypes, and returns true if no problem was detected
 	 * @param typeParameters
@@ -1267,7 +1122,7 @@ public abstract class Scope {
 			next:
 			for (int i = startFoundSize; i < foundSize; i++) {
 				MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
-				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, APPLICABILITY);
+				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
 				if (compatibleMethod != null) {
 					if (compatibleMethod.isValidBinding()) {
 						if (concreteMatches != null) {
@@ -1297,8 +1152,6 @@ public abstract class Scope {
 					return problemMethod; // can be null
 			}
 			concreteMatch = candidates[0];
-			// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
-			concreteMatch = inferInvocationType(invocationSite, concreteMatch, argumentTypes);
 			if (concreteMatch != null)
 				compilationUnitScope().recordTypeReferences(concreteMatch.thrownExceptions);
 			return concreteMatch;
@@ -1371,7 +1224,7 @@ public abstract class Scope {
 				// targeting a generic method could find an exact match with variable return type
 				if (invocationSite.genericTypeArguments() != null) {
 					// computeCompatibleMethod(..) will return a PolymorphicMethodBinding if needed
-					exactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite, FULL_INFERENCE);
+					exactMethod = computeCompatibleMethod(exactMethod, argumentTypes, invocationSite);
 				} else if ((exactMethod.tagBits & TagBits.AnnotationPolymorphicSignature) != 0) {
 					// generate polymorphic method
 					return this.environment().createPolymorphicMethod(exactMethod, argumentTypes);
@@ -1763,22 +1616,13 @@ public abstract class Scope {
 			// argument type compatibility check
 			for (int i = 0; i < foundSize; i++) {
 				MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
-				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, APPLICABILITY);
+				MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
 				if (compatibleMethod != null) {
 					if (compatibleMethod.isValidBinding()) {
 						if (foundSize == 1 && compatibleMethod.canBeSeenBy(receiverType, invocationSite, this)) {
 							// return the single visible match now
 							if (searchForDefaultAbstractMethod)
 								return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, new MethodBinding [] {compatibleMethod});
-// ==== 1.8: Finalize type inference of generic methods: ====
-							MethodBinding improved = inferInvocationType(invocationSite, compatibleMethod, argumentTypes);
-							if (improved != null && improved.isValidBinding()) {
-								compatibleMethod = improved;
-							} else {
-								problemMethod = improved;
-								continue;
-							}
-// ==== 1.8 ====
 							unitScope.recordTypeReferences(compatibleMethod.thrownExceptions);
 							return compatibleMethod;
 						}
@@ -1887,8 +1731,7 @@ public abstract class Scope {
 			case 1 :
 				if (searchForDefaultAbstractMethod)
 					return findDefaultAbstractMethod(receiverType, selector, argumentTypes, invocationSite, classHierarchyStart, found, new MethodBinding [] { candidates[0] });
-				// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
-				candidate = inferInvocationType(invocationSite, candidates[0], argumentTypes);
+				candidate = candidates[0];
 				if (candidate != null)
 					unitScope.recordTypeReferences(candidate.thrownExceptions);
 				return candidate;
@@ -2380,7 +2223,10 @@ public abstract class Scope {
 		}
 		if (exactMethod == null || !exactMethod.canBeSeenBy(invocationSite, this))
 			return null;
-		if (exactMethod.isVarargs() || exactMethod.typeVariables() != Binding.NO_TYPE_VARIABLES && invocationSite.genericTypeArguments() == null)
+		
+		final TypeBinding[] typeArguments = invocationSite.genericTypeArguments();
+		TypeVariableBinding[] typeVariables = exactMethod.typeVariables();
+		if (exactMethod.isVarargs() || (typeVariables != Binding.NO_TYPE_VARIABLES && (typeArguments == null || typeArguments.length != typeVariables.length)))
 			return null;
 		
 		if (receiverType.isArrayType()) {
@@ -2395,6 +2241,10 @@ public abstract class Scope {
 		{
 			return environment().createGetClassMethod(receiverType, exactMethod, this);
 		}
+		
+		if (typeVariables != Binding.NO_TYPE_VARIABLES) 
+			return environment().createParameterizedGenericMethod(exactMethod, typeArguments);
+	
 		return exactMethod;
 	}
 		
@@ -2417,13 +2267,14 @@ public abstract class Scope {
 		MethodBinding exactConstructor = null;
 		unitScope.recordTypeReference(receiverType);
 		MethodBinding[] methods = receiverType.getMethods(TypeConstants.INIT);
+		final TypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();
 		for (int i = 0, length = methods.length; i < length; i++) {
 			MethodBinding constructor = methods[i];
 			if (!constructor.canBeSeenBy(invocationSite, this))
 				continue;
 			if (constructor.isVarargs())
 				return null;
-			if (constructor.typeVariables() != Binding.NO_TYPE_VARIABLES && invocationSite.genericTypeArguments() == null)
+			if (constructor.typeVariables() != Binding.NO_TYPE_VARIABLES && genericTypeArguments == null)
 				return null;
 			if (exactConstructor == null) {
 				exactConstructor = constructor;
@@ -2431,6 +2282,12 @@ public abstract class Scope {
 				return null;
 			}
 		}
+		final TypeVariableBinding[] typeVariables = exactConstructor.typeVariables();
+		if (typeVariables != Binding.NO_TYPE_VARIABLES) {
+			if (typeVariables.length != genericTypeArguments.length)
+				return null;
+			exactConstructor = environment().createParameterizedGenericMethod(exactConstructor, genericTypeArguments);
+		}
 		return exactConstructor;
 	}
 
@@ -2458,7 +2315,7 @@ public abstract class Scope {
 			if (methodBinding != null && methodBinding.canBeSeenBy(invocationSite, this)) {
 			    // targeting a non generic constructor with type arguments ?
 			    if (invocationSite.genericTypeArguments() != null)
-			    	methodBinding = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, FULL_INFERENCE);
+			    	methodBinding = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
 				return methodBinding;
 			}
 			MethodBinding[] methods = receiverType.getMethods(TypeConstants.INIT, argumentTypes.length);
@@ -2472,7 +2329,7 @@ public abstract class Scope {
 			int compatibleIndex = 0;
 			MethodBinding problemMethod = null;
 			for (int i = 0, length = methods.length; i < length; i++) {
-				MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite, APPLICABILITY);
+				MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite);
 				if (compatibleMethod != null) {
 					if (compatibleMethod.isValidBinding())
 						compatible[compatibleIndex++] = compatibleMethod;
@@ -2495,8 +2352,7 @@ public abstract class Scope {
 					visible[visibleIndex++] = method;
 			}
 			if (visibleIndex == 1) {
-				// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
-				return inferInvocationType(invocationSite, visible[0], argumentTypes);
+				return visible[0];
 			}
 			if (visibleIndex == 0)
 				return new ProblemMethodBinding(
@@ -2760,7 +2616,7 @@ public abstract class Scope {
 								if (foundProblem == null)
 									foundProblem = possible; // answer as error case match
 							} else if (possible.isStatic()) {
-								MethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite, APPLICABILITY);
+								MethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite);
 								if (compatibleMethod != null) {
 									if (compatibleMethod.isValidBinding()) {
 										if (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {
@@ -3596,8 +3452,8 @@ public abstract class Scope {
 			for (int i = (oneParamsLength > twoParamsLength ? twoParamsLength : oneParamsLength) - 2; i >= 0; i--)
 				if (TypeBinding.notEquals(oneParams[i], twoParams[i]) && !oneParams[i].isCompatibleWith(twoParams[i]))
 					return false;
-			if (parameterCompatibilityLevel(one, twoParams, true, false) == NOT_COMPATIBLE
-					&& parameterCompatibilityLevel(two, oneParams, true, false) == VARARGS_COMPATIBLE)
+			if (parameterCompatibilityLevel(one, twoParams, true) == NOT_COMPATIBLE
+					&& parameterCompatibilityLevel(two, oneParams, true) == VARARGS_COMPATIBLE)
 				return true;
 		}
 		return false;
@@ -4372,33 +4228,22 @@ public abstract class Scope {
 	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType) {
 
 		boolean isJdk18 = compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
-
 		// common part for all compliance levels:
 		int[] compatibilityLevels = new int[visibleSize];
 		int compatibleCount = 0;
-		for (int i = 0; i < visibleSize; i++) {
-			TypeBinding[] argTypes = argumentTypes;
-			if (isJdk18 && invocationSite instanceof Invocation) {
-				InnerInferenceHelper innerInferenceHelper = ((Invocation)invocationSite).innerInferenceHelper();
-				if (innerInferenceHelper != null)
-					argTypes = innerInferenceHelper.getArgumentTypesForCandidate(visible[i], argumentTypes);
-			}
-			if ((compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argTypes)) != NOT_COMPATIBLE) {
+		for (int i = 0; i < visibleSize; i++)
+			if ((compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes)) != NOT_COMPATIBLE) {
 				if (i != compatibleCount) {
 					visible[compatibleCount] = visible[i];
 					compatibilityLevels[compatibleCount] = compatibilityLevels[i];
 				}
 				compatibleCount++;
 			}
-		}
-// TODO: Disabled, because we know a situation where this is expected, see https://bugs.eclipse.org/429490
-//		if (compatibleCount != visibleSize) {
-//			problemReporter().genericInferenceProblem("(Recovered) Internal inconsistency while checking invocation ambiguity", invocationSite, ProblemSeverities.Warning); //$NON-NLS-1$
-//		}
+		
 		if (compatibleCount == 0) {
 			return new ProblemMethodBinding(visible[0].selector, argumentTypes, ProblemReasons.NotFound);
 		} else if (compatibleCount == 1) {
-			MethodBinding candidate = inferInvocationType(invocationSite, visible[0], argumentTypes);
+			MethodBinding candidate = visible[0];
 			if (candidate != null)
 				compilationUnitScope().recordTypeReferences(candidate.thrownExceptions);
 			return candidate;
@@ -4408,8 +4253,8 @@ public abstract class Scope {
 			System.arraycopy(compatibilityLevels, 0, compatibilityLevels = new int[compatibleCount], 0, compatibleCount);
 		}
 		
+		
 		MethodBinding[] moreSpecific = new MethodBinding[visibleSize];
-
 		if (isJdk18) {
 			// 15.12.2.5 Choosing the Most Specific Method
 			int count = 0;
@@ -4469,7 +4314,7 @@ public abstract class Scope {
 			if (count == 0) {
 				return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);
 			} else if (count == 1) {
-				MethodBinding candidate = inferInvocationType(invocationSite, moreSpecific[0], argumentTypes);
+				MethodBinding candidate = moreSpecific[0];
 				if (candidate != null)
 					compilationUnitScope().recordTypeReferences(candidate.thrownExceptions);
 				return candidate;
@@ -4523,7 +4368,7 @@ public abstract class Scope {
 							}
 						}
 						MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters,
-								tieBreakInvocationSite, INVOCATION_TYPE, level == VARARGS_COMPATIBLE);
+								tieBreakInvocationSite, level == VARARGS_COMPATIBLE);
 						/* There are 4 choices to consider with current & next :
 						 foo(B) & foo(A) where B extends A
 						 1. the 2 methods are equal (both accept each others parameters) -> want to continue
@@ -4547,8 +4392,7 @@ public abstract class Scope {
 			if (count == 1) {
 				for (int i = 0; i < visibleSize; i++) {
 					if (moreSpecific[i] != null) {
-						// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
-						MethodBinding candidate = inferInvocationType(invocationSite, visible[i], argumentTypes);
+						MethodBinding candidate = visible[i];
 						if (candidate != null)
 							compilationUnitScope().recordTypeReferences(candidate.thrownExceptions);
 						return candidate;
@@ -4669,8 +4513,7 @@ public abstract class Scope {
 				if (mostSpecificExceptions != null && mostSpecificExceptions != current.thrownExceptions) {
 					return new MostSpecificExceptionMethodBinding(current, mostSpecificExceptions);
 				}
-				// 1.8: Before returning give inference a chance to perform outstanding tasks (18.5.2):
-				return inferInvocationType(invocationSite, current, argumentTypes);
+				return current;
 			}
 		}
 
@@ -4735,9 +4578,9 @@ public abstract class Scope {
 	}
 
 	public int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments) {
-		return parameterCompatibilityLevel(method, arguments, false, false);
+		return parameterCompatibilityLevel(method, arguments, false);
 	}	
-	public int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, boolean tolerateInferenceVariables) {
+	public int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods) {
 		TypeBinding[] parameters = method.parameters;
 		int paramLength = parameters.length;
 		int argLength = arguments.length;
@@ -4769,14 +4612,14 @@ public abstract class Scope {
 				TypeBinding param = parameters[lastIndex]; // is an ArrayBinding by definition
 				TypeBinding arg = arguments[lastIndex];
 				if (TypeBinding.notEquals(param, arg)) {
-					level = parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods, tolerateInferenceVariables);
+					level = parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods);
 					if (level == NOT_COMPATIBLE) {
 						// expect X[], is it called with X
 						param = ((ArrayBinding) param).elementsType();
 						if (tiebreakingVarargsMethods) {
 							arg = ((ArrayBinding) arg).elementsType();
 						}
-						if (parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods, tolerateInferenceVariables) == NOT_COMPATIBLE)
+						if (parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods) == NOT_COMPATIBLE)
 							return NOT_COMPATIBLE;
 						level = VARARGS_COMPATIBLE; // varargs support needed
 					}
@@ -4786,7 +4629,7 @@ public abstract class Scope {
 					TypeBinding param = ((ArrayBinding) parameters[lastIndex]).elementsType();
 					for (int i = lastIndex; i < argLength; i++) {
 						TypeBinding arg = (tiebreakingVarargsMethods && (i == (argLength - 1))) ? ((ArrayBinding)arguments[i]).elementsType() : arguments[i];
-						if (TypeBinding.notEquals(param, arg) && parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods, tolerateInferenceVariables) == NOT_COMPATIBLE)
+						if (TypeBinding.notEquals(param, arg) && parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods) == NOT_COMPATIBLE)
 							return NOT_COMPATIBLE;
 					}
 				}  else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();
@@ -4802,7 +4645,7 @@ public abstract class Scope {
 			TypeBinding param = parameters[i];
 			TypeBinding arg = (tiebreakingVarargsMethods && (i == (argLength - 1))) ? ((ArrayBinding)arguments[i]).elementsType() : arguments[i];
 			if (TypeBinding.notEquals(arg,param)) {
-				int newLevel = parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods, tolerateInferenceVariables);
+				int newLevel = parameterCompatibilityLevel(arg, param, env, tiebreakingVarargsMethods);
 				if (newLevel == NOT_COMPATIBLE)
 					return NOT_COMPATIBLE;
 				if (newLevel > level)
@@ -4831,7 +4674,7 @@ public abstract class Scope {
 		return NOT_COMPATIBLE;
 	}
 	
-	private int parameterCompatibilityLevel(TypeBinding arg, TypeBinding param, LookupEnvironment env, boolean tieBreakingVarargsMethods, boolean tolerateInferenceVariables) {
+	private int parameterCompatibilityLevel(TypeBinding arg, TypeBinding param, LookupEnvironment env, boolean tieBreakingVarargsMethods) {
 		// only called if env.options.sourceLevel >= ClassFileConstants.JDK1_5
 		if (arg == null || param == null)
 			return NOT_COMPATIBLE;
@@ -4851,11 +4694,6 @@ public abstract class Scope {
 			if (TypeBinding.equalsEquals(convertedType, param) || convertedType.isCompatibleWith(param, this))
 				return AUTOBOX_COMPATIBLE;
 		}
-		if (tolerateInferenceVariables && (!arg.isProperType(false) || !param.isProperType(false))) {
-			// during type inference involving a ReferenceExpression ignore incompatibility due to an inference variable,
-			// knowing that we will produce constraints that will ensure compatible instantiation (if one exists).
-			return COMPATIBLE; 
-		}
 		return NOT_COMPATIBLE;
 	}
 
@@ -4940,7 +4778,7 @@ public abstract class Scope {
 	   that could instead be invoked with identical results. Return null if no compatible, visible, most specific method
 	   could be found. This method is modeled after Scope.getConstructor and Scope.getMethod.
 	 */
-	public MethodBinding getStaticFactory (ParameterizedTypeBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final Invocation allocationSite) {
+	public MethodBinding getStaticFactory (ParameterizedTypeBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final InvocationSite allocationSite) {
 		
 		// allocationType is the diamond type. originalEnclosingType is the real enclosing type ==> may be parameterized, parameterized with own type variables, raw, just plain type or null.
 		int classTypeVariablesArity = 0;
@@ -5067,7 +4905,7 @@ public abstract class Scope {
 		MethodBinding[] compatible = new MethodBinding[sfi];
 		int compatibleIndex = 0;
 		for (int i = 0; i < sfi; i++) {
-			MethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite, APPLICABILITY);
+			MethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite);
 			if (compatibleMethod != null) {
 				if (compatibleMethod.isValidBinding())
 					compatible[compatibleIndex++] = compatibleMethod;
@@ -5077,10 +4915,6 @@ public abstract class Scope {
 		if (compatibleIndex == 0) {
 			return null;
 		}
-		if (compatibleIndex == 1) {
-			// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
-			compatible[0] = inferInvocationType(allocationSite, compatible[0], argumentTypes);
-		}
 		return compatibleIndex == 1 ? compatible[0] : mostSpecificMethodBinding(compatible, compatibleIndex, argumentTypes, allocationSite, allocationType);
 	}
 
@@ -5151,30 +4985,4 @@ public abstract class Scope {
 			}
 		}
 	}
-
-	/**
-	 * Given a selected applicable method, check if it has an unfinished InferenceContext18 associated.
-	 * If so perform the outstanding Invocation Type Inference and return the improved method,
-	 * otherwise return the applicable method unchanged.
-	 */
-	protected MethodBinding inferInvocationType(InvocationSite invocationSite, MethodBinding applicable, TypeBinding[] argumentTypes) {
-		if (invocationSite instanceof Invocation) {
-			Invocation invocation = (Invocation) invocationSite;
-			if (applicable instanceof ParameterizedGenericMethodBinding) {
-				ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) applicable;
-				InferenceContext18 infCtx18 = invocation.getInferenceContext(parameterizedMethod);
-				if (infCtx18 != null && !infCtx18.hasResultFor(invocation.invocationTargetType())) {
-					return infCtx18.inferInvocationType(invocation, argumentTypes, parameterizedMethod);
-				}
-			} else {
-				ASTNode.resolvePolyExpressionArguments(invocation, applicable, argumentTypes, this);
-			}
-		} else if (invocationSite instanceof ReferenceExpression) {
-			if (applicable instanceof ParameterizedGenericMethodBinding)
-				applicable = applicable.shallowOriginal();
-			if (applicable.typeVariables() != Binding.NO_TYPE_VARIABLES)
-				return ParameterizedGenericMethodBinding.computeCompatibleMethod(applicable, argumentTypes, this, invocationSite, FULL_INFERENCE);
-		}
-		return applicable;
-	}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
index be7515c..2722d4e 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java
@@ -1629,4 +1629,8 @@ public boolean enterRecursiveFunction() {
 public void exitRecursiveFunction() {
 	// empty, subclasses to override
 }
+
+public boolean isFunctionalType() {
+	return false;
+}
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
index b591b03..ddc9502 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/problem/ProblemReporter.java
@@ -150,7 +150,6 @@ import org.eclipse.jdt.internal.compiler.lookup.Binding;
 import org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;
 import org.eclipse.jdt.internal.compiler.lookup.ExtraCompilerModifiers;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
-import org.eclipse.jdt.internal.compiler.lookup.InferenceContext18;
 import org.eclipse.jdt.internal.compiler.lookup.InvocationSite;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;
@@ -3692,7 +3691,8 @@ public void invalidConstructor(Statement statement, MethodBinding targetConstruc
 				sourceStart,
 				sourceEnd);
 			return;
-		case ProblemReasons.ParameterizedMethodExpectedTypeProblem:
+		case ProblemReasons.InferredApplicableMethodInapplicable:	
+		case ProblemReasons.InvocationTypeInferenceFailure:
 			// FIXME(stephan): construct suitable message (https://bugs.eclipse.org/404675)
 			problemConstructor = (ProblemMethodBinding) targetConstructor;
 			shownConstructor = problemConstructor.closestMatch;
@@ -4227,16 +4227,13 @@ public void invalidMethod(MessageSend messageSend, MethodBinding method) {
 				(int) (messageSend.nameSourcePosition >>> 32),
 				(int) messageSend.nameSourcePosition);
 			return;
-		case ProblemReasons.ParameterizedMethodExpectedTypeProblem:
+		case ProblemReasons.InferredApplicableMethodInapplicable:
+		case ProblemReasons.InvocationTypeInferenceFailure:
 			// FIXME(stephan): construct suitable message (https://bugs.eclipse.org/404675)
 			problemMethod = (ProblemMethodBinding) method;
-			InferenceContext18 inferenceContext = problemMethod.inferenceContext;
-			if (inferenceContext != null && inferenceContext.outerContext != null) {
-				// problem relates to a nested inference context, let the outer handle it:
-				inferenceContext.outerContext.addProblemMethod(problemMethod);
-				return;
-			}
 			shownMethod = problemMethod.closestMatch;
+			if (problemMethod.returnType == shownMethod.returnType) //$IDENTITY-COMPARISON$
+				return; // funnily this can happen in a deeply nested call, because the inner lies by stealing its closest match and the outer does not know so. See GRT1_8.testBug430296
 			this.handle(
 				IProblem.TypeMismatch,
 				new String[] {
diff --git a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
index 2ec843f..20c5ed9 100644
--- a/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
+++ b/org.eclipse.jdt.core/eval/org/eclipse/jdt/internal/eval/CodeSnippetScope.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2000, 2013 IBM Corporation and others.
+ * Copyright (c) 2000, 2014 IBM Corporation and others.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -396,7 +396,7 @@ public MethodBinding findMethodForArray(ArrayBinding receiverType, char[] select
 	if (methodBinding == null)
 		return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);
 	if (methodBinding.isValidBinding()) {
-	    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite, Scope.FULL_INFERENCE);
+	    MethodBinding compatibleMethod = computeCompatibleMethod(methodBinding, argumentTypes, invocationSite);
 	    if (compatibleMethod == null)
 			return new ProblemMethodBinding(methodBinding, selector, argumentTypes, ProblemReasons.NotFound);
 	    methodBinding = compatibleMethod;
@@ -542,7 +542,7 @@ public MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[]
 	MethodBinding[] compatible = new MethodBinding[methods.length];
 	int compatibleIndex = 0;
 	for (int i = 0, length = methods.length; i < length; i++) {
-	    MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite, Scope.APPLICABILITY);
+	    MethodBinding compatibleMethod = computeCompatibleMethod(methods[i], argumentTypes, invocationSite);
 		if (compatibleMethod != null)
 			compatible[compatibleIndex++] = compatibleMethod;
 	}
@@ -558,8 +558,7 @@ public MethodBinding getConstructor(ReferenceBinding receiverType, TypeBinding[]
 		}
 	}
 	if (visibleIndex == 1) {
-		// 1.8: Give inference a chance to perform outstanding tasks (18.5.2):
-		return inferInvocationType(invocationSite, visible[0], argumentTypes);
+		return visible[0];
 	}
 	if (visibleIndex == 0) {
 		return new ProblemMethodBinding(compatible[0], TypeConstants.INIT, compatible[0].parameters, ProblemReasons.NotVisible);
commit 192820efad9191d4773fbd88aa6d8a5ea915ea14
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Sat Oct 25 21:13:59 2014 +0530

    Bug 437444 - Addendum for capture bound change under compile time
    constant

6	12	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
16	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
6	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 2110b8b..9b0989f 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -594,9 +594,7 @@ class BoundSet {
 		while (captIter.hasNext()) {
 			Entry<ParameterizedTypeBinding, ParameterizedTypeBinding> capt = captIter.next();
 			ParameterizedTypeBinding gAlpha = capt.getKey();
-			// We come in with capture(gA), we need to work with gA below. It was necessary to establish capture at the call site.
-			ParameterizedTypeBinding cgA = capt.getValue();
-			ParameterizedTypeBinding gA = (ParameterizedTypeBinding) cgA.uncapture(context.scope);
+			ParameterizedTypeBinding gA = capt.getValue();
 			ReferenceBinding g = (ReferenceBinding) gA.original();
 			final TypeVariableBinding[] parameters = g.typeVariables();
 			// construct theta = [P1:=alpha1,...]
@@ -615,7 +613,6 @@ class BoundSet {
 				addBounds(pi.getTypeBounds(alpha, theta), context.environment);
 
 				TypeBinding ai = gA.arguments[i];
-				TypeBinding cai = cgA.arguments[i];
 				if (ai instanceof WildcardBinding) {
 					WildcardBinding wildcardBinding = (WildcardBinding)ai;
 					TypeBinding t = wildcardBinding.bound;
@@ -627,14 +624,11 @@ class BoundSet {
 							it = three.sameBounds.iterator();
 							while (it.hasNext()) {
 								TypeBound bound = it.next();
-								/* With the expected type's declared type being Collector<? super T, A, R> and gAlpha being Collector<T#0,?#1,List<T#0>#2> and cgA being
-								   Collector<T#0,capture#1-of ?,List<T#0>>, without the constraint reduction below - we will never discover A to be capture#1-of ? and
-								   claim A is jlO. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c24 - #27
-								*/
-								if (!reduceOneConstraint(context, ConstraintTypeFormula.create(bound.right, cai, ReductionResult.SAME)))
-									return false;
-								// Our = reduction transitively adds a new bound that necessitates the check below for capture. 
-								if (!(bound.right instanceof InferenceVariable) && !bound.right.isCapture())
+								if (InferenceContext18.SHOULD_WORKAROUND_BUG_JDK_8054721) {
+									if (bound.right instanceof CaptureBinding)
+										continue;
+								}
+								if (!(bound.right instanceof InferenceVariable))
 									return false;
 							}
 						}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 2820638..d327bbe 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -17,6 +17,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Argument;
 import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
@@ -348,7 +349,21 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				InferenceVariable[] betas = inferenceContext.addTypeVariableSubstitutions(arguments);
 				ParameterizedTypeBinding gbeta = inferenceContext.environment.createParameterizedType(
 						parameterizedType.genericType(), betas, parameterizedType.enclosingType(), parameterizedType.getTypeAnnotations());
-				inferenceContext.currentBounds.captures.put(gbeta, parameterizedType.capture(inferenceContext.scope, invocationSite.sourceEnd())); // established: both types have nonnull arguments
+				inferenceContext.currentBounds.captures.put(gbeta, parameterizedType); // established: both types have nonnull arguments
+				if (InferenceContext18.SHOULD_WORKAROUND_BUG_JDK_8054721) {
+					for (int i = 0, length = arguments.length; i < length;i++) {
+						if (arguments[i].isWildcard() && arguments[i].isProperType(true)) {
+							WildcardBinding wildcard = (WildcardBinding) arguments[i];
+							SourceTypeBinding contextType = inferenceContext.scope.enclosingSourceType();
+							int position = invocationSite.sourceEnd();
+							CompilationUnitScope compilationUnitScope = inferenceContext.scope.compilationUnitScope();
+							ASTNode cud = compilationUnitScope.referenceContext;
+							final int captureID = compilationUnitScope.nextCaptureID();
+							CaptureBinding capture = inferenceContext.environment.createCapturedWildcard(wildcard, contextType, position, cud, captureID);
+							inferenceContext.currentBounds.addBound(new TypeBound(betas[i], capture, SAME), inferenceContext.environment);
+						}
+					}
+				}
 				ConstraintTypeFormula newConstraint = ConstraintTypeFormula.create(gbeta, targetType, COMPATIBLE);
 				return inferenceContext.reduceAndIncorporate(newConstraint);
 			}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index d4015ed..d033ba1 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -105,6 +105,12 @@ public class InferenceContext18 {
 
 	/** to conform with javac regarding https://bugs.openjdk.java.net/browse/JDK-8026527 */
 	static final boolean SIMULATE_BUG_JDK_8026527 = true;
+	
+	/** Temporary workaround until we know fully what to do with https://bugs.openjdk.java.net/browse/JDK-8054721 
+	 *  It looks likely that we have a bug independent of this JLS bug in that we clear the capture bounds eagerly.
+	*/
+	static final boolean SHOULD_WORKAROUND_BUG_JDK_8054721 = true; // See https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c24 onwards
+	
 	/**
 	 * Detail flag to control the extent of {@link #SIMULATE_BUG_JDK_8026527}.
 	 * A setting of 'false' implements the advice from http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000447.html
commit b0ee678b65f48d1cfab35972dd53d6bd85389446
Author: ssankaran <srikanth_sankaran@in.ibm.com>
Date:   Tue Oct 28 03:37:46 2014 +0530

    Bug 437444 - Incorporate review comments.

3	1	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
12	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
2	2	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
8	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
3	19	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
11	15	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
7	6	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
1	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
5	0	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
10	3	org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
index 79fd3b7..eafc4e6 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ASTNode.java
@@ -652,6 +652,8 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 	/**
 	 * After method lookup has produced 'methodBinding' but when poly expressions have been seen as arguments,
 	 * inspect the arguments to trigger another round of resolving with improved target types from the methods parameters.
+	 * If this resolving produces better types for any arguments, update the 'argumentTypes' array in-place as an
+	 * intended side effect that will feed better type information in checkInvocationArguments() and others. 
 	 * @param invocation the outer invocation which is being resolved
 	 * @param method the method produced by lookup (possibly involving type inference).
 	 * @param argumentTypes the argument types as collected from first resolving the invocation arguments and as used for the method lookup.
@@ -674,7 +676,7 @@ public abstract class ASTNode implements TypeConstants, TypeIds {
 			TypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);
 			if (parameterType == null)
 				continue; // not much we can do without a target type, assume it only happens after some resolve error
-			if (argumentTypes[i].isPolyType()) {
+			if (argumentTypes[i] != null && argumentTypes[i].isPolyType()) {
 				argument.setExpectedType(parameterType);
 				TypeBinding updatedArgumentType = argument.resolveType(scope); 
 				if (argument instanceof LambdaExpression) {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
index f2da510..35cbef8 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java
@@ -556,8 +556,18 @@ public MethodBinding inferConstructorOfElidedParameterizedType(ParameterizedType
 	// Given the allocation type and the arguments to the constructor, see if we can infer the constructor of the elided parameterized type.
 	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTyps, this);
 	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
-		SyntheticFactoryMethodBinding original = (SyntheticFactoryMethodBinding) factory.original();
-		return original.applyTypeArgumentsOnConstructor(((ParameterizedTypeBinding)factory.returnType).arguments);
+		SyntheticFactoryMethodBinding sfmb = (SyntheticFactoryMethodBinding) factory.original();
+		TypeVariableBinding[] constructorTypeVariables = sfmb.getConstructor().typeVariables();
+		TypeBinding [] constructorTypeArguments = constructorTypeVariables != null ? new TypeBinding[constructorTypeVariables.length] : Binding.NO_TYPES;
+		if (constructorTypeArguments.length > 0)
+			System.arraycopy(((ParameterizedGenericMethodBinding)factory).typeArguments, sfmb.typeVariables().length - constructorTypeArguments.length , 
+												constructorTypeArguments, 0, constructorTypeArguments.length);
+		MethodBinding constructor = sfmb.applyTypeArgumentsOnConstructor(((ParameterizedTypeBinding)factory.returnType).arguments, constructorTypeArguments);
+		if (constructor instanceof ParameterizedGenericMethodBinding && scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
+			// force an inference context to be established, but avoid tunneling through overload resolution. We know this is the MSMB.
+			return ParameterizedGenericMethodBinding.computeCompatibleMethod18(constructor.shallowOriginal(), argumentTyps, scope, this);
+		}
+		return constructor;
 	}
 	return null;
 }
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
index 7f0ccbf..7caa2ff 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ConditionalExpression.java
@@ -719,7 +719,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 	
 	public boolean isPertinentToApplicability(TypeVariableBinding typeVariable, MethodBinding method) {
 		return this.valueIfTrue.isPertinentToApplicability(typeVariable, method) 
-				&& this.valueIfFalse.isPertinentToApplicability(typeVariable, method); // not perfect.
+				&& this.valueIfFalse.isPertinentToApplicability(typeVariable, method);
 	}
 	
 	public boolean isPertinentToApplicability(TypeBinding targetType, MethodBinding method) {
@@ -729,7 +729,7 @@ public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext,
 	
 	@Override
 	public boolean isFunctionalType() {
-		return this.valueIfTrue.isFunctionalType() || this.valueIfFalse.isFunctionalType();
+		return this.valueIfTrue.isFunctionalType() || this.valueIfFalse.isFunctionalType(); // Even if only one arm is functional type, this will require a functional interface target
 	}
 	
 	public boolean isPolyExpression() throws UnsupportedOperationException {
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
index 1db2668..60a8cda 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReferenceExpression.java
@@ -694,6 +694,14 @@ public class ReferenceExpression extends FunctionalExpression implements Invocat
 
 	/** During inference: Try to find an applicable method binding without causing undesired side-effects. */
 	public MethodBinding findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope) {
+		if (this.exactMethodBinding != null) {
+			MethodBinding functionType = targetType.getSingleAbstractMethod(scope, true);
+			if (functionType == null)
+				return null;
+			int n = functionType.parameters.length;
+			int k = this.exactMethodBinding.parameters.length;
+			return (n == k || n == k + 1) ? this.exactMethodBinding : null;
+		}
 		MethodBinding targetMethod = internalResolveTentatively(targetType, scope);
 		if (targetMethod == null || !targetMethod.isValidBinding())
 			return null;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
index 04a14b2..d05c0db 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/BoundSet.java
@@ -631,7 +631,7 @@ class BoundSet {
 							while (it.hasNext()) {
 								TypeBound bound = it.next();
 								if (InferenceContext18.SHOULD_WORKAROUND_BUG_JDK_8054721) {
-									if (bound.right instanceof CaptureBinding)
+									if (bound.right instanceof CaptureBinding && bound.right.isProperType(true))
 										continue;
 								}
 								if (!(bound.right instanceof InferenceVariable))
@@ -978,21 +978,6 @@ class BoundSet {
 		if (three == null) return null;
 		return three.findSingleWrapperType();
 	}
-
-	private TypeBinding applyInstantiations(TypeBinding type) {
-		if (type.isProperType(true))
-			return type;
-	
-		Iterator<InferenceVariable> variableIt = this.boundsPerVariable.keySet().iterator();
-		while (variableIt.hasNext()) {
-			InferenceVariable inferenceVariable = variableIt.next();
-			TypeBinding instantiation = getInstantiation(inferenceVariable, null);
-			if (instantiation != null)
-				type = type.substituteInferenceVariable(inferenceVariable, instantiation);
-		}
-		return type;
-	}
-	
 	// this condition is just way too complex to check it in-line:
 	public boolean condition18_5_2_bullet_3_3_1(InferenceVariable alpha, TypeBinding targetType) {
 		// T is a reference type, but is not a wildcard-parameterized type, and either 
@@ -1032,10 +1017,9 @@ class BoundSet {
 						/* HashMap<K#8,V#9> and HashMap<K#8,ArrayList<T>> with an instantiation for V9 = ArrayList<T> already in the 
 						   bound set should not be seen as two different parameterizations of the same generic class or interface.
 						   See https://bugs.eclipse.org/bugs/show_bug.cgi?id=432626 for a test that triggers this condition.
+						   See https://bugs.openjdk.java.net/browse/JDK-8056092: recommendation is to check for proper types.
 						*/
-						supers[0] = applyInstantiations(supers[0]);
-						supers[1] = applyInstantiations(supers[1]);
-						if (!TypeBinding.equalsEquals(supers[0], supers[1]))
+						if (supers[0].isProperType(true) && supers[1].isProperType(true) && !TypeBinding.equalsEquals(supers[0], supers[1]))
 							return true;
 					}
 				}
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
index 6e3d54c..05eb777 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ConstraintExpressionFormula.java
@@ -84,21 +84,21 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 					if (previousMethod instanceof ParameterizedGenericMethodBinding) {
 						// find the previous inner inference context to see what inference kind this invocation needs:
 						InferenceContext18 innerCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) previousMethod);
-						if (innerCtx == null) { // no inference -> assume it wasn't really poly after all
+						if (innerCtx == null || innerCtx.stepCompleted >= InferenceContext18.TYPE_INFERRED) { 
+							/* No inference context -> the method was likely manufactured by Scope.findExactMethod -> assume it wasn't really poly after all.
+							   Otherwise, either the constraints and initial bounds that would effectively reduce to b3 are already transferred to current context 
+							   during C Set construction. Otherwise all that is relevant is to relate the return type with expected type.
+							*/
 							TypeBinding exprType = this.left.resolvedType;
 							if (exprType == null || !exprType.isValidBinding())
 								return FALSE;
 							return ConstraintTypeFormula.create(exprType, this.right, COMPATIBLE, this.isSoft);
 						}
-						if (innerCtx.stepCompleted >= InferenceContext18.TYPE_INFERRED) {
-							// The constraints and initial bounds that would effectively reduce to b3 are already transferred to current context during C Set construction.
-							// This should really be done only for poly invocations interleaved by a lambda that is not pertinent to applicability. FIXME.
-							return TRUE;
-						}
 						if (innerCtx.stepCompleted >= InferenceContext18.APPLICABILITY_INFERRED) {
 							inferenceContext.currentBounds.addBounds(innerCtx.b2, inferenceContext.environment);
 							inferenceContext.inferenceVariables = innerCtx.inferenceVariables;
 							inferenceContext.inferenceKind = innerCtx.inferenceKind;
+							innerCtx.outerContext = inferenceContext;
 							inferenceContext.usesUncheckedConversion = innerCtx.usesUncheckedConversion;
 						} else {
 							return FALSE; // should not reach here.
@@ -227,9 +227,11 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 		MethodBinding functionType = t.getSingleAbstractMethod(inferenceContext.scope, true);
 		if (functionType == null)
 			return FALSE;
-
+		// potentially-applicable method for the method reference when targeting T (15.13.1),
+		MethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope);
+		if (potentiallyApplicable == null)
+			return FALSE;
 		if (reference.isExactMethodReference()) {
-			MethodBinding potentiallyApplicable = reference.getExactMethod(); 
 			List<ConstraintFormula> newConstraints = new ArrayList<ConstraintFormula>();
 			TypeBinding[] p = functionType.parameters;
 			int n = p.length;
@@ -239,8 +241,6 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			if (n == k+1) {
 				newConstraints.add(ConstraintTypeFormula.create(p[0], reference.lhs.resolvedType, COMPATIBLE));
 				offset = 1;
-			} else if (n != k) {
-				return FALSE;
 			}
 			for (int i = offset; i < n; i++)
 				newConstraints.add(ConstraintTypeFormula.create(p[i], pPrime[i-offset], COMPATIBLE));
@@ -254,10 +254,6 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 			}
 			return newConstraints.toArray(new ConstraintFormula[newConstraints.size()]);
 		} else { // inexact
-			MethodBinding potentiallyApplicable = reference.findCompileTimeMethodTargeting(t, inferenceContext.scope); // // potentially-applicable method for the method reference when targeting T (15.13.1),
-			if (potentiallyApplicable == null)
-				return FALSE;
-			
 			int n = functionType.parameters.length;
 			for (int i = 0; i < n; i++)
 				if (!functionType.parameters[i].isProperType(true))
@@ -379,7 +375,7 @@ class ConstraintExpressionFormula extends ConstraintFormula {
 				ConstraintTypeFormula newConstraint = ConstraintTypeFormula.create(gbeta, targetType, COMPATIBLE);
 				return inferenceContext.reduceAndIncorporate(newConstraint);
 			}
-			if (rTheta.leafComponentType() instanceof InferenceVariable) {
+			if (rTheta.leafComponentType() instanceof InferenceVariable) { // https://bugs.openjdk.java.net/browse/JDK-8062082
 				InferenceVariable alpha = (InferenceVariable) rTheta.leafComponentType();
 				TypeBinding targetLeafType = targetType.leafComponentType();
 				boolean toResolve = false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
index f0a6754..377bd52 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/InferenceContext18.java
@@ -154,7 +154,7 @@ public class InferenceContext18 {
 	/** Signals whether any type compatibility makes use of unchecked conversion. */
 	public List<ConstraintFormula> constraintsWithUncheckedConversion;
 	public boolean usesUncheckedConversion;
-
+	public InferenceContext18 outerContext;
 	Scope scope;
 	LookupEnvironment environment;
 	ReferenceBinding object; // java.lang.Object
@@ -439,11 +439,6 @@ public class InferenceContext18 {
 
 	private boolean addConstraintsToC_OneExpr(Expression expri, Set<ConstraintFormula> c, TypeBinding fsi, TypeBinding substF, MethodBinding method, boolean interleaved) throws InferenceFailureException {
 		
-		// See https://bugs.openjdk.java.net/browse/JDK-8052325 for exclusion of poly expressions targeting proper types. CEF.reduce validates 
-		// that they are compatible in a loose invocation context against the target type. They contribute nothing further to solving the formulas.
-		if (substF.isProperType(true))
-			return true;
-		
 		// For all i (1  i  k), if ei is not pertinent to applicability, the set contains ei   Fi.
 		if (!expri.isPertinentToApplicability(fsi, method)) {
 			c.add(new ConstraintExpressionFormula(expri, substF, ReductionResult.COMPATIBLE, ARGUMENT_CONSTRAINTS_ARE_SOFT));
@@ -472,6 +467,10 @@ public class InferenceContext18 {
 				}
 			}
 		} else if (expri instanceof Invocation && expri.isPolyExpression()) {
+			
+			if (substF.isProperType(true)) // https://bugs.openjdk.java.net/browse/JDK-8052325 
+				return true;
+			
 			Invocation invocation = (Invocation) expri;
 			MethodBinding innerMethod = invocation.binding(substF, this.scope);
 			if (innerMethod == null)
@@ -492,6 +491,8 @@ public class InferenceContext18 {
 				SuspendedInferenceRecord prevInvocation = enterPolyInvocation(invocation, invocation.arguments());
 				try {
 					this.inferenceKind = applicabilityKind;
+					if (innerContext != null)
+						innerContext.outerContext = this;
 					inferInvocationApplicability(shallowMethod, argumentTypes, shallowMethod.isConstructor());
 					if (!ConstraintExpressionFormula.inferPolyInvocationType(this, invocation, substF, shallowMethod))
 						return false;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
index 3831743..db6c90c 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/ParameterizedGenericMethodBinding.java
@@ -190,7 +190,7 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 			if (infCtx18.isResolved(result)) {
 				infCtx18.stepCompleted = InferenceContext18.APPLICABILITY_INFERRED;
 				if (invocationSite instanceof ReferenceExpression)
-					((ReferenceExpression) invocationSite).inferenceKind = infCtx18.inferenceKind;   // CHECK
+					((ReferenceExpression) invocationSite).inferenceKind = infCtx18.inferenceKind;
 			} else {
 				return null;
 			}
@@ -214,7 +214,6 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 					if (hasReturnProblem) { // illegally working from the provisional result?
 						MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
 						if (problemMethod instanceof ProblemMethodBinding) {
-							methodSubstitute = null;
 							return problemMethod;
 						}
 					}
@@ -223,7 +222,6 @@ public class ParameterizedGenericMethodBinding extends ParameterizedMethodBindin
 							NullAnnotationMatching.checkForContraditions(methodSubstitute, invocationSite, scope);
 						MethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments);
 						if (problemMethod != null) {
-							methodSubstitute = null;
 							return problemMethod;
 						}
 						infCtx18.solutionsPerTargetType.put(expectedType, new Solution(methodSubstitute, result));
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
index 31700af..66eea6b 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/RawTypeBinding.java
@@ -206,6 +206,11 @@ public class RawTypeBinding extends ParameterizedTypeBinding {
 		this.arguments = typeArguments;
 	}
 		
+	@Override
+	public ParameterizedTypeBinding capture(Scope scope, int position) {
+		return this;
+	}
+	
 	@Override 
 	public TypeBinding uncapture(Scope scope) {
 		return this;
diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
index 93849cd..38ee5be 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/SyntheticFactoryMethodBinding.java
@@ -29,13 +29,20 @@ public class SyntheticFactoryMethodBinding extends MethodBinding {
 		this.enclosingType = enclosingType;
 	}
 	
-	/** Apply the given type arguments on the (declaring class of the) actual constructor being represented by this factory method. */
-	public ParameterizedMethodBinding applyTypeArgumentsOnConstructor(TypeBinding[] typeArguments) {
+	public MethodBinding getConstructor() {
+		return this.staticFactoryFor;
+	}
+	
+	/** Apply the given type arguments on the (declaring class of the) actual constructor being represented by this factory method and
+	    if method type arguments is not empty materialize the parameterized generic constructor 
+	*/
+	public ParameterizedMethodBinding applyTypeArgumentsOnConstructor(TypeBinding[] typeArguments, TypeBinding[] constructorTypeArguments) {
 		ReferenceBinding parameterizedType = this.environment.createParameterizedType(this.declaringClass, typeArguments,
 																						this.enclosingType);
 		for (MethodBinding parameterizedMethod : parameterizedType.methods()) {
 			if (parameterizedMethod.original() == this.staticFactoryFor)
-				return (ParameterizedMethodBinding) parameterizedMethod;
+				return constructorTypeArguments.length > 0 ? this.environment.createParameterizedGenericMethod(parameterizedMethod, constructorTypeArguments) :
+													         (ParameterizedMethodBinding) parameterizedMethod;
 			if (parameterizedMethod instanceof ProblemMethodBinding) {
 				MethodBinding closestMatch = ((ProblemMethodBinding)parameterizedMethod).closestMatch;
 				if (closestMatch instanceof ParameterizedMethodBinding && closestMatch.original() == this.staticFactoryFor)
